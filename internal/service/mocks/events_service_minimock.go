// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/wDRxxx/eventflow-backend/internal/service.EventsService -o events_service_minimock.go -n EventsServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/wDRxxx/eventflow-backend/internal/models"
)

// EventsServiceMock implements mm_service.EventsService
type EventsServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateEvent          func(ctx context.Context, event *models.Event) (i1 int64, err error)
	funcCreateEventOrigin    string
	inspectFuncCreateEvent   func(ctx context.Context, event *models.Event)
	afterCreateEventCounter  uint64
	beforeCreateEventCounter uint64
	CreateEventMock          mEventsServiceMockCreateEvent

	funcDeleteEvent          func(ctx context.Context, userID int64, urlTitle string) (err error)
	funcDeleteEventOrigin    string
	inspectFuncDeleteEvent   func(ctx context.Context, userID int64, urlTitle string)
	afterDeleteEventCounter  uint64
	beforeDeleteEventCounter uint64
	DeleteEventMock          mEventsServiceMockDeleteEvent

	funcEvent          func(ctx context.Context, urlTitle string) (ep1 *models.Event, err error)
	funcEventOrigin    string
	inspectFuncEvent   func(ctx context.Context, urlTitle string)
	afterEventCounter  uint64
	beforeEventCounter uint64
	EventMock          mEventsServiceMockEvent

	funcEvents          func(ctx context.Context, page int) (epa1 []*models.Event, err error)
	funcEventsOrigin    string
	inspectFuncEvents   func(ctx context.Context, page int)
	afterEventsCounter  uint64
	beforeEventsCounter uint64
	EventsMock          mEventsServiceMockEvents

	funcUpdateEvent          func(ctx context.Context, userID int64, event *models.Event) (err error)
	funcUpdateEventOrigin    string
	inspectFuncUpdateEvent   func(ctx context.Context, userID int64, event *models.Event)
	afterUpdateEventCounter  uint64
	beforeUpdateEventCounter uint64
	UpdateEventMock          mEventsServiceMockUpdateEvent

	funcUserEvents          func(ctx context.Context, userID int64) (epa1 []*models.Event, err error)
	funcUserEventsOrigin    string
	inspectFuncUserEvents   func(ctx context.Context, userID int64)
	afterUserEventsCounter  uint64
	beforeUserEventsCounter uint64
	UserEventsMock          mEventsServiceMockUserEvents
}

// NewEventsServiceMock returns a mock for mm_service.EventsService
func NewEventsServiceMock(t minimock.Tester) *EventsServiceMock {
	m := &EventsServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateEventMock = mEventsServiceMockCreateEvent{mock: m}
	m.CreateEventMock.callArgs = []*EventsServiceMockCreateEventParams{}

	m.DeleteEventMock = mEventsServiceMockDeleteEvent{mock: m}
	m.DeleteEventMock.callArgs = []*EventsServiceMockDeleteEventParams{}

	m.EventMock = mEventsServiceMockEvent{mock: m}
	m.EventMock.callArgs = []*EventsServiceMockEventParams{}

	m.EventsMock = mEventsServiceMockEvents{mock: m}
	m.EventsMock.callArgs = []*EventsServiceMockEventsParams{}

	m.UpdateEventMock = mEventsServiceMockUpdateEvent{mock: m}
	m.UpdateEventMock.callArgs = []*EventsServiceMockUpdateEventParams{}

	m.UserEventsMock = mEventsServiceMockUserEvents{mock: m}
	m.UserEventsMock.callArgs = []*EventsServiceMockUserEventsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mEventsServiceMockCreateEvent struct {
	optional           bool
	mock               *EventsServiceMock
	defaultExpectation *EventsServiceMockCreateEventExpectation
	expectations       []*EventsServiceMockCreateEventExpectation

	callArgs []*EventsServiceMockCreateEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EventsServiceMockCreateEventExpectation specifies expectation struct of the EventsService.CreateEvent
type EventsServiceMockCreateEventExpectation struct {
	mock               *EventsServiceMock
	params             *EventsServiceMockCreateEventParams
	paramPtrs          *EventsServiceMockCreateEventParamPtrs
	expectationOrigins EventsServiceMockCreateEventExpectationOrigins
	results            *EventsServiceMockCreateEventResults
	returnOrigin       string
	Counter            uint64
}

// EventsServiceMockCreateEventParams contains parameters of the EventsService.CreateEvent
type EventsServiceMockCreateEventParams struct {
	ctx   context.Context
	event *models.Event
}

// EventsServiceMockCreateEventParamPtrs contains pointers to parameters of the EventsService.CreateEvent
type EventsServiceMockCreateEventParamPtrs struct {
	ctx   *context.Context
	event **models.Event
}

// EventsServiceMockCreateEventResults contains results of the EventsService.CreateEvent
type EventsServiceMockCreateEventResults struct {
	i1  int64
	err error
}

// EventsServiceMockCreateEventOrigins contains origins of expectations of the EventsService.CreateEvent
type EventsServiceMockCreateEventExpectationOrigins struct {
	origin      string
	originCtx   string
	originEvent string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateEvent *mEventsServiceMockCreateEvent) Optional() *mEventsServiceMockCreateEvent {
	mmCreateEvent.optional = true
	return mmCreateEvent
}

// Expect sets up expected params for EventsService.CreateEvent
func (mmCreateEvent *mEventsServiceMockCreateEvent) Expect(ctx context.Context, event *models.Event) *mEventsServiceMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("EventsServiceMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &EventsServiceMockCreateEventExpectation{}
	}

	if mmCreateEvent.defaultExpectation.paramPtrs != nil {
		mmCreateEvent.mock.t.Fatalf("EventsServiceMock.CreateEvent mock is already set by ExpectParams functions")
	}

	mmCreateEvent.defaultExpectation.params = &EventsServiceMockCreateEventParams{ctx, event}
	mmCreateEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateEvent.expectations {
		if minimock.Equal(e.params, mmCreateEvent.defaultExpectation.params) {
			mmCreateEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateEvent.defaultExpectation.params)
		}
	}

	return mmCreateEvent
}

// ExpectCtxParam1 sets up expected param ctx for EventsService.CreateEvent
func (mmCreateEvent *mEventsServiceMockCreateEvent) ExpectCtxParam1(ctx context.Context) *mEventsServiceMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("EventsServiceMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &EventsServiceMockCreateEventExpectation{}
	}

	if mmCreateEvent.defaultExpectation.params != nil {
		mmCreateEvent.mock.t.Fatalf("EventsServiceMock.CreateEvent mock is already set by Expect")
	}

	if mmCreateEvent.defaultExpectation.paramPtrs == nil {
		mmCreateEvent.defaultExpectation.paramPtrs = &EventsServiceMockCreateEventParamPtrs{}
	}
	mmCreateEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateEvent
}

// ExpectEventParam2 sets up expected param event for EventsService.CreateEvent
func (mmCreateEvent *mEventsServiceMockCreateEvent) ExpectEventParam2(event *models.Event) *mEventsServiceMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("EventsServiceMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &EventsServiceMockCreateEventExpectation{}
	}

	if mmCreateEvent.defaultExpectation.params != nil {
		mmCreateEvent.mock.t.Fatalf("EventsServiceMock.CreateEvent mock is already set by Expect")
	}

	if mmCreateEvent.defaultExpectation.paramPtrs == nil {
		mmCreateEvent.defaultExpectation.paramPtrs = &EventsServiceMockCreateEventParamPtrs{}
	}
	mmCreateEvent.defaultExpectation.paramPtrs.event = &event
	mmCreateEvent.defaultExpectation.expectationOrigins.originEvent = minimock.CallerInfo(1)

	return mmCreateEvent
}

// Inspect accepts an inspector function that has same arguments as the EventsService.CreateEvent
func (mmCreateEvent *mEventsServiceMockCreateEvent) Inspect(f func(ctx context.Context, event *models.Event)) *mEventsServiceMockCreateEvent {
	if mmCreateEvent.mock.inspectFuncCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("Inspect function is already set for EventsServiceMock.CreateEvent")
	}

	mmCreateEvent.mock.inspectFuncCreateEvent = f

	return mmCreateEvent
}

// Return sets up results that will be returned by EventsService.CreateEvent
func (mmCreateEvent *mEventsServiceMockCreateEvent) Return(i1 int64, err error) *EventsServiceMock {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("EventsServiceMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &EventsServiceMockCreateEventExpectation{mock: mmCreateEvent.mock}
	}
	mmCreateEvent.defaultExpectation.results = &EventsServiceMockCreateEventResults{i1, err}
	mmCreateEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateEvent.mock
}

// Set uses given function f to mock the EventsService.CreateEvent method
func (mmCreateEvent *mEventsServiceMockCreateEvent) Set(f func(ctx context.Context, event *models.Event) (i1 int64, err error)) *EventsServiceMock {
	if mmCreateEvent.defaultExpectation != nil {
		mmCreateEvent.mock.t.Fatalf("Default expectation is already set for the EventsService.CreateEvent method")
	}

	if len(mmCreateEvent.expectations) > 0 {
		mmCreateEvent.mock.t.Fatalf("Some expectations are already set for the EventsService.CreateEvent method")
	}

	mmCreateEvent.mock.funcCreateEvent = f
	mmCreateEvent.mock.funcCreateEventOrigin = minimock.CallerInfo(1)
	return mmCreateEvent.mock
}

// When sets expectation for the EventsService.CreateEvent which will trigger the result defined by the following
// Then helper
func (mmCreateEvent *mEventsServiceMockCreateEvent) When(ctx context.Context, event *models.Event) *EventsServiceMockCreateEventExpectation {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("EventsServiceMock.CreateEvent mock is already set by Set")
	}

	expectation := &EventsServiceMockCreateEventExpectation{
		mock:               mmCreateEvent.mock,
		params:             &EventsServiceMockCreateEventParams{ctx, event},
		expectationOrigins: EventsServiceMockCreateEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateEvent.expectations = append(mmCreateEvent.expectations, expectation)
	return expectation
}

// Then sets up EventsService.CreateEvent return parameters for the expectation previously defined by the When method
func (e *EventsServiceMockCreateEventExpectation) Then(i1 int64, err error) *EventsServiceMock {
	e.results = &EventsServiceMockCreateEventResults{i1, err}
	return e.mock
}

// Times sets number of times EventsService.CreateEvent should be invoked
func (mmCreateEvent *mEventsServiceMockCreateEvent) Times(n uint64) *mEventsServiceMockCreateEvent {
	if n == 0 {
		mmCreateEvent.mock.t.Fatalf("Times of EventsServiceMock.CreateEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateEvent.expectedInvocations, n)
	mmCreateEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateEvent
}

func (mmCreateEvent *mEventsServiceMockCreateEvent) invocationsDone() bool {
	if len(mmCreateEvent.expectations) == 0 && mmCreateEvent.defaultExpectation == nil && mmCreateEvent.mock.funcCreateEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateEvent.mock.afterCreateEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateEvent implements mm_service.EventsService
func (mmCreateEvent *EventsServiceMock) CreateEvent(ctx context.Context, event *models.Event) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateEvent.beforeCreateEventCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateEvent.afterCreateEventCounter, 1)

	mmCreateEvent.t.Helper()

	if mmCreateEvent.inspectFuncCreateEvent != nil {
		mmCreateEvent.inspectFuncCreateEvent(ctx, event)
	}

	mm_params := EventsServiceMockCreateEventParams{ctx, event}

	// Record call args
	mmCreateEvent.CreateEventMock.mutex.Lock()
	mmCreateEvent.CreateEventMock.callArgs = append(mmCreateEvent.CreateEventMock.callArgs, &mm_params)
	mmCreateEvent.CreateEventMock.mutex.Unlock()

	for _, e := range mmCreateEvent.CreateEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateEvent.CreateEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateEvent.CreateEventMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateEvent.CreateEventMock.defaultExpectation.params
		mm_want_ptrs := mmCreateEvent.CreateEventMock.defaultExpectation.paramPtrs

		mm_got := EventsServiceMockCreateEventParams{ctx, event}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateEvent.t.Errorf("EventsServiceMock.CreateEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEvent.CreateEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.event != nil && !minimock.Equal(*mm_want_ptrs.event, mm_got.event) {
				mmCreateEvent.t.Errorf("EventsServiceMock.CreateEvent got unexpected parameter event, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEvent.CreateEventMock.defaultExpectation.expectationOrigins.originEvent, *mm_want_ptrs.event, mm_got.event, minimock.Diff(*mm_want_ptrs.event, mm_got.event))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateEvent.t.Errorf("EventsServiceMock.CreateEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateEvent.CreateEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateEvent.CreateEventMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateEvent.t.Fatal("No results are set for the EventsServiceMock.CreateEvent")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateEvent.funcCreateEvent != nil {
		return mmCreateEvent.funcCreateEvent(ctx, event)
	}
	mmCreateEvent.t.Fatalf("Unexpected call to EventsServiceMock.CreateEvent. %v %v", ctx, event)
	return
}

// CreateEventAfterCounter returns a count of finished EventsServiceMock.CreateEvent invocations
func (mmCreateEvent *EventsServiceMock) CreateEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEvent.afterCreateEventCounter)
}

// CreateEventBeforeCounter returns a count of EventsServiceMock.CreateEvent invocations
func (mmCreateEvent *EventsServiceMock) CreateEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEvent.beforeCreateEventCounter)
}

// Calls returns a list of arguments used in each call to EventsServiceMock.CreateEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateEvent *mEventsServiceMockCreateEvent) Calls() []*EventsServiceMockCreateEventParams {
	mmCreateEvent.mutex.RLock()

	argCopy := make([]*EventsServiceMockCreateEventParams, len(mmCreateEvent.callArgs))
	copy(argCopy, mmCreateEvent.callArgs)

	mmCreateEvent.mutex.RUnlock()

	return argCopy
}

// MinimockCreateEventDone returns true if the count of the CreateEvent invocations corresponds
// the number of defined expectations
func (m *EventsServiceMock) MinimockCreateEventDone() bool {
	if m.CreateEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateEventMock.invocationsDone()
}

// MinimockCreateEventInspect logs each unmet expectation
func (m *EventsServiceMock) MinimockCreateEventInspect() {
	for _, e := range m.CreateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventsServiceMock.CreateEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateEventCounter := mm_atomic.LoadUint64(&m.afterCreateEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEventMock.defaultExpectation != nil && afterCreateEventCounter < 1 {
		if m.CreateEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EventsServiceMock.CreateEvent at\n%s", m.CreateEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EventsServiceMock.CreateEvent at\n%s with params: %#v", m.CreateEventMock.defaultExpectation.expectationOrigins.origin, *m.CreateEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEvent != nil && afterCreateEventCounter < 1 {
		m.t.Errorf("Expected call to EventsServiceMock.CreateEvent at\n%s", m.funcCreateEventOrigin)
	}

	if !m.CreateEventMock.invocationsDone() && afterCreateEventCounter > 0 {
		m.t.Errorf("Expected %d calls to EventsServiceMock.CreateEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateEventMock.expectedInvocations), m.CreateEventMock.expectedInvocationsOrigin, afterCreateEventCounter)
	}
}

type mEventsServiceMockDeleteEvent struct {
	optional           bool
	mock               *EventsServiceMock
	defaultExpectation *EventsServiceMockDeleteEventExpectation
	expectations       []*EventsServiceMockDeleteEventExpectation

	callArgs []*EventsServiceMockDeleteEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EventsServiceMockDeleteEventExpectation specifies expectation struct of the EventsService.DeleteEvent
type EventsServiceMockDeleteEventExpectation struct {
	mock               *EventsServiceMock
	params             *EventsServiceMockDeleteEventParams
	paramPtrs          *EventsServiceMockDeleteEventParamPtrs
	expectationOrigins EventsServiceMockDeleteEventExpectationOrigins
	results            *EventsServiceMockDeleteEventResults
	returnOrigin       string
	Counter            uint64
}

// EventsServiceMockDeleteEventParams contains parameters of the EventsService.DeleteEvent
type EventsServiceMockDeleteEventParams struct {
	ctx      context.Context
	userID   int64
	urlTitle string
}

// EventsServiceMockDeleteEventParamPtrs contains pointers to parameters of the EventsService.DeleteEvent
type EventsServiceMockDeleteEventParamPtrs struct {
	ctx      *context.Context
	userID   *int64
	urlTitle *string
}

// EventsServiceMockDeleteEventResults contains results of the EventsService.DeleteEvent
type EventsServiceMockDeleteEventResults struct {
	err error
}

// EventsServiceMockDeleteEventOrigins contains origins of expectations of the EventsService.DeleteEvent
type EventsServiceMockDeleteEventExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserID   string
	originUrlTitle string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteEvent *mEventsServiceMockDeleteEvent) Optional() *mEventsServiceMockDeleteEvent {
	mmDeleteEvent.optional = true
	return mmDeleteEvent
}

// Expect sets up expected params for EventsService.DeleteEvent
func (mmDeleteEvent *mEventsServiceMockDeleteEvent) Expect(ctx context.Context, userID int64, urlTitle string) *mEventsServiceMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("EventsServiceMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &EventsServiceMockDeleteEventExpectation{}
	}

	if mmDeleteEvent.defaultExpectation.paramPtrs != nil {
		mmDeleteEvent.mock.t.Fatalf("EventsServiceMock.DeleteEvent mock is already set by ExpectParams functions")
	}

	mmDeleteEvent.defaultExpectation.params = &EventsServiceMockDeleteEventParams{ctx, userID, urlTitle}
	mmDeleteEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteEvent.expectations {
		if minimock.Equal(e.params, mmDeleteEvent.defaultExpectation.params) {
			mmDeleteEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEvent.defaultExpectation.params)
		}
	}

	return mmDeleteEvent
}

// ExpectCtxParam1 sets up expected param ctx for EventsService.DeleteEvent
func (mmDeleteEvent *mEventsServiceMockDeleteEvent) ExpectCtxParam1(ctx context.Context) *mEventsServiceMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("EventsServiceMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &EventsServiceMockDeleteEventExpectation{}
	}

	if mmDeleteEvent.defaultExpectation.params != nil {
		mmDeleteEvent.mock.t.Fatalf("EventsServiceMock.DeleteEvent mock is already set by Expect")
	}

	if mmDeleteEvent.defaultExpectation.paramPtrs == nil {
		mmDeleteEvent.defaultExpectation.paramPtrs = &EventsServiceMockDeleteEventParamPtrs{}
	}
	mmDeleteEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteEvent
}

// ExpectUserIDParam2 sets up expected param userID for EventsService.DeleteEvent
func (mmDeleteEvent *mEventsServiceMockDeleteEvent) ExpectUserIDParam2(userID int64) *mEventsServiceMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("EventsServiceMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &EventsServiceMockDeleteEventExpectation{}
	}

	if mmDeleteEvent.defaultExpectation.params != nil {
		mmDeleteEvent.mock.t.Fatalf("EventsServiceMock.DeleteEvent mock is already set by Expect")
	}

	if mmDeleteEvent.defaultExpectation.paramPtrs == nil {
		mmDeleteEvent.defaultExpectation.paramPtrs = &EventsServiceMockDeleteEventParamPtrs{}
	}
	mmDeleteEvent.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteEvent.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteEvent
}

// ExpectUrlTitleParam3 sets up expected param urlTitle for EventsService.DeleteEvent
func (mmDeleteEvent *mEventsServiceMockDeleteEvent) ExpectUrlTitleParam3(urlTitle string) *mEventsServiceMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("EventsServiceMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &EventsServiceMockDeleteEventExpectation{}
	}

	if mmDeleteEvent.defaultExpectation.params != nil {
		mmDeleteEvent.mock.t.Fatalf("EventsServiceMock.DeleteEvent mock is already set by Expect")
	}

	if mmDeleteEvent.defaultExpectation.paramPtrs == nil {
		mmDeleteEvent.defaultExpectation.paramPtrs = &EventsServiceMockDeleteEventParamPtrs{}
	}
	mmDeleteEvent.defaultExpectation.paramPtrs.urlTitle = &urlTitle
	mmDeleteEvent.defaultExpectation.expectationOrigins.originUrlTitle = minimock.CallerInfo(1)

	return mmDeleteEvent
}

// Inspect accepts an inspector function that has same arguments as the EventsService.DeleteEvent
func (mmDeleteEvent *mEventsServiceMockDeleteEvent) Inspect(f func(ctx context.Context, userID int64, urlTitle string)) *mEventsServiceMockDeleteEvent {
	if mmDeleteEvent.mock.inspectFuncDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("Inspect function is already set for EventsServiceMock.DeleteEvent")
	}

	mmDeleteEvent.mock.inspectFuncDeleteEvent = f

	return mmDeleteEvent
}

// Return sets up results that will be returned by EventsService.DeleteEvent
func (mmDeleteEvent *mEventsServiceMockDeleteEvent) Return(err error) *EventsServiceMock {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("EventsServiceMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &EventsServiceMockDeleteEventExpectation{mock: mmDeleteEvent.mock}
	}
	mmDeleteEvent.defaultExpectation.results = &EventsServiceMockDeleteEventResults{err}
	mmDeleteEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteEvent.mock
}

// Set uses given function f to mock the EventsService.DeleteEvent method
func (mmDeleteEvent *mEventsServiceMockDeleteEvent) Set(f func(ctx context.Context, userID int64, urlTitle string) (err error)) *EventsServiceMock {
	if mmDeleteEvent.defaultExpectation != nil {
		mmDeleteEvent.mock.t.Fatalf("Default expectation is already set for the EventsService.DeleteEvent method")
	}

	if len(mmDeleteEvent.expectations) > 0 {
		mmDeleteEvent.mock.t.Fatalf("Some expectations are already set for the EventsService.DeleteEvent method")
	}

	mmDeleteEvent.mock.funcDeleteEvent = f
	mmDeleteEvent.mock.funcDeleteEventOrigin = minimock.CallerInfo(1)
	return mmDeleteEvent.mock
}

// When sets expectation for the EventsService.DeleteEvent which will trigger the result defined by the following
// Then helper
func (mmDeleteEvent *mEventsServiceMockDeleteEvent) When(ctx context.Context, userID int64, urlTitle string) *EventsServiceMockDeleteEventExpectation {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("EventsServiceMock.DeleteEvent mock is already set by Set")
	}

	expectation := &EventsServiceMockDeleteEventExpectation{
		mock:               mmDeleteEvent.mock,
		params:             &EventsServiceMockDeleteEventParams{ctx, userID, urlTitle},
		expectationOrigins: EventsServiceMockDeleteEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteEvent.expectations = append(mmDeleteEvent.expectations, expectation)
	return expectation
}

// Then sets up EventsService.DeleteEvent return parameters for the expectation previously defined by the When method
func (e *EventsServiceMockDeleteEventExpectation) Then(err error) *EventsServiceMock {
	e.results = &EventsServiceMockDeleteEventResults{err}
	return e.mock
}

// Times sets number of times EventsService.DeleteEvent should be invoked
func (mmDeleteEvent *mEventsServiceMockDeleteEvent) Times(n uint64) *mEventsServiceMockDeleteEvent {
	if n == 0 {
		mmDeleteEvent.mock.t.Fatalf("Times of EventsServiceMock.DeleteEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEvent.expectedInvocations, n)
	mmDeleteEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteEvent
}

func (mmDeleteEvent *mEventsServiceMockDeleteEvent) invocationsDone() bool {
	if len(mmDeleteEvent.expectations) == 0 && mmDeleteEvent.defaultExpectation == nil && mmDeleteEvent.mock.funcDeleteEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEvent.mock.afterDeleteEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEvent implements mm_service.EventsService
func (mmDeleteEvent *EventsServiceMock) DeleteEvent(ctx context.Context, userID int64, urlTitle string) (err error) {
	mm_atomic.AddUint64(&mmDeleteEvent.beforeDeleteEventCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEvent.afterDeleteEventCounter, 1)

	mmDeleteEvent.t.Helper()

	if mmDeleteEvent.inspectFuncDeleteEvent != nil {
		mmDeleteEvent.inspectFuncDeleteEvent(ctx, userID, urlTitle)
	}

	mm_params := EventsServiceMockDeleteEventParams{ctx, userID, urlTitle}

	// Record call args
	mmDeleteEvent.DeleteEventMock.mutex.Lock()
	mmDeleteEvent.DeleteEventMock.callArgs = append(mmDeleteEvent.DeleteEventMock.callArgs, &mm_params)
	mmDeleteEvent.DeleteEventMock.mutex.Unlock()

	for _, e := range mmDeleteEvent.DeleteEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEvent.DeleteEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEvent.DeleteEventMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEvent.DeleteEventMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEvent.DeleteEventMock.defaultExpectation.paramPtrs

		mm_got := EventsServiceMockDeleteEventParams{ctx, userID, urlTitle}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEvent.t.Errorf("EventsServiceMock.DeleteEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEvent.DeleteEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteEvent.t.Errorf("EventsServiceMock.DeleteEvent got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEvent.DeleteEventMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.urlTitle != nil && !minimock.Equal(*mm_want_ptrs.urlTitle, mm_got.urlTitle) {
				mmDeleteEvent.t.Errorf("EventsServiceMock.DeleteEvent got unexpected parameter urlTitle, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEvent.DeleteEventMock.defaultExpectation.expectationOrigins.originUrlTitle, *mm_want_ptrs.urlTitle, mm_got.urlTitle, minimock.Diff(*mm_want_ptrs.urlTitle, mm_got.urlTitle))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEvent.t.Errorf("EventsServiceMock.DeleteEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteEvent.DeleteEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEvent.DeleteEventMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEvent.t.Fatal("No results are set for the EventsServiceMock.DeleteEvent")
		}
		return (*mm_results).err
	}
	if mmDeleteEvent.funcDeleteEvent != nil {
		return mmDeleteEvent.funcDeleteEvent(ctx, userID, urlTitle)
	}
	mmDeleteEvent.t.Fatalf("Unexpected call to EventsServiceMock.DeleteEvent. %v %v %v", ctx, userID, urlTitle)
	return
}

// DeleteEventAfterCounter returns a count of finished EventsServiceMock.DeleteEvent invocations
func (mmDeleteEvent *EventsServiceMock) DeleteEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEvent.afterDeleteEventCounter)
}

// DeleteEventBeforeCounter returns a count of EventsServiceMock.DeleteEvent invocations
func (mmDeleteEvent *EventsServiceMock) DeleteEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEvent.beforeDeleteEventCounter)
}

// Calls returns a list of arguments used in each call to EventsServiceMock.DeleteEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEvent *mEventsServiceMockDeleteEvent) Calls() []*EventsServiceMockDeleteEventParams {
	mmDeleteEvent.mutex.RLock()

	argCopy := make([]*EventsServiceMockDeleteEventParams, len(mmDeleteEvent.callArgs))
	copy(argCopy, mmDeleteEvent.callArgs)

	mmDeleteEvent.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEventDone returns true if the count of the DeleteEvent invocations corresponds
// the number of defined expectations
func (m *EventsServiceMock) MinimockDeleteEventDone() bool {
	if m.DeleteEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEventMock.invocationsDone()
}

// MinimockDeleteEventInspect logs each unmet expectation
func (m *EventsServiceMock) MinimockDeleteEventInspect() {
	for _, e := range m.DeleteEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventsServiceMock.DeleteEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteEventCounter := mm_atomic.LoadUint64(&m.afterDeleteEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEventMock.defaultExpectation != nil && afterDeleteEventCounter < 1 {
		if m.DeleteEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EventsServiceMock.DeleteEvent at\n%s", m.DeleteEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EventsServiceMock.DeleteEvent at\n%s with params: %#v", m.DeleteEventMock.defaultExpectation.expectationOrigins.origin, *m.DeleteEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEvent != nil && afterDeleteEventCounter < 1 {
		m.t.Errorf("Expected call to EventsServiceMock.DeleteEvent at\n%s", m.funcDeleteEventOrigin)
	}

	if !m.DeleteEventMock.invocationsDone() && afterDeleteEventCounter > 0 {
		m.t.Errorf("Expected %d calls to EventsServiceMock.DeleteEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEventMock.expectedInvocations), m.DeleteEventMock.expectedInvocationsOrigin, afterDeleteEventCounter)
	}
}

type mEventsServiceMockEvent struct {
	optional           bool
	mock               *EventsServiceMock
	defaultExpectation *EventsServiceMockEventExpectation
	expectations       []*EventsServiceMockEventExpectation

	callArgs []*EventsServiceMockEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EventsServiceMockEventExpectation specifies expectation struct of the EventsService.Event
type EventsServiceMockEventExpectation struct {
	mock               *EventsServiceMock
	params             *EventsServiceMockEventParams
	paramPtrs          *EventsServiceMockEventParamPtrs
	expectationOrigins EventsServiceMockEventExpectationOrigins
	results            *EventsServiceMockEventResults
	returnOrigin       string
	Counter            uint64
}

// EventsServiceMockEventParams contains parameters of the EventsService.Event
type EventsServiceMockEventParams struct {
	ctx      context.Context
	urlTitle string
}

// EventsServiceMockEventParamPtrs contains pointers to parameters of the EventsService.Event
type EventsServiceMockEventParamPtrs struct {
	ctx      *context.Context
	urlTitle *string
}

// EventsServiceMockEventResults contains results of the EventsService.Event
type EventsServiceMockEventResults struct {
	ep1 *models.Event
	err error
}

// EventsServiceMockEventOrigins contains origins of expectations of the EventsService.Event
type EventsServiceMockEventExpectationOrigins struct {
	origin         string
	originCtx      string
	originUrlTitle string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEvent *mEventsServiceMockEvent) Optional() *mEventsServiceMockEvent {
	mmEvent.optional = true
	return mmEvent
}

// Expect sets up expected params for EventsService.Event
func (mmEvent *mEventsServiceMockEvent) Expect(ctx context.Context, urlTitle string) *mEventsServiceMockEvent {
	if mmEvent.mock.funcEvent != nil {
		mmEvent.mock.t.Fatalf("EventsServiceMock.Event mock is already set by Set")
	}

	if mmEvent.defaultExpectation == nil {
		mmEvent.defaultExpectation = &EventsServiceMockEventExpectation{}
	}

	if mmEvent.defaultExpectation.paramPtrs != nil {
		mmEvent.mock.t.Fatalf("EventsServiceMock.Event mock is already set by ExpectParams functions")
	}

	mmEvent.defaultExpectation.params = &EventsServiceMockEventParams{ctx, urlTitle}
	mmEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEvent.expectations {
		if minimock.Equal(e.params, mmEvent.defaultExpectation.params) {
			mmEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEvent.defaultExpectation.params)
		}
	}

	return mmEvent
}

// ExpectCtxParam1 sets up expected param ctx for EventsService.Event
func (mmEvent *mEventsServiceMockEvent) ExpectCtxParam1(ctx context.Context) *mEventsServiceMockEvent {
	if mmEvent.mock.funcEvent != nil {
		mmEvent.mock.t.Fatalf("EventsServiceMock.Event mock is already set by Set")
	}

	if mmEvent.defaultExpectation == nil {
		mmEvent.defaultExpectation = &EventsServiceMockEventExpectation{}
	}

	if mmEvent.defaultExpectation.params != nil {
		mmEvent.mock.t.Fatalf("EventsServiceMock.Event mock is already set by Expect")
	}

	if mmEvent.defaultExpectation.paramPtrs == nil {
		mmEvent.defaultExpectation.paramPtrs = &EventsServiceMockEventParamPtrs{}
	}
	mmEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEvent
}

// ExpectUrlTitleParam2 sets up expected param urlTitle for EventsService.Event
func (mmEvent *mEventsServiceMockEvent) ExpectUrlTitleParam2(urlTitle string) *mEventsServiceMockEvent {
	if mmEvent.mock.funcEvent != nil {
		mmEvent.mock.t.Fatalf("EventsServiceMock.Event mock is already set by Set")
	}

	if mmEvent.defaultExpectation == nil {
		mmEvent.defaultExpectation = &EventsServiceMockEventExpectation{}
	}

	if mmEvent.defaultExpectation.params != nil {
		mmEvent.mock.t.Fatalf("EventsServiceMock.Event mock is already set by Expect")
	}

	if mmEvent.defaultExpectation.paramPtrs == nil {
		mmEvent.defaultExpectation.paramPtrs = &EventsServiceMockEventParamPtrs{}
	}
	mmEvent.defaultExpectation.paramPtrs.urlTitle = &urlTitle
	mmEvent.defaultExpectation.expectationOrigins.originUrlTitle = minimock.CallerInfo(1)

	return mmEvent
}

// Inspect accepts an inspector function that has same arguments as the EventsService.Event
func (mmEvent *mEventsServiceMockEvent) Inspect(f func(ctx context.Context, urlTitle string)) *mEventsServiceMockEvent {
	if mmEvent.mock.inspectFuncEvent != nil {
		mmEvent.mock.t.Fatalf("Inspect function is already set for EventsServiceMock.Event")
	}

	mmEvent.mock.inspectFuncEvent = f

	return mmEvent
}

// Return sets up results that will be returned by EventsService.Event
func (mmEvent *mEventsServiceMockEvent) Return(ep1 *models.Event, err error) *EventsServiceMock {
	if mmEvent.mock.funcEvent != nil {
		mmEvent.mock.t.Fatalf("EventsServiceMock.Event mock is already set by Set")
	}

	if mmEvent.defaultExpectation == nil {
		mmEvent.defaultExpectation = &EventsServiceMockEventExpectation{mock: mmEvent.mock}
	}
	mmEvent.defaultExpectation.results = &EventsServiceMockEventResults{ep1, err}
	mmEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEvent.mock
}

// Set uses given function f to mock the EventsService.Event method
func (mmEvent *mEventsServiceMockEvent) Set(f func(ctx context.Context, urlTitle string) (ep1 *models.Event, err error)) *EventsServiceMock {
	if mmEvent.defaultExpectation != nil {
		mmEvent.mock.t.Fatalf("Default expectation is already set for the EventsService.Event method")
	}

	if len(mmEvent.expectations) > 0 {
		mmEvent.mock.t.Fatalf("Some expectations are already set for the EventsService.Event method")
	}

	mmEvent.mock.funcEvent = f
	mmEvent.mock.funcEventOrigin = minimock.CallerInfo(1)
	return mmEvent.mock
}

// When sets expectation for the EventsService.Event which will trigger the result defined by the following
// Then helper
func (mmEvent *mEventsServiceMockEvent) When(ctx context.Context, urlTitle string) *EventsServiceMockEventExpectation {
	if mmEvent.mock.funcEvent != nil {
		mmEvent.mock.t.Fatalf("EventsServiceMock.Event mock is already set by Set")
	}

	expectation := &EventsServiceMockEventExpectation{
		mock:               mmEvent.mock,
		params:             &EventsServiceMockEventParams{ctx, urlTitle},
		expectationOrigins: EventsServiceMockEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEvent.expectations = append(mmEvent.expectations, expectation)
	return expectation
}

// Then sets up EventsService.Event return parameters for the expectation previously defined by the When method
func (e *EventsServiceMockEventExpectation) Then(ep1 *models.Event, err error) *EventsServiceMock {
	e.results = &EventsServiceMockEventResults{ep1, err}
	return e.mock
}

// Times sets number of times EventsService.Event should be invoked
func (mmEvent *mEventsServiceMockEvent) Times(n uint64) *mEventsServiceMockEvent {
	if n == 0 {
		mmEvent.mock.t.Fatalf("Times of EventsServiceMock.Event mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEvent.expectedInvocations, n)
	mmEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEvent
}

func (mmEvent *mEventsServiceMockEvent) invocationsDone() bool {
	if len(mmEvent.expectations) == 0 && mmEvent.defaultExpectation == nil && mmEvent.mock.funcEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEvent.mock.afterEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Event implements mm_service.EventsService
func (mmEvent *EventsServiceMock) Event(ctx context.Context, urlTitle string) (ep1 *models.Event, err error) {
	mm_atomic.AddUint64(&mmEvent.beforeEventCounter, 1)
	defer mm_atomic.AddUint64(&mmEvent.afterEventCounter, 1)

	mmEvent.t.Helper()

	if mmEvent.inspectFuncEvent != nil {
		mmEvent.inspectFuncEvent(ctx, urlTitle)
	}

	mm_params := EventsServiceMockEventParams{ctx, urlTitle}

	// Record call args
	mmEvent.EventMock.mutex.Lock()
	mmEvent.EventMock.callArgs = append(mmEvent.EventMock.callArgs, &mm_params)
	mmEvent.EventMock.mutex.Unlock()

	for _, e := range mmEvent.EventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmEvent.EventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEvent.EventMock.defaultExpectation.Counter, 1)
		mm_want := mmEvent.EventMock.defaultExpectation.params
		mm_want_ptrs := mmEvent.EventMock.defaultExpectation.paramPtrs

		mm_got := EventsServiceMockEventParams{ctx, urlTitle}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEvent.t.Errorf("EventsServiceMock.Event got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEvent.EventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.urlTitle != nil && !minimock.Equal(*mm_want_ptrs.urlTitle, mm_got.urlTitle) {
				mmEvent.t.Errorf("EventsServiceMock.Event got unexpected parameter urlTitle, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEvent.EventMock.defaultExpectation.expectationOrigins.originUrlTitle, *mm_want_ptrs.urlTitle, mm_got.urlTitle, minimock.Diff(*mm_want_ptrs.urlTitle, mm_got.urlTitle))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEvent.t.Errorf("EventsServiceMock.Event got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEvent.EventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEvent.EventMock.defaultExpectation.results
		if mm_results == nil {
			mmEvent.t.Fatal("No results are set for the EventsServiceMock.Event")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmEvent.funcEvent != nil {
		return mmEvent.funcEvent(ctx, urlTitle)
	}
	mmEvent.t.Fatalf("Unexpected call to EventsServiceMock.Event. %v %v", ctx, urlTitle)
	return
}

// EventAfterCounter returns a count of finished EventsServiceMock.Event invocations
func (mmEvent *EventsServiceMock) EventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEvent.afterEventCounter)
}

// EventBeforeCounter returns a count of EventsServiceMock.Event invocations
func (mmEvent *EventsServiceMock) EventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEvent.beforeEventCounter)
}

// Calls returns a list of arguments used in each call to EventsServiceMock.Event.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEvent *mEventsServiceMockEvent) Calls() []*EventsServiceMockEventParams {
	mmEvent.mutex.RLock()

	argCopy := make([]*EventsServiceMockEventParams, len(mmEvent.callArgs))
	copy(argCopy, mmEvent.callArgs)

	mmEvent.mutex.RUnlock()

	return argCopy
}

// MinimockEventDone returns true if the count of the Event invocations corresponds
// the number of defined expectations
func (m *EventsServiceMock) MinimockEventDone() bool {
	if m.EventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EventMock.invocationsDone()
}

// MinimockEventInspect logs each unmet expectation
func (m *EventsServiceMock) MinimockEventInspect() {
	for _, e := range m.EventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventsServiceMock.Event at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEventCounter := mm_atomic.LoadUint64(&m.afterEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EventMock.defaultExpectation != nil && afterEventCounter < 1 {
		if m.EventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EventsServiceMock.Event at\n%s", m.EventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EventsServiceMock.Event at\n%s with params: %#v", m.EventMock.defaultExpectation.expectationOrigins.origin, *m.EventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEvent != nil && afterEventCounter < 1 {
		m.t.Errorf("Expected call to EventsServiceMock.Event at\n%s", m.funcEventOrigin)
	}

	if !m.EventMock.invocationsDone() && afterEventCounter > 0 {
		m.t.Errorf("Expected %d calls to EventsServiceMock.Event at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EventMock.expectedInvocations), m.EventMock.expectedInvocationsOrigin, afterEventCounter)
	}
}

type mEventsServiceMockEvents struct {
	optional           bool
	mock               *EventsServiceMock
	defaultExpectation *EventsServiceMockEventsExpectation
	expectations       []*EventsServiceMockEventsExpectation

	callArgs []*EventsServiceMockEventsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EventsServiceMockEventsExpectation specifies expectation struct of the EventsService.Events
type EventsServiceMockEventsExpectation struct {
	mock               *EventsServiceMock
	params             *EventsServiceMockEventsParams
	paramPtrs          *EventsServiceMockEventsParamPtrs
	expectationOrigins EventsServiceMockEventsExpectationOrigins
	results            *EventsServiceMockEventsResults
	returnOrigin       string
	Counter            uint64
}

// EventsServiceMockEventsParams contains parameters of the EventsService.Events
type EventsServiceMockEventsParams struct {
	ctx  context.Context
	page int
}

// EventsServiceMockEventsParamPtrs contains pointers to parameters of the EventsService.Events
type EventsServiceMockEventsParamPtrs struct {
	ctx  *context.Context
	page *int
}

// EventsServiceMockEventsResults contains results of the EventsService.Events
type EventsServiceMockEventsResults struct {
	epa1 []*models.Event
	err  error
}

// EventsServiceMockEventsOrigins contains origins of expectations of the EventsService.Events
type EventsServiceMockEventsExpectationOrigins struct {
	origin     string
	originCtx  string
	originPage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEvents *mEventsServiceMockEvents) Optional() *mEventsServiceMockEvents {
	mmEvents.optional = true
	return mmEvents
}

// Expect sets up expected params for EventsService.Events
func (mmEvents *mEventsServiceMockEvents) Expect(ctx context.Context, page int) *mEventsServiceMockEvents {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("EventsServiceMock.Events mock is already set by Set")
	}

	if mmEvents.defaultExpectation == nil {
		mmEvents.defaultExpectation = &EventsServiceMockEventsExpectation{}
	}

	if mmEvents.defaultExpectation.paramPtrs != nil {
		mmEvents.mock.t.Fatalf("EventsServiceMock.Events mock is already set by ExpectParams functions")
	}

	mmEvents.defaultExpectation.params = &EventsServiceMockEventsParams{ctx, page}
	mmEvents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEvents.expectations {
		if minimock.Equal(e.params, mmEvents.defaultExpectation.params) {
			mmEvents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEvents.defaultExpectation.params)
		}
	}

	return mmEvents
}

// ExpectCtxParam1 sets up expected param ctx for EventsService.Events
func (mmEvents *mEventsServiceMockEvents) ExpectCtxParam1(ctx context.Context) *mEventsServiceMockEvents {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("EventsServiceMock.Events mock is already set by Set")
	}

	if mmEvents.defaultExpectation == nil {
		mmEvents.defaultExpectation = &EventsServiceMockEventsExpectation{}
	}

	if mmEvents.defaultExpectation.params != nil {
		mmEvents.mock.t.Fatalf("EventsServiceMock.Events mock is already set by Expect")
	}

	if mmEvents.defaultExpectation.paramPtrs == nil {
		mmEvents.defaultExpectation.paramPtrs = &EventsServiceMockEventsParamPtrs{}
	}
	mmEvents.defaultExpectation.paramPtrs.ctx = &ctx
	mmEvents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEvents
}

// ExpectPageParam2 sets up expected param page for EventsService.Events
func (mmEvents *mEventsServiceMockEvents) ExpectPageParam2(page int) *mEventsServiceMockEvents {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("EventsServiceMock.Events mock is already set by Set")
	}

	if mmEvents.defaultExpectation == nil {
		mmEvents.defaultExpectation = &EventsServiceMockEventsExpectation{}
	}

	if mmEvents.defaultExpectation.params != nil {
		mmEvents.mock.t.Fatalf("EventsServiceMock.Events mock is already set by Expect")
	}

	if mmEvents.defaultExpectation.paramPtrs == nil {
		mmEvents.defaultExpectation.paramPtrs = &EventsServiceMockEventsParamPtrs{}
	}
	mmEvents.defaultExpectation.paramPtrs.page = &page
	mmEvents.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmEvents
}

// Inspect accepts an inspector function that has same arguments as the EventsService.Events
func (mmEvents *mEventsServiceMockEvents) Inspect(f func(ctx context.Context, page int)) *mEventsServiceMockEvents {
	if mmEvents.mock.inspectFuncEvents != nil {
		mmEvents.mock.t.Fatalf("Inspect function is already set for EventsServiceMock.Events")
	}

	mmEvents.mock.inspectFuncEvents = f

	return mmEvents
}

// Return sets up results that will be returned by EventsService.Events
func (mmEvents *mEventsServiceMockEvents) Return(epa1 []*models.Event, err error) *EventsServiceMock {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("EventsServiceMock.Events mock is already set by Set")
	}

	if mmEvents.defaultExpectation == nil {
		mmEvents.defaultExpectation = &EventsServiceMockEventsExpectation{mock: mmEvents.mock}
	}
	mmEvents.defaultExpectation.results = &EventsServiceMockEventsResults{epa1, err}
	mmEvents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEvents.mock
}

// Set uses given function f to mock the EventsService.Events method
func (mmEvents *mEventsServiceMockEvents) Set(f func(ctx context.Context, page int) (epa1 []*models.Event, err error)) *EventsServiceMock {
	if mmEvents.defaultExpectation != nil {
		mmEvents.mock.t.Fatalf("Default expectation is already set for the EventsService.Events method")
	}

	if len(mmEvents.expectations) > 0 {
		mmEvents.mock.t.Fatalf("Some expectations are already set for the EventsService.Events method")
	}

	mmEvents.mock.funcEvents = f
	mmEvents.mock.funcEventsOrigin = minimock.CallerInfo(1)
	return mmEvents.mock
}

// When sets expectation for the EventsService.Events which will trigger the result defined by the following
// Then helper
func (mmEvents *mEventsServiceMockEvents) When(ctx context.Context, page int) *EventsServiceMockEventsExpectation {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("EventsServiceMock.Events mock is already set by Set")
	}

	expectation := &EventsServiceMockEventsExpectation{
		mock:               mmEvents.mock,
		params:             &EventsServiceMockEventsParams{ctx, page},
		expectationOrigins: EventsServiceMockEventsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEvents.expectations = append(mmEvents.expectations, expectation)
	return expectation
}

// Then sets up EventsService.Events return parameters for the expectation previously defined by the When method
func (e *EventsServiceMockEventsExpectation) Then(epa1 []*models.Event, err error) *EventsServiceMock {
	e.results = &EventsServiceMockEventsResults{epa1, err}
	return e.mock
}

// Times sets number of times EventsService.Events should be invoked
func (mmEvents *mEventsServiceMockEvents) Times(n uint64) *mEventsServiceMockEvents {
	if n == 0 {
		mmEvents.mock.t.Fatalf("Times of EventsServiceMock.Events mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEvents.expectedInvocations, n)
	mmEvents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEvents
}

func (mmEvents *mEventsServiceMockEvents) invocationsDone() bool {
	if len(mmEvents.expectations) == 0 && mmEvents.defaultExpectation == nil && mmEvents.mock.funcEvents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEvents.mock.afterEventsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEvents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Events implements mm_service.EventsService
func (mmEvents *EventsServiceMock) Events(ctx context.Context, page int) (epa1 []*models.Event, err error) {
	mm_atomic.AddUint64(&mmEvents.beforeEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmEvents.afterEventsCounter, 1)

	mmEvents.t.Helper()

	if mmEvents.inspectFuncEvents != nil {
		mmEvents.inspectFuncEvents(ctx, page)
	}

	mm_params := EventsServiceMockEventsParams{ctx, page}

	// Record call args
	mmEvents.EventsMock.mutex.Lock()
	mmEvents.EventsMock.callArgs = append(mmEvents.EventsMock.callArgs, &mm_params)
	mmEvents.EventsMock.mutex.Unlock()

	for _, e := range mmEvents.EventsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.epa1, e.results.err
		}
	}

	if mmEvents.EventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEvents.EventsMock.defaultExpectation.Counter, 1)
		mm_want := mmEvents.EventsMock.defaultExpectation.params
		mm_want_ptrs := mmEvents.EventsMock.defaultExpectation.paramPtrs

		mm_got := EventsServiceMockEventsParams{ctx, page}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEvents.t.Errorf("EventsServiceMock.Events got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEvents.EventsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmEvents.t.Errorf("EventsServiceMock.Events got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEvents.EventsMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEvents.t.Errorf("EventsServiceMock.Events got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEvents.EventsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEvents.EventsMock.defaultExpectation.results
		if mm_results == nil {
			mmEvents.t.Fatal("No results are set for the EventsServiceMock.Events")
		}
		return (*mm_results).epa1, (*mm_results).err
	}
	if mmEvents.funcEvents != nil {
		return mmEvents.funcEvents(ctx, page)
	}
	mmEvents.t.Fatalf("Unexpected call to EventsServiceMock.Events. %v %v", ctx, page)
	return
}

// EventsAfterCounter returns a count of finished EventsServiceMock.Events invocations
func (mmEvents *EventsServiceMock) EventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEvents.afterEventsCounter)
}

// EventsBeforeCounter returns a count of EventsServiceMock.Events invocations
func (mmEvents *EventsServiceMock) EventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEvents.beforeEventsCounter)
}

// Calls returns a list of arguments used in each call to EventsServiceMock.Events.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEvents *mEventsServiceMockEvents) Calls() []*EventsServiceMockEventsParams {
	mmEvents.mutex.RLock()

	argCopy := make([]*EventsServiceMockEventsParams, len(mmEvents.callArgs))
	copy(argCopy, mmEvents.callArgs)

	mmEvents.mutex.RUnlock()

	return argCopy
}

// MinimockEventsDone returns true if the count of the Events invocations corresponds
// the number of defined expectations
func (m *EventsServiceMock) MinimockEventsDone() bool {
	if m.EventsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EventsMock.invocationsDone()
}

// MinimockEventsInspect logs each unmet expectation
func (m *EventsServiceMock) MinimockEventsInspect() {
	for _, e := range m.EventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventsServiceMock.Events at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEventsCounter := mm_atomic.LoadUint64(&m.afterEventsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EventsMock.defaultExpectation != nil && afterEventsCounter < 1 {
		if m.EventsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EventsServiceMock.Events at\n%s", m.EventsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EventsServiceMock.Events at\n%s with params: %#v", m.EventsMock.defaultExpectation.expectationOrigins.origin, *m.EventsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEvents != nil && afterEventsCounter < 1 {
		m.t.Errorf("Expected call to EventsServiceMock.Events at\n%s", m.funcEventsOrigin)
	}

	if !m.EventsMock.invocationsDone() && afterEventsCounter > 0 {
		m.t.Errorf("Expected %d calls to EventsServiceMock.Events at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EventsMock.expectedInvocations), m.EventsMock.expectedInvocationsOrigin, afterEventsCounter)
	}
}

type mEventsServiceMockUpdateEvent struct {
	optional           bool
	mock               *EventsServiceMock
	defaultExpectation *EventsServiceMockUpdateEventExpectation
	expectations       []*EventsServiceMockUpdateEventExpectation

	callArgs []*EventsServiceMockUpdateEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EventsServiceMockUpdateEventExpectation specifies expectation struct of the EventsService.UpdateEvent
type EventsServiceMockUpdateEventExpectation struct {
	mock               *EventsServiceMock
	params             *EventsServiceMockUpdateEventParams
	paramPtrs          *EventsServiceMockUpdateEventParamPtrs
	expectationOrigins EventsServiceMockUpdateEventExpectationOrigins
	results            *EventsServiceMockUpdateEventResults
	returnOrigin       string
	Counter            uint64
}

// EventsServiceMockUpdateEventParams contains parameters of the EventsService.UpdateEvent
type EventsServiceMockUpdateEventParams struct {
	ctx    context.Context
	userID int64
	event  *models.Event
}

// EventsServiceMockUpdateEventParamPtrs contains pointers to parameters of the EventsService.UpdateEvent
type EventsServiceMockUpdateEventParamPtrs struct {
	ctx    *context.Context
	userID *int64
	event  **models.Event
}

// EventsServiceMockUpdateEventResults contains results of the EventsService.UpdateEvent
type EventsServiceMockUpdateEventResults struct {
	err error
}

// EventsServiceMockUpdateEventOrigins contains origins of expectations of the EventsService.UpdateEvent
type EventsServiceMockUpdateEventExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originEvent  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateEvent *mEventsServiceMockUpdateEvent) Optional() *mEventsServiceMockUpdateEvent {
	mmUpdateEvent.optional = true
	return mmUpdateEvent
}

// Expect sets up expected params for EventsService.UpdateEvent
func (mmUpdateEvent *mEventsServiceMockUpdateEvent) Expect(ctx context.Context, userID int64, event *models.Event) *mEventsServiceMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("EventsServiceMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &EventsServiceMockUpdateEventExpectation{}
	}

	if mmUpdateEvent.defaultExpectation.paramPtrs != nil {
		mmUpdateEvent.mock.t.Fatalf("EventsServiceMock.UpdateEvent mock is already set by ExpectParams functions")
	}

	mmUpdateEvent.defaultExpectation.params = &EventsServiceMockUpdateEventParams{ctx, userID, event}
	mmUpdateEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateEvent.expectations {
		if minimock.Equal(e.params, mmUpdateEvent.defaultExpectation.params) {
			mmUpdateEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateEvent.defaultExpectation.params)
		}
	}

	return mmUpdateEvent
}

// ExpectCtxParam1 sets up expected param ctx for EventsService.UpdateEvent
func (mmUpdateEvent *mEventsServiceMockUpdateEvent) ExpectCtxParam1(ctx context.Context) *mEventsServiceMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("EventsServiceMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &EventsServiceMockUpdateEventExpectation{}
	}

	if mmUpdateEvent.defaultExpectation.params != nil {
		mmUpdateEvent.mock.t.Fatalf("EventsServiceMock.UpdateEvent mock is already set by Expect")
	}

	if mmUpdateEvent.defaultExpectation.paramPtrs == nil {
		mmUpdateEvent.defaultExpectation.paramPtrs = &EventsServiceMockUpdateEventParamPtrs{}
	}
	mmUpdateEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateEvent
}

// ExpectUserIDParam2 sets up expected param userID for EventsService.UpdateEvent
func (mmUpdateEvent *mEventsServiceMockUpdateEvent) ExpectUserIDParam2(userID int64) *mEventsServiceMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("EventsServiceMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &EventsServiceMockUpdateEventExpectation{}
	}

	if mmUpdateEvent.defaultExpectation.params != nil {
		mmUpdateEvent.mock.t.Fatalf("EventsServiceMock.UpdateEvent mock is already set by Expect")
	}

	if mmUpdateEvent.defaultExpectation.paramPtrs == nil {
		mmUpdateEvent.defaultExpectation.paramPtrs = &EventsServiceMockUpdateEventParamPtrs{}
	}
	mmUpdateEvent.defaultExpectation.paramPtrs.userID = &userID
	mmUpdateEvent.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUpdateEvent
}

// ExpectEventParam3 sets up expected param event for EventsService.UpdateEvent
func (mmUpdateEvent *mEventsServiceMockUpdateEvent) ExpectEventParam3(event *models.Event) *mEventsServiceMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("EventsServiceMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &EventsServiceMockUpdateEventExpectation{}
	}

	if mmUpdateEvent.defaultExpectation.params != nil {
		mmUpdateEvent.mock.t.Fatalf("EventsServiceMock.UpdateEvent mock is already set by Expect")
	}

	if mmUpdateEvent.defaultExpectation.paramPtrs == nil {
		mmUpdateEvent.defaultExpectation.paramPtrs = &EventsServiceMockUpdateEventParamPtrs{}
	}
	mmUpdateEvent.defaultExpectation.paramPtrs.event = &event
	mmUpdateEvent.defaultExpectation.expectationOrigins.originEvent = minimock.CallerInfo(1)

	return mmUpdateEvent
}

// Inspect accepts an inspector function that has same arguments as the EventsService.UpdateEvent
func (mmUpdateEvent *mEventsServiceMockUpdateEvent) Inspect(f func(ctx context.Context, userID int64, event *models.Event)) *mEventsServiceMockUpdateEvent {
	if mmUpdateEvent.mock.inspectFuncUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("Inspect function is already set for EventsServiceMock.UpdateEvent")
	}

	mmUpdateEvent.mock.inspectFuncUpdateEvent = f

	return mmUpdateEvent
}

// Return sets up results that will be returned by EventsService.UpdateEvent
func (mmUpdateEvent *mEventsServiceMockUpdateEvent) Return(err error) *EventsServiceMock {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("EventsServiceMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &EventsServiceMockUpdateEventExpectation{mock: mmUpdateEvent.mock}
	}
	mmUpdateEvent.defaultExpectation.results = &EventsServiceMockUpdateEventResults{err}
	mmUpdateEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateEvent.mock
}

// Set uses given function f to mock the EventsService.UpdateEvent method
func (mmUpdateEvent *mEventsServiceMockUpdateEvent) Set(f func(ctx context.Context, userID int64, event *models.Event) (err error)) *EventsServiceMock {
	if mmUpdateEvent.defaultExpectation != nil {
		mmUpdateEvent.mock.t.Fatalf("Default expectation is already set for the EventsService.UpdateEvent method")
	}

	if len(mmUpdateEvent.expectations) > 0 {
		mmUpdateEvent.mock.t.Fatalf("Some expectations are already set for the EventsService.UpdateEvent method")
	}

	mmUpdateEvent.mock.funcUpdateEvent = f
	mmUpdateEvent.mock.funcUpdateEventOrigin = minimock.CallerInfo(1)
	return mmUpdateEvent.mock
}

// When sets expectation for the EventsService.UpdateEvent which will trigger the result defined by the following
// Then helper
func (mmUpdateEvent *mEventsServiceMockUpdateEvent) When(ctx context.Context, userID int64, event *models.Event) *EventsServiceMockUpdateEventExpectation {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("EventsServiceMock.UpdateEvent mock is already set by Set")
	}

	expectation := &EventsServiceMockUpdateEventExpectation{
		mock:               mmUpdateEvent.mock,
		params:             &EventsServiceMockUpdateEventParams{ctx, userID, event},
		expectationOrigins: EventsServiceMockUpdateEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateEvent.expectations = append(mmUpdateEvent.expectations, expectation)
	return expectation
}

// Then sets up EventsService.UpdateEvent return parameters for the expectation previously defined by the When method
func (e *EventsServiceMockUpdateEventExpectation) Then(err error) *EventsServiceMock {
	e.results = &EventsServiceMockUpdateEventResults{err}
	return e.mock
}

// Times sets number of times EventsService.UpdateEvent should be invoked
func (mmUpdateEvent *mEventsServiceMockUpdateEvent) Times(n uint64) *mEventsServiceMockUpdateEvent {
	if n == 0 {
		mmUpdateEvent.mock.t.Fatalf("Times of EventsServiceMock.UpdateEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateEvent.expectedInvocations, n)
	mmUpdateEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateEvent
}

func (mmUpdateEvent *mEventsServiceMockUpdateEvent) invocationsDone() bool {
	if len(mmUpdateEvent.expectations) == 0 && mmUpdateEvent.defaultExpectation == nil && mmUpdateEvent.mock.funcUpdateEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateEvent.mock.afterUpdateEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateEvent implements mm_service.EventsService
func (mmUpdateEvent *EventsServiceMock) UpdateEvent(ctx context.Context, userID int64, event *models.Event) (err error) {
	mm_atomic.AddUint64(&mmUpdateEvent.beforeUpdateEventCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateEvent.afterUpdateEventCounter, 1)

	mmUpdateEvent.t.Helper()

	if mmUpdateEvent.inspectFuncUpdateEvent != nil {
		mmUpdateEvent.inspectFuncUpdateEvent(ctx, userID, event)
	}

	mm_params := EventsServiceMockUpdateEventParams{ctx, userID, event}

	// Record call args
	mmUpdateEvent.UpdateEventMock.mutex.Lock()
	mmUpdateEvent.UpdateEventMock.callArgs = append(mmUpdateEvent.UpdateEventMock.callArgs, &mm_params)
	mmUpdateEvent.UpdateEventMock.mutex.Unlock()

	for _, e := range mmUpdateEvent.UpdateEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateEvent.UpdateEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateEvent.UpdateEventMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateEvent.UpdateEventMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateEvent.UpdateEventMock.defaultExpectation.paramPtrs

		mm_got := EventsServiceMockUpdateEventParams{ctx, userID, event}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateEvent.t.Errorf("EventsServiceMock.UpdateEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEvent.UpdateEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUpdateEvent.t.Errorf("EventsServiceMock.UpdateEvent got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEvent.UpdateEventMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.event != nil && !minimock.Equal(*mm_want_ptrs.event, mm_got.event) {
				mmUpdateEvent.t.Errorf("EventsServiceMock.UpdateEvent got unexpected parameter event, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEvent.UpdateEventMock.defaultExpectation.expectationOrigins.originEvent, *mm_want_ptrs.event, mm_got.event, minimock.Diff(*mm_want_ptrs.event, mm_got.event))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateEvent.t.Errorf("EventsServiceMock.UpdateEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateEvent.UpdateEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateEvent.UpdateEventMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateEvent.t.Fatal("No results are set for the EventsServiceMock.UpdateEvent")
		}
		return (*mm_results).err
	}
	if mmUpdateEvent.funcUpdateEvent != nil {
		return mmUpdateEvent.funcUpdateEvent(ctx, userID, event)
	}
	mmUpdateEvent.t.Fatalf("Unexpected call to EventsServiceMock.UpdateEvent. %v %v %v", ctx, userID, event)
	return
}

// UpdateEventAfterCounter returns a count of finished EventsServiceMock.UpdateEvent invocations
func (mmUpdateEvent *EventsServiceMock) UpdateEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEvent.afterUpdateEventCounter)
}

// UpdateEventBeforeCounter returns a count of EventsServiceMock.UpdateEvent invocations
func (mmUpdateEvent *EventsServiceMock) UpdateEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEvent.beforeUpdateEventCounter)
}

// Calls returns a list of arguments used in each call to EventsServiceMock.UpdateEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateEvent *mEventsServiceMockUpdateEvent) Calls() []*EventsServiceMockUpdateEventParams {
	mmUpdateEvent.mutex.RLock()

	argCopy := make([]*EventsServiceMockUpdateEventParams, len(mmUpdateEvent.callArgs))
	copy(argCopy, mmUpdateEvent.callArgs)

	mmUpdateEvent.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateEventDone returns true if the count of the UpdateEvent invocations corresponds
// the number of defined expectations
func (m *EventsServiceMock) MinimockUpdateEventDone() bool {
	if m.UpdateEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateEventMock.invocationsDone()
}

// MinimockUpdateEventInspect logs each unmet expectation
func (m *EventsServiceMock) MinimockUpdateEventInspect() {
	for _, e := range m.UpdateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventsServiceMock.UpdateEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateEventCounter := mm_atomic.LoadUint64(&m.afterUpdateEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateEventMock.defaultExpectation != nil && afterUpdateEventCounter < 1 {
		if m.UpdateEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EventsServiceMock.UpdateEvent at\n%s", m.UpdateEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EventsServiceMock.UpdateEvent at\n%s with params: %#v", m.UpdateEventMock.defaultExpectation.expectationOrigins.origin, *m.UpdateEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateEvent != nil && afterUpdateEventCounter < 1 {
		m.t.Errorf("Expected call to EventsServiceMock.UpdateEvent at\n%s", m.funcUpdateEventOrigin)
	}

	if !m.UpdateEventMock.invocationsDone() && afterUpdateEventCounter > 0 {
		m.t.Errorf("Expected %d calls to EventsServiceMock.UpdateEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateEventMock.expectedInvocations), m.UpdateEventMock.expectedInvocationsOrigin, afterUpdateEventCounter)
	}
}

type mEventsServiceMockUserEvents struct {
	optional           bool
	mock               *EventsServiceMock
	defaultExpectation *EventsServiceMockUserEventsExpectation
	expectations       []*EventsServiceMockUserEventsExpectation

	callArgs []*EventsServiceMockUserEventsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EventsServiceMockUserEventsExpectation specifies expectation struct of the EventsService.UserEvents
type EventsServiceMockUserEventsExpectation struct {
	mock               *EventsServiceMock
	params             *EventsServiceMockUserEventsParams
	paramPtrs          *EventsServiceMockUserEventsParamPtrs
	expectationOrigins EventsServiceMockUserEventsExpectationOrigins
	results            *EventsServiceMockUserEventsResults
	returnOrigin       string
	Counter            uint64
}

// EventsServiceMockUserEventsParams contains parameters of the EventsService.UserEvents
type EventsServiceMockUserEventsParams struct {
	ctx    context.Context
	userID int64
}

// EventsServiceMockUserEventsParamPtrs contains pointers to parameters of the EventsService.UserEvents
type EventsServiceMockUserEventsParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// EventsServiceMockUserEventsResults contains results of the EventsService.UserEvents
type EventsServiceMockUserEventsResults struct {
	epa1 []*models.Event
	err  error
}

// EventsServiceMockUserEventsOrigins contains origins of expectations of the EventsService.UserEvents
type EventsServiceMockUserEventsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserEvents *mEventsServiceMockUserEvents) Optional() *mEventsServiceMockUserEvents {
	mmUserEvents.optional = true
	return mmUserEvents
}

// Expect sets up expected params for EventsService.UserEvents
func (mmUserEvents *mEventsServiceMockUserEvents) Expect(ctx context.Context, userID int64) *mEventsServiceMockUserEvents {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("EventsServiceMock.UserEvents mock is already set by Set")
	}

	if mmUserEvents.defaultExpectation == nil {
		mmUserEvents.defaultExpectation = &EventsServiceMockUserEventsExpectation{}
	}

	if mmUserEvents.defaultExpectation.paramPtrs != nil {
		mmUserEvents.mock.t.Fatalf("EventsServiceMock.UserEvents mock is already set by ExpectParams functions")
	}

	mmUserEvents.defaultExpectation.params = &EventsServiceMockUserEventsParams{ctx, userID}
	mmUserEvents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserEvents.expectations {
		if minimock.Equal(e.params, mmUserEvents.defaultExpectation.params) {
			mmUserEvents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserEvents.defaultExpectation.params)
		}
	}

	return mmUserEvents
}

// ExpectCtxParam1 sets up expected param ctx for EventsService.UserEvents
func (mmUserEvents *mEventsServiceMockUserEvents) ExpectCtxParam1(ctx context.Context) *mEventsServiceMockUserEvents {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("EventsServiceMock.UserEvents mock is already set by Set")
	}

	if mmUserEvents.defaultExpectation == nil {
		mmUserEvents.defaultExpectation = &EventsServiceMockUserEventsExpectation{}
	}

	if mmUserEvents.defaultExpectation.params != nil {
		mmUserEvents.mock.t.Fatalf("EventsServiceMock.UserEvents mock is already set by Expect")
	}

	if mmUserEvents.defaultExpectation.paramPtrs == nil {
		mmUserEvents.defaultExpectation.paramPtrs = &EventsServiceMockUserEventsParamPtrs{}
	}
	mmUserEvents.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserEvents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserEvents
}

// ExpectUserIDParam2 sets up expected param userID for EventsService.UserEvents
func (mmUserEvents *mEventsServiceMockUserEvents) ExpectUserIDParam2(userID int64) *mEventsServiceMockUserEvents {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("EventsServiceMock.UserEvents mock is already set by Set")
	}

	if mmUserEvents.defaultExpectation == nil {
		mmUserEvents.defaultExpectation = &EventsServiceMockUserEventsExpectation{}
	}

	if mmUserEvents.defaultExpectation.params != nil {
		mmUserEvents.mock.t.Fatalf("EventsServiceMock.UserEvents mock is already set by Expect")
	}

	if mmUserEvents.defaultExpectation.paramPtrs == nil {
		mmUserEvents.defaultExpectation.paramPtrs = &EventsServiceMockUserEventsParamPtrs{}
	}
	mmUserEvents.defaultExpectation.paramPtrs.userID = &userID
	mmUserEvents.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUserEvents
}

// Inspect accepts an inspector function that has same arguments as the EventsService.UserEvents
func (mmUserEvents *mEventsServiceMockUserEvents) Inspect(f func(ctx context.Context, userID int64)) *mEventsServiceMockUserEvents {
	if mmUserEvents.mock.inspectFuncUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("Inspect function is already set for EventsServiceMock.UserEvents")
	}

	mmUserEvents.mock.inspectFuncUserEvents = f

	return mmUserEvents
}

// Return sets up results that will be returned by EventsService.UserEvents
func (mmUserEvents *mEventsServiceMockUserEvents) Return(epa1 []*models.Event, err error) *EventsServiceMock {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("EventsServiceMock.UserEvents mock is already set by Set")
	}

	if mmUserEvents.defaultExpectation == nil {
		mmUserEvents.defaultExpectation = &EventsServiceMockUserEventsExpectation{mock: mmUserEvents.mock}
	}
	mmUserEvents.defaultExpectation.results = &EventsServiceMockUserEventsResults{epa1, err}
	mmUserEvents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserEvents.mock
}

// Set uses given function f to mock the EventsService.UserEvents method
func (mmUserEvents *mEventsServiceMockUserEvents) Set(f func(ctx context.Context, userID int64) (epa1 []*models.Event, err error)) *EventsServiceMock {
	if mmUserEvents.defaultExpectation != nil {
		mmUserEvents.mock.t.Fatalf("Default expectation is already set for the EventsService.UserEvents method")
	}

	if len(mmUserEvents.expectations) > 0 {
		mmUserEvents.mock.t.Fatalf("Some expectations are already set for the EventsService.UserEvents method")
	}

	mmUserEvents.mock.funcUserEvents = f
	mmUserEvents.mock.funcUserEventsOrigin = minimock.CallerInfo(1)
	return mmUserEvents.mock
}

// When sets expectation for the EventsService.UserEvents which will trigger the result defined by the following
// Then helper
func (mmUserEvents *mEventsServiceMockUserEvents) When(ctx context.Context, userID int64) *EventsServiceMockUserEventsExpectation {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("EventsServiceMock.UserEvents mock is already set by Set")
	}

	expectation := &EventsServiceMockUserEventsExpectation{
		mock:               mmUserEvents.mock,
		params:             &EventsServiceMockUserEventsParams{ctx, userID},
		expectationOrigins: EventsServiceMockUserEventsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserEvents.expectations = append(mmUserEvents.expectations, expectation)
	return expectation
}

// Then sets up EventsService.UserEvents return parameters for the expectation previously defined by the When method
func (e *EventsServiceMockUserEventsExpectation) Then(epa1 []*models.Event, err error) *EventsServiceMock {
	e.results = &EventsServiceMockUserEventsResults{epa1, err}
	return e.mock
}

// Times sets number of times EventsService.UserEvents should be invoked
func (mmUserEvents *mEventsServiceMockUserEvents) Times(n uint64) *mEventsServiceMockUserEvents {
	if n == 0 {
		mmUserEvents.mock.t.Fatalf("Times of EventsServiceMock.UserEvents mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserEvents.expectedInvocations, n)
	mmUserEvents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserEvents
}

func (mmUserEvents *mEventsServiceMockUserEvents) invocationsDone() bool {
	if len(mmUserEvents.expectations) == 0 && mmUserEvents.defaultExpectation == nil && mmUserEvents.mock.funcUserEvents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserEvents.mock.afterUserEventsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserEvents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserEvents implements mm_service.EventsService
func (mmUserEvents *EventsServiceMock) UserEvents(ctx context.Context, userID int64) (epa1 []*models.Event, err error) {
	mm_atomic.AddUint64(&mmUserEvents.beforeUserEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmUserEvents.afterUserEventsCounter, 1)

	mmUserEvents.t.Helper()

	if mmUserEvents.inspectFuncUserEvents != nil {
		mmUserEvents.inspectFuncUserEvents(ctx, userID)
	}

	mm_params := EventsServiceMockUserEventsParams{ctx, userID}

	// Record call args
	mmUserEvents.UserEventsMock.mutex.Lock()
	mmUserEvents.UserEventsMock.callArgs = append(mmUserEvents.UserEventsMock.callArgs, &mm_params)
	mmUserEvents.UserEventsMock.mutex.Unlock()

	for _, e := range mmUserEvents.UserEventsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.epa1, e.results.err
		}
	}

	if mmUserEvents.UserEventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserEvents.UserEventsMock.defaultExpectation.Counter, 1)
		mm_want := mmUserEvents.UserEventsMock.defaultExpectation.params
		mm_want_ptrs := mmUserEvents.UserEventsMock.defaultExpectation.paramPtrs

		mm_got := EventsServiceMockUserEventsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserEvents.t.Errorf("EventsServiceMock.UserEvents got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserEvents.UserEventsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUserEvents.t.Errorf("EventsServiceMock.UserEvents got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserEvents.UserEventsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserEvents.t.Errorf("EventsServiceMock.UserEvents got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserEvents.UserEventsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserEvents.UserEventsMock.defaultExpectation.results
		if mm_results == nil {
			mmUserEvents.t.Fatal("No results are set for the EventsServiceMock.UserEvents")
		}
		return (*mm_results).epa1, (*mm_results).err
	}
	if mmUserEvents.funcUserEvents != nil {
		return mmUserEvents.funcUserEvents(ctx, userID)
	}
	mmUserEvents.t.Fatalf("Unexpected call to EventsServiceMock.UserEvents. %v %v", ctx, userID)
	return
}

// UserEventsAfterCounter returns a count of finished EventsServiceMock.UserEvents invocations
func (mmUserEvents *EventsServiceMock) UserEventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserEvents.afterUserEventsCounter)
}

// UserEventsBeforeCounter returns a count of EventsServiceMock.UserEvents invocations
func (mmUserEvents *EventsServiceMock) UserEventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserEvents.beforeUserEventsCounter)
}

// Calls returns a list of arguments used in each call to EventsServiceMock.UserEvents.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserEvents *mEventsServiceMockUserEvents) Calls() []*EventsServiceMockUserEventsParams {
	mmUserEvents.mutex.RLock()

	argCopy := make([]*EventsServiceMockUserEventsParams, len(mmUserEvents.callArgs))
	copy(argCopy, mmUserEvents.callArgs)

	mmUserEvents.mutex.RUnlock()

	return argCopy
}

// MinimockUserEventsDone returns true if the count of the UserEvents invocations corresponds
// the number of defined expectations
func (m *EventsServiceMock) MinimockUserEventsDone() bool {
	if m.UserEventsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserEventsMock.invocationsDone()
}

// MinimockUserEventsInspect logs each unmet expectation
func (m *EventsServiceMock) MinimockUserEventsInspect() {
	for _, e := range m.UserEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventsServiceMock.UserEvents at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserEventsCounter := mm_atomic.LoadUint64(&m.afterUserEventsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserEventsMock.defaultExpectation != nil && afterUserEventsCounter < 1 {
		if m.UserEventsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EventsServiceMock.UserEvents at\n%s", m.UserEventsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EventsServiceMock.UserEvents at\n%s with params: %#v", m.UserEventsMock.defaultExpectation.expectationOrigins.origin, *m.UserEventsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserEvents != nil && afterUserEventsCounter < 1 {
		m.t.Errorf("Expected call to EventsServiceMock.UserEvents at\n%s", m.funcUserEventsOrigin)
	}

	if !m.UserEventsMock.invocationsDone() && afterUserEventsCounter > 0 {
		m.t.Errorf("Expected %d calls to EventsServiceMock.UserEvents at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserEventsMock.expectedInvocations), m.UserEventsMock.expectedInvocationsOrigin, afterUserEventsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EventsServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateEventInspect()

			m.MinimockDeleteEventInspect()

			m.MinimockEventInspect()

			m.MinimockEventsInspect()

			m.MinimockUpdateEventInspect()

			m.MinimockUserEventsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EventsServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EventsServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateEventDone() &&
		m.MinimockDeleteEventDone() &&
		m.MinimockEventDone() &&
		m.MinimockEventsDone() &&
		m.MinimockUpdateEventDone() &&
		m.MinimockUserEventsDone()
}
