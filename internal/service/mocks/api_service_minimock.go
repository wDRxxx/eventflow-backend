// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/wDRxxx/eventflow-backend/internal/service.ApiService -o api_service_minimock.go -n ApiServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/wDRxxx/eventflow-backend/internal/models"
)

// ApiServiceMock implements mm_service.ApiService
type ApiServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAccessToken          func(ctx context.Context, refreshToken string) (s1 string, err error)
	funcAccessTokenOrigin    string
	inspectFuncAccessToken   func(ctx context.Context, refreshToken string)
	afterAccessTokenCounter  uint64
	beforeAccessTokenCounter uint64
	AccessTokenMock          mApiServiceMockAccessToken

	funcBuyTicket          func(ctx context.Context, req *models.BuyTicketRequest) (s1 string, err error)
	funcBuyTicketOrigin    string
	inspectFuncBuyTicket   func(ctx context.Context, req *models.BuyTicketRequest)
	afterBuyTicketCounter  uint64
	beforeBuyTicketCounter uint64
	BuyTicketMock          mApiServiceMockBuyTicket

	funcCreateEvent          func(ctx context.Context, event *models.Event) (i1 int64, err error)
	funcCreateEventOrigin    string
	inspectFuncCreateEvent   func(ctx context.Context, event *models.Event)
	afterCreateEventCounter  uint64
	beforeCreateEventCounter uint64
	CreateEventMock          mApiServiceMockCreateEvent

	funcDeleteEvent          func(ctx context.Context, userID int64, urlTitle string) (err error)
	funcDeleteEventOrigin    string
	inspectFuncDeleteEvent   func(ctx context.Context, userID int64, urlTitle string)
	afterDeleteEventCounter  uint64
	beforeDeleteEventCounter uint64
	DeleteEventMock          mApiServiceMockDeleteEvent

	funcEvent          func(ctx context.Context, urlTitle string) (ep1 *models.Event, err error)
	funcEventOrigin    string
	inspectFuncEvent   func(ctx context.Context, urlTitle string)
	afterEventCounter  uint64
	beforeEventCounter uint64
	EventMock          mApiServiceMockEvent

	funcEvents          func(ctx context.Context, page int) (epa1 []*models.Event, err error)
	funcEventsOrigin    string
	inspectFuncEvents   func(ctx context.Context, page int)
	afterEventsCounter  uint64
	beforeEventsCounter uint64
	EventsMock          mApiServiceMockEvents

	funcLogin          func(ctx context.Context, user *models.User) (s1 string, err error)
	funcLoginOrigin    string
	inspectFuncLogin   func(ctx context.Context, user *models.User)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mApiServiceMockLogin

	funcRegisterUser          func(ctx context.Context, user *models.User) (err error)
	funcRegisterUserOrigin    string
	inspectFuncRegisterUser   func(ctx context.Context, user *models.User)
	afterRegisterUserCounter  uint64
	beforeRegisterUserCounter uint64
	RegisterUserMock          mApiServiceMockRegisterUser

	funcTicket          func(ctx context.Context, ticketID string) (tp1 *models.Ticket, err error)
	funcTicketOrigin    string
	inspectFuncTicket   func(ctx context.Context, ticketID string)
	afterTicketCounter  uint64
	beforeTicketCounter uint64
	TicketMock          mApiServiceMockTicket

	funcUpdateEvent          func(ctx context.Context, userID int64, event *models.Event) (err error)
	funcUpdateEventOrigin    string
	inspectFuncUpdateEvent   func(ctx context.Context, userID int64, event *models.Event)
	afterUpdateEventCounter  uint64
	beforeUpdateEventCounter uint64
	UpdateEventMock          mApiServiceMockUpdateEvent

	funcUpdateUser          func(ctx context.Context, user *models.User) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, user *models.User)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mApiServiceMockUpdateUser

	funcUser          func(ctx context.Context, userEmail string) (up1 *models.User, err error)
	funcUserOrigin    string
	inspectFuncUser   func(ctx context.Context, userEmail string)
	afterUserCounter  uint64
	beforeUserCounter uint64
	UserMock          mApiServiceMockUser

	funcUserEvents          func(ctx context.Context, userID int64) (epa1 []*models.Event, err error)
	funcUserEventsOrigin    string
	inspectFuncUserEvents   func(ctx context.Context, userID int64)
	afterUserEventsCounter  uint64
	beforeUserEventsCounter uint64
	UserEventsMock          mApiServiceMockUserEvents

	funcUserTickets          func(ctx context.Context, userID int64) (tpa1 []*models.Ticket, err error)
	funcUserTicketsOrigin    string
	inspectFuncUserTickets   func(ctx context.Context, userID int64)
	afterUserTicketsCounter  uint64
	beforeUserTicketsCounter uint64
	UserTicketsMock          mApiServiceMockUserTickets
}

// NewApiServiceMock returns a mock for mm_service.ApiService
func NewApiServiceMock(t minimock.Tester) *ApiServiceMock {
	m := &ApiServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AccessTokenMock = mApiServiceMockAccessToken{mock: m}
	m.AccessTokenMock.callArgs = []*ApiServiceMockAccessTokenParams{}

	m.BuyTicketMock = mApiServiceMockBuyTicket{mock: m}
	m.BuyTicketMock.callArgs = []*ApiServiceMockBuyTicketParams{}

	m.CreateEventMock = mApiServiceMockCreateEvent{mock: m}
	m.CreateEventMock.callArgs = []*ApiServiceMockCreateEventParams{}

	m.DeleteEventMock = mApiServiceMockDeleteEvent{mock: m}
	m.DeleteEventMock.callArgs = []*ApiServiceMockDeleteEventParams{}

	m.EventMock = mApiServiceMockEvent{mock: m}
	m.EventMock.callArgs = []*ApiServiceMockEventParams{}

	m.EventsMock = mApiServiceMockEvents{mock: m}
	m.EventsMock.callArgs = []*ApiServiceMockEventsParams{}

	m.LoginMock = mApiServiceMockLogin{mock: m}
	m.LoginMock.callArgs = []*ApiServiceMockLoginParams{}

	m.RegisterUserMock = mApiServiceMockRegisterUser{mock: m}
	m.RegisterUserMock.callArgs = []*ApiServiceMockRegisterUserParams{}

	m.TicketMock = mApiServiceMockTicket{mock: m}
	m.TicketMock.callArgs = []*ApiServiceMockTicketParams{}

	m.UpdateEventMock = mApiServiceMockUpdateEvent{mock: m}
	m.UpdateEventMock.callArgs = []*ApiServiceMockUpdateEventParams{}

	m.UpdateUserMock = mApiServiceMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*ApiServiceMockUpdateUserParams{}

	m.UserMock = mApiServiceMockUser{mock: m}
	m.UserMock.callArgs = []*ApiServiceMockUserParams{}

	m.UserEventsMock = mApiServiceMockUserEvents{mock: m}
	m.UserEventsMock.callArgs = []*ApiServiceMockUserEventsParams{}

	m.UserTicketsMock = mApiServiceMockUserTickets{mock: m}
	m.UserTicketsMock.callArgs = []*ApiServiceMockUserTicketsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mApiServiceMockAccessToken struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockAccessTokenExpectation
	expectations       []*ApiServiceMockAccessTokenExpectation

	callArgs []*ApiServiceMockAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockAccessTokenExpectation specifies expectation struct of the ApiService.AccessToken
type ApiServiceMockAccessTokenExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockAccessTokenParams
	paramPtrs          *ApiServiceMockAccessTokenParamPtrs
	expectationOrigins ApiServiceMockAccessTokenExpectationOrigins
	results            *ApiServiceMockAccessTokenResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockAccessTokenParams contains parameters of the ApiService.AccessToken
type ApiServiceMockAccessTokenParams struct {
	ctx          context.Context
	refreshToken string
}

// ApiServiceMockAccessTokenParamPtrs contains pointers to parameters of the ApiService.AccessToken
type ApiServiceMockAccessTokenParamPtrs struct {
	ctx          *context.Context
	refreshToken *string
}

// ApiServiceMockAccessTokenResults contains results of the ApiService.AccessToken
type ApiServiceMockAccessTokenResults struct {
	s1  string
	err error
}

// ApiServiceMockAccessTokenOrigins contains origins of expectations of the ApiService.AccessToken
type ApiServiceMockAccessTokenExpectationOrigins struct {
	origin             string
	originCtx          string
	originRefreshToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAccessToken *mApiServiceMockAccessToken) Optional() *mApiServiceMockAccessToken {
	mmAccessToken.optional = true
	return mmAccessToken
}

// Expect sets up expected params for ApiService.AccessToken
func (mmAccessToken *mApiServiceMockAccessToken) Expect(ctx context.Context, refreshToken string) *mApiServiceMockAccessToken {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("ApiServiceMock.AccessToken mock is already set by Set")
	}

	if mmAccessToken.defaultExpectation == nil {
		mmAccessToken.defaultExpectation = &ApiServiceMockAccessTokenExpectation{}
	}

	if mmAccessToken.defaultExpectation.paramPtrs != nil {
		mmAccessToken.mock.t.Fatalf("ApiServiceMock.AccessToken mock is already set by ExpectParams functions")
	}

	mmAccessToken.defaultExpectation.params = &ApiServiceMockAccessTokenParams{ctx, refreshToken}
	mmAccessToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAccessToken.expectations {
		if minimock.Equal(e.params, mmAccessToken.defaultExpectation.params) {
			mmAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAccessToken.defaultExpectation.params)
		}
	}

	return mmAccessToken
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.AccessToken
func (mmAccessToken *mApiServiceMockAccessToken) ExpectCtxParam1(ctx context.Context) *mApiServiceMockAccessToken {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("ApiServiceMock.AccessToken mock is already set by Set")
	}

	if mmAccessToken.defaultExpectation == nil {
		mmAccessToken.defaultExpectation = &ApiServiceMockAccessTokenExpectation{}
	}

	if mmAccessToken.defaultExpectation.params != nil {
		mmAccessToken.mock.t.Fatalf("ApiServiceMock.AccessToken mock is already set by Expect")
	}

	if mmAccessToken.defaultExpectation.paramPtrs == nil {
		mmAccessToken.defaultExpectation.paramPtrs = &ApiServiceMockAccessTokenParamPtrs{}
	}
	mmAccessToken.defaultExpectation.paramPtrs.ctx = &ctx
	mmAccessToken.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAccessToken
}

// ExpectRefreshTokenParam2 sets up expected param refreshToken for ApiService.AccessToken
func (mmAccessToken *mApiServiceMockAccessToken) ExpectRefreshTokenParam2(refreshToken string) *mApiServiceMockAccessToken {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("ApiServiceMock.AccessToken mock is already set by Set")
	}

	if mmAccessToken.defaultExpectation == nil {
		mmAccessToken.defaultExpectation = &ApiServiceMockAccessTokenExpectation{}
	}

	if mmAccessToken.defaultExpectation.params != nil {
		mmAccessToken.mock.t.Fatalf("ApiServiceMock.AccessToken mock is already set by Expect")
	}

	if mmAccessToken.defaultExpectation.paramPtrs == nil {
		mmAccessToken.defaultExpectation.paramPtrs = &ApiServiceMockAccessTokenParamPtrs{}
	}
	mmAccessToken.defaultExpectation.paramPtrs.refreshToken = &refreshToken
	mmAccessToken.defaultExpectation.expectationOrigins.originRefreshToken = minimock.CallerInfo(1)

	return mmAccessToken
}

// Inspect accepts an inspector function that has same arguments as the ApiService.AccessToken
func (mmAccessToken *mApiServiceMockAccessToken) Inspect(f func(ctx context.Context, refreshToken string)) *mApiServiceMockAccessToken {
	if mmAccessToken.mock.inspectFuncAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.AccessToken")
	}

	mmAccessToken.mock.inspectFuncAccessToken = f

	return mmAccessToken
}

// Return sets up results that will be returned by ApiService.AccessToken
func (mmAccessToken *mApiServiceMockAccessToken) Return(s1 string, err error) *ApiServiceMock {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("ApiServiceMock.AccessToken mock is already set by Set")
	}

	if mmAccessToken.defaultExpectation == nil {
		mmAccessToken.defaultExpectation = &ApiServiceMockAccessTokenExpectation{mock: mmAccessToken.mock}
	}
	mmAccessToken.defaultExpectation.results = &ApiServiceMockAccessTokenResults{s1, err}
	mmAccessToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAccessToken.mock
}

// Set uses given function f to mock the ApiService.AccessToken method
func (mmAccessToken *mApiServiceMockAccessToken) Set(f func(ctx context.Context, refreshToken string) (s1 string, err error)) *ApiServiceMock {
	if mmAccessToken.defaultExpectation != nil {
		mmAccessToken.mock.t.Fatalf("Default expectation is already set for the ApiService.AccessToken method")
	}

	if len(mmAccessToken.expectations) > 0 {
		mmAccessToken.mock.t.Fatalf("Some expectations are already set for the ApiService.AccessToken method")
	}

	mmAccessToken.mock.funcAccessToken = f
	mmAccessToken.mock.funcAccessTokenOrigin = minimock.CallerInfo(1)
	return mmAccessToken.mock
}

// When sets expectation for the ApiService.AccessToken which will trigger the result defined by the following
// Then helper
func (mmAccessToken *mApiServiceMockAccessToken) When(ctx context.Context, refreshToken string) *ApiServiceMockAccessTokenExpectation {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("ApiServiceMock.AccessToken mock is already set by Set")
	}

	expectation := &ApiServiceMockAccessTokenExpectation{
		mock:               mmAccessToken.mock,
		params:             &ApiServiceMockAccessTokenParams{ctx, refreshToken},
		expectationOrigins: ApiServiceMockAccessTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAccessToken.expectations = append(mmAccessToken.expectations, expectation)
	return expectation
}

// Then sets up ApiService.AccessToken return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockAccessTokenExpectation) Then(s1 string, err error) *ApiServiceMock {
	e.results = &ApiServiceMockAccessTokenResults{s1, err}
	return e.mock
}

// Times sets number of times ApiService.AccessToken should be invoked
func (mmAccessToken *mApiServiceMockAccessToken) Times(n uint64) *mApiServiceMockAccessToken {
	if n == 0 {
		mmAccessToken.mock.t.Fatalf("Times of ApiServiceMock.AccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAccessToken.expectedInvocations, n)
	mmAccessToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAccessToken
}

func (mmAccessToken *mApiServiceMockAccessToken) invocationsDone() bool {
	if len(mmAccessToken.expectations) == 0 && mmAccessToken.defaultExpectation == nil && mmAccessToken.mock.funcAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAccessToken.mock.afterAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AccessToken implements mm_service.ApiService
func (mmAccessToken *ApiServiceMock) AccessToken(ctx context.Context, refreshToken string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmAccessToken.beforeAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmAccessToken.afterAccessTokenCounter, 1)

	mmAccessToken.t.Helper()

	if mmAccessToken.inspectFuncAccessToken != nil {
		mmAccessToken.inspectFuncAccessToken(ctx, refreshToken)
	}

	mm_params := ApiServiceMockAccessTokenParams{ctx, refreshToken}

	// Record call args
	mmAccessToken.AccessTokenMock.mutex.Lock()
	mmAccessToken.AccessTokenMock.callArgs = append(mmAccessToken.AccessTokenMock.callArgs, &mm_params)
	mmAccessToken.AccessTokenMock.mutex.Unlock()

	for _, e := range mmAccessToken.AccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmAccessToken.AccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAccessToken.AccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmAccessToken.AccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmAccessToken.AccessTokenMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockAccessTokenParams{ctx, refreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAccessToken.t.Errorf("ApiServiceMock.AccessToken got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAccessToken.AccessTokenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.refreshToken != nil && !minimock.Equal(*mm_want_ptrs.refreshToken, mm_got.refreshToken) {
				mmAccessToken.t.Errorf("ApiServiceMock.AccessToken got unexpected parameter refreshToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAccessToken.AccessTokenMock.defaultExpectation.expectationOrigins.originRefreshToken, *mm_want_ptrs.refreshToken, mm_got.refreshToken, minimock.Diff(*mm_want_ptrs.refreshToken, mm_got.refreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAccessToken.t.Errorf("ApiServiceMock.AccessToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAccessToken.AccessTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAccessToken.AccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmAccessToken.t.Fatal("No results are set for the ApiServiceMock.AccessToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmAccessToken.funcAccessToken != nil {
		return mmAccessToken.funcAccessToken(ctx, refreshToken)
	}
	mmAccessToken.t.Fatalf("Unexpected call to ApiServiceMock.AccessToken. %v %v", ctx, refreshToken)
	return
}

// AccessTokenAfterCounter returns a count of finished ApiServiceMock.AccessToken invocations
func (mmAccessToken *ApiServiceMock) AccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessToken.afterAccessTokenCounter)
}

// AccessTokenBeforeCounter returns a count of ApiServiceMock.AccessToken invocations
func (mmAccessToken *ApiServiceMock) AccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessToken.beforeAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.AccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAccessToken *mApiServiceMockAccessToken) Calls() []*ApiServiceMockAccessTokenParams {
	mmAccessToken.mutex.RLock()

	argCopy := make([]*ApiServiceMockAccessTokenParams, len(mmAccessToken.callArgs))
	copy(argCopy, mmAccessToken.callArgs)

	mmAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockAccessTokenDone returns true if the count of the AccessToken invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockAccessTokenDone() bool {
	if m.AccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AccessTokenMock.invocationsDone()
}

// MinimockAccessTokenInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockAccessTokenInspect() {
	for _, e := range m.AccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.AccessToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAccessTokenCounter := mm_atomic.LoadUint64(&m.afterAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AccessTokenMock.defaultExpectation != nil && afterAccessTokenCounter < 1 {
		if m.AccessTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.AccessToken at\n%s", m.AccessTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.AccessToken at\n%s with params: %#v", m.AccessTokenMock.defaultExpectation.expectationOrigins.origin, *m.AccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccessToken != nil && afterAccessTokenCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.AccessToken at\n%s", m.funcAccessTokenOrigin)
	}

	if !m.AccessTokenMock.invocationsDone() && afterAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.AccessToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AccessTokenMock.expectedInvocations), m.AccessTokenMock.expectedInvocationsOrigin, afterAccessTokenCounter)
	}
}

type mApiServiceMockBuyTicket struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockBuyTicketExpectation
	expectations       []*ApiServiceMockBuyTicketExpectation

	callArgs []*ApiServiceMockBuyTicketParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockBuyTicketExpectation specifies expectation struct of the ApiService.BuyTicket
type ApiServiceMockBuyTicketExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockBuyTicketParams
	paramPtrs          *ApiServiceMockBuyTicketParamPtrs
	expectationOrigins ApiServiceMockBuyTicketExpectationOrigins
	results            *ApiServiceMockBuyTicketResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockBuyTicketParams contains parameters of the ApiService.BuyTicket
type ApiServiceMockBuyTicketParams struct {
	ctx context.Context
	req *models.BuyTicketRequest
}

// ApiServiceMockBuyTicketParamPtrs contains pointers to parameters of the ApiService.BuyTicket
type ApiServiceMockBuyTicketParamPtrs struct {
	ctx *context.Context
	req **models.BuyTicketRequest
}

// ApiServiceMockBuyTicketResults contains results of the ApiService.BuyTicket
type ApiServiceMockBuyTicketResults struct {
	s1  string
	err error
}

// ApiServiceMockBuyTicketOrigins contains origins of expectations of the ApiService.BuyTicket
type ApiServiceMockBuyTicketExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBuyTicket *mApiServiceMockBuyTicket) Optional() *mApiServiceMockBuyTicket {
	mmBuyTicket.optional = true
	return mmBuyTicket
}

// Expect sets up expected params for ApiService.BuyTicket
func (mmBuyTicket *mApiServiceMockBuyTicket) Expect(ctx context.Context, req *models.BuyTicketRequest) *mApiServiceMockBuyTicket {
	if mmBuyTicket.mock.funcBuyTicket != nil {
		mmBuyTicket.mock.t.Fatalf("ApiServiceMock.BuyTicket mock is already set by Set")
	}

	if mmBuyTicket.defaultExpectation == nil {
		mmBuyTicket.defaultExpectation = &ApiServiceMockBuyTicketExpectation{}
	}

	if mmBuyTicket.defaultExpectation.paramPtrs != nil {
		mmBuyTicket.mock.t.Fatalf("ApiServiceMock.BuyTicket mock is already set by ExpectParams functions")
	}

	mmBuyTicket.defaultExpectation.params = &ApiServiceMockBuyTicketParams{ctx, req}
	mmBuyTicket.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmBuyTicket.expectations {
		if minimock.Equal(e.params, mmBuyTicket.defaultExpectation.params) {
			mmBuyTicket.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuyTicket.defaultExpectation.params)
		}
	}

	return mmBuyTicket
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.BuyTicket
func (mmBuyTicket *mApiServiceMockBuyTicket) ExpectCtxParam1(ctx context.Context) *mApiServiceMockBuyTicket {
	if mmBuyTicket.mock.funcBuyTicket != nil {
		mmBuyTicket.mock.t.Fatalf("ApiServiceMock.BuyTicket mock is already set by Set")
	}

	if mmBuyTicket.defaultExpectation == nil {
		mmBuyTicket.defaultExpectation = &ApiServiceMockBuyTicketExpectation{}
	}

	if mmBuyTicket.defaultExpectation.params != nil {
		mmBuyTicket.mock.t.Fatalf("ApiServiceMock.BuyTicket mock is already set by Expect")
	}

	if mmBuyTicket.defaultExpectation.paramPtrs == nil {
		mmBuyTicket.defaultExpectation.paramPtrs = &ApiServiceMockBuyTicketParamPtrs{}
	}
	mmBuyTicket.defaultExpectation.paramPtrs.ctx = &ctx
	mmBuyTicket.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmBuyTicket
}

// ExpectReqParam2 sets up expected param req for ApiService.BuyTicket
func (mmBuyTicket *mApiServiceMockBuyTicket) ExpectReqParam2(req *models.BuyTicketRequest) *mApiServiceMockBuyTicket {
	if mmBuyTicket.mock.funcBuyTicket != nil {
		mmBuyTicket.mock.t.Fatalf("ApiServiceMock.BuyTicket mock is already set by Set")
	}

	if mmBuyTicket.defaultExpectation == nil {
		mmBuyTicket.defaultExpectation = &ApiServiceMockBuyTicketExpectation{}
	}

	if mmBuyTicket.defaultExpectation.params != nil {
		mmBuyTicket.mock.t.Fatalf("ApiServiceMock.BuyTicket mock is already set by Expect")
	}

	if mmBuyTicket.defaultExpectation.paramPtrs == nil {
		mmBuyTicket.defaultExpectation.paramPtrs = &ApiServiceMockBuyTicketParamPtrs{}
	}
	mmBuyTicket.defaultExpectation.paramPtrs.req = &req
	mmBuyTicket.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmBuyTicket
}

// Inspect accepts an inspector function that has same arguments as the ApiService.BuyTicket
func (mmBuyTicket *mApiServiceMockBuyTicket) Inspect(f func(ctx context.Context, req *models.BuyTicketRequest)) *mApiServiceMockBuyTicket {
	if mmBuyTicket.mock.inspectFuncBuyTicket != nil {
		mmBuyTicket.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.BuyTicket")
	}

	mmBuyTicket.mock.inspectFuncBuyTicket = f

	return mmBuyTicket
}

// Return sets up results that will be returned by ApiService.BuyTicket
func (mmBuyTicket *mApiServiceMockBuyTicket) Return(s1 string, err error) *ApiServiceMock {
	if mmBuyTicket.mock.funcBuyTicket != nil {
		mmBuyTicket.mock.t.Fatalf("ApiServiceMock.BuyTicket mock is already set by Set")
	}

	if mmBuyTicket.defaultExpectation == nil {
		mmBuyTicket.defaultExpectation = &ApiServiceMockBuyTicketExpectation{mock: mmBuyTicket.mock}
	}
	mmBuyTicket.defaultExpectation.results = &ApiServiceMockBuyTicketResults{s1, err}
	mmBuyTicket.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBuyTicket.mock
}

// Set uses given function f to mock the ApiService.BuyTicket method
func (mmBuyTicket *mApiServiceMockBuyTicket) Set(f func(ctx context.Context, req *models.BuyTicketRequest) (s1 string, err error)) *ApiServiceMock {
	if mmBuyTicket.defaultExpectation != nil {
		mmBuyTicket.mock.t.Fatalf("Default expectation is already set for the ApiService.BuyTicket method")
	}

	if len(mmBuyTicket.expectations) > 0 {
		mmBuyTicket.mock.t.Fatalf("Some expectations are already set for the ApiService.BuyTicket method")
	}

	mmBuyTicket.mock.funcBuyTicket = f
	mmBuyTicket.mock.funcBuyTicketOrigin = minimock.CallerInfo(1)
	return mmBuyTicket.mock
}

// When sets expectation for the ApiService.BuyTicket which will trigger the result defined by the following
// Then helper
func (mmBuyTicket *mApiServiceMockBuyTicket) When(ctx context.Context, req *models.BuyTicketRequest) *ApiServiceMockBuyTicketExpectation {
	if mmBuyTicket.mock.funcBuyTicket != nil {
		mmBuyTicket.mock.t.Fatalf("ApiServiceMock.BuyTicket mock is already set by Set")
	}

	expectation := &ApiServiceMockBuyTicketExpectation{
		mock:               mmBuyTicket.mock,
		params:             &ApiServiceMockBuyTicketParams{ctx, req},
		expectationOrigins: ApiServiceMockBuyTicketExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmBuyTicket.expectations = append(mmBuyTicket.expectations, expectation)
	return expectation
}

// Then sets up ApiService.BuyTicket return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockBuyTicketExpectation) Then(s1 string, err error) *ApiServiceMock {
	e.results = &ApiServiceMockBuyTicketResults{s1, err}
	return e.mock
}

// Times sets number of times ApiService.BuyTicket should be invoked
func (mmBuyTicket *mApiServiceMockBuyTicket) Times(n uint64) *mApiServiceMockBuyTicket {
	if n == 0 {
		mmBuyTicket.mock.t.Fatalf("Times of ApiServiceMock.BuyTicket mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBuyTicket.expectedInvocations, n)
	mmBuyTicket.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBuyTicket
}

func (mmBuyTicket *mApiServiceMockBuyTicket) invocationsDone() bool {
	if len(mmBuyTicket.expectations) == 0 && mmBuyTicket.defaultExpectation == nil && mmBuyTicket.mock.funcBuyTicket == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBuyTicket.mock.afterBuyTicketCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBuyTicket.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BuyTicket implements mm_service.ApiService
func (mmBuyTicket *ApiServiceMock) BuyTicket(ctx context.Context, req *models.BuyTicketRequest) (s1 string, err error) {
	mm_atomic.AddUint64(&mmBuyTicket.beforeBuyTicketCounter, 1)
	defer mm_atomic.AddUint64(&mmBuyTicket.afterBuyTicketCounter, 1)

	mmBuyTicket.t.Helper()

	if mmBuyTicket.inspectFuncBuyTicket != nil {
		mmBuyTicket.inspectFuncBuyTicket(ctx, req)
	}

	mm_params := ApiServiceMockBuyTicketParams{ctx, req}

	// Record call args
	mmBuyTicket.BuyTicketMock.mutex.Lock()
	mmBuyTicket.BuyTicketMock.callArgs = append(mmBuyTicket.BuyTicketMock.callArgs, &mm_params)
	mmBuyTicket.BuyTicketMock.mutex.Unlock()

	for _, e := range mmBuyTicket.BuyTicketMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmBuyTicket.BuyTicketMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuyTicket.BuyTicketMock.defaultExpectation.Counter, 1)
		mm_want := mmBuyTicket.BuyTicketMock.defaultExpectation.params
		mm_want_ptrs := mmBuyTicket.BuyTicketMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockBuyTicketParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBuyTicket.t.Errorf("ApiServiceMock.BuyTicket got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyTicket.BuyTicketMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmBuyTicket.t.Errorf("ApiServiceMock.BuyTicket got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyTicket.BuyTicketMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuyTicket.t.Errorf("ApiServiceMock.BuyTicket got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmBuyTicket.BuyTicketMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuyTicket.BuyTicketMock.defaultExpectation.results
		if mm_results == nil {
			mmBuyTicket.t.Fatal("No results are set for the ApiServiceMock.BuyTicket")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmBuyTicket.funcBuyTicket != nil {
		return mmBuyTicket.funcBuyTicket(ctx, req)
	}
	mmBuyTicket.t.Fatalf("Unexpected call to ApiServiceMock.BuyTicket. %v %v", ctx, req)
	return
}

// BuyTicketAfterCounter returns a count of finished ApiServiceMock.BuyTicket invocations
func (mmBuyTicket *ApiServiceMock) BuyTicketAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuyTicket.afterBuyTicketCounter)
}

// BuyTicketBeforeCounter returns a count of ApiServiceMock.BuyTicket invocations
func (mmBuyTicket *ApiServiceMock) BuyTicketBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuyTicket.beforeBuyTicketCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.BuyTicket.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuyTicket *mApiServiceMockBuyTicket) Calls() []*ApiServiceMockBuyTicketParams {
	mmBuyTicket.mutex.RLock()

	argCopy := make([]*ApiServiceMockBuyTicketParams, len(mmBuyTicket.callArgs))
	copy(argCopy, mmBuyTicket.callArgs)

	mmBuyTicket.mutex.RUnlock()

	return argCopy
}

// MinimockBuyTicketDone returns true if the count of the BuyTicket invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockBuyTicketDone() bool {
	if m.BuyTicketMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BuyTicketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BuyTicketMock.invocationsDone()
}

// MinimockBuyTicketInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockBuyTicketInspect() {
	for _, e := range m.BuyTicketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.BuyTicket at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterBuyTicketCounter := mm_atomic.LoadUint64(&m.afterBuyTicketCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BuyTicketMock.defaultExpectation != nil && afterBuyTicketCounter < 1 {
		if m.BuyTicketMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.BuyTicket at\n%s", m.BuyTicketMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.BuyTicket at\n%s with params: %#v", m.BuyTicketMock.defaultExpectation.expectationOrigins.origin, *m.BuyTicketMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuyTicket != nil && afterBuyTicketCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.BuyTicket at\n%s", m.funcBuyTicketOrigin)
	}

	if !m.BuyTicketMock.invocationsDone() && afterBuyTicketCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.BuyTicket at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BuyTicketMock.expectedInvocations), m.BuyTicketMock.expectedInvocationsOrigin, afterBuyTicketCounter)
	}
}

type mApiServiceMockCreateEvent struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockCreateEventExpectation
	expectations       []*ApiServiceMockCreateEventExpectation

	callArgs []*ApiServiceMockCreateEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockCreateEventExpectation specifies expectation struct of the ApiService.CreateEvent
type ApiServiceMockCreateEventExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockCreateEventParams
	paramPtrs          *ApiServiceMockCreateEventParamPtrs
	expectationOrigins ApiServiceMockCreateEventExpectationOrigins
	results            *ApiServiceMockCreateEventResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockCreateEventParams contains parameters of the ApiService.CreateEvent
type ApiServiceMockCreateEventParams struct {
	ctx   context.Context
	event *models.Event
}

// ApiServiceMockCreateEventParamPtrs contains pointers to parameters of the ApiService.CreateEvent
type ApiServiceMockCreateEventParamPtrs struct {
	ctx   *context.Context
	event **models.Event
}

// ApiServiceMockCreateEventResults contains results of the ApiService.CreateEvent
type ApiServiceMockCreateEventResults struct {
	i1  int64
	err error
}

// ApiServiceMockCreateEventOrigins contains origins of expectations of the ApiService.CreateEvent
type ApiServiceMockCreateEventExpectationOrigins struct {
	origin      string
	originCtx   string
	originEvent string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateEvent *mApiServiceMockCreateEvent) Optional() *mApiServiceMockCreateEvent {
	mmCreateEvent.optional = true
	return mmCreateEvent
}

// Expect sets up expected params for ApiService.CreateEvent
func (mmCreateEvent *mApiServiceMockCreateEvent) Expect(ctx context.Context, event *models.Event) *mApiServiceMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("ApiServiceMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &ApiServiceMockCreateEventExpectation{}
	}

	if mmCreateEvent.defaultExpectation.paramPtrs != nil {
		mmCreateEvent.mock.t.Fatalf("ApiServiceMock.CreateEvent mock is already set by ExpectParams functions")
	}

	mmCreateEvent.defaultExpectation.params = &ApiServiceMockCreateEventParams{ctx, event}
	mmCreateEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateEvent.expectations {
		if minimock.Equal(e.params, mmCreateEvent.defaultExpectation.params) {
			mmCreateEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateEvent.defaultExpectation.params)
		}
	}

	return mmCreateEvent
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.CreateEvent
func (mmCreateEvent *mApiServiceMockCreateEvent) ExpectCtxParam1(ctx context.Context) *mApiServiceMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("ApiServiceMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &ApiServiceMockCreateEventExpectation{}
	}

	if mmCreateEvent.defaultExpectation.params != nil {
		mmCreateEvent.mock.t.Fatalf("ApiServiceMock.CreateEvent mock is already set by Expect")
	}

	if mmCreateEvent.defaultExpectation.paramPtrs == nil {
		mmCreateEvent.defaultExpectation.paramPtrs = &ApiServiceMockCreateEventParamPtrs{}
	}
	mmCreateEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateEvent
}

// ExpectEventParam2 sets up expected param event for ApiService.CreateEvent
func (mmCreateEvent *mApiServiceMockCreateEvent) ExpectEventParam2(event *models.Event) *mApiServiceMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("ApiServiceMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &ApiServiceMockCreateEventExpectation{}
	}

	if mmCreateEvent.defaultExpectation.params != nil {
		mmCreateEvent.mock.t.Fatalf("ApiServiceMock.CreateEvent mock is already set by Expect")
	}

	if mmCreateEvent.defaultExpectation.paramPtrs == nil {
		mmCreateEvent.defaultExpectation.paramPtrs = &ApiServiceMockCreateEventParamPtrs{}
	}
	mmCreateEvent.defaultExpectation.paramPtrs.event = &event
	mmCreateEvent.defaultExpectation.expectationOrigins.originEvent = minimock.CallerInfo(1)

	return mmCreateEvent
}

// Inspect accepts an inspector function that has same arguments as the ApiService.CreateEvent
func (mmCreateEvent *mApiServiceMockCreateEvent) Inspect(f func(ctx context.Context, event *models.Event)) *mApiServiceMockCreateEvent {
	if mmCreateEvent.mock.inspectFuncCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.CreateEvent")
	}

	mmCreateEvent.mock.inspectFuncCreateEvent = f

	return mmCreateEvent
}

// Return sets up results that will be returned by ApiService.CreateEvent
func (mmCreateEvent *mApiServiceMockCreateEvent) Return(i1 int64, err error) *ApiServiceMock {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("ApiServiceMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &ApiServiceMockCreateEventExpectation{mock: mmCreateEvent.mock}
	}
	mmCreateEvent.defaultExpectation.results = &ApiServiceMockCreateEventResults{i1, err}
	mmCreateEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateEvent.mock
}

// Set uses given function f to mock the ApiService.CreateEvent method
func (mmCreateEvent *mApiServiceMockCreateEvent) Set(f func(ctx context.Context, event *models.Event) (i1 int64, err error)) *ApiServiceMock {
	if mmCreateEvent.defaultExpectation != nil {
		mmCreateEvent.mock.t.Fatalf("Default expectation is already set for the ApiService.CreateEvent method")
	}

	if len(mmCreateEvent.expectations) > 0 {
		mmCreateEvent.mock.t.Fatalf("Some expectations are already set for the ApiService.CreateEvent method")
	}

	mmCreateEvent.mock.funcCreateEvent = f
	mmCreateEvent.mock.funcCreateEventOrigin = minimock.CallerInfo(1)
	return mmCreateEvent.mock
}

// When sets expectation for the ApiService.CreateEvent which will trigger the result defined by the following
// Then helper
func (mmCreateEvent *mApiServiceMockCreateEvent) When(ctx context.Context, event *models.Event) *ApiServiceMockCreateEventExpectation {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("ApiServiceMock.CreateEvent mock is already set by Set")
	}

	expectation := &ApiServiceMockCreateEventExpectation{
		mock:               mmCreateEvent.mock,
		params:             &ApiServiceMockCreateEventParams{ctx, event},
		expectationOrigins: ApiServiceMockCreateEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateEvent.expectations = append(mmCreateEvent.expectations, expectation)
	return expectation
}

// Then sets up ApiService.CreateEvent return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockCreateEventExpectation) Then(i1 int64, err error) *ApiServiceMock {
	e.results = &ApiServiceMockCreateEventResults{i1, err}
	return e.mock
}

// Times sets number of times ApiService.CreateEvent should be invoked
func (mmCreateEvent *mApiServiceMockCreateEvent) Times(n uint64) *mApiServiceMockCreateEvent {
	if n == 0 {
		mmCreateEvent.mock.t.Fatalf("Times of ApiServiceMock.CreateEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateEvent.expectedInvocations, n)
	mmCreateEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateEvent
}

func (mmCreateEvent *mApiServiceMockCreateEvent) invocationsDone() bool {
	if len(mmCreateEvent.expectations) == 0 && mmCreateEvent.defaultExpectation == nil && mmCreateEvent.mock.funcCreateEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateEvent.mock.afterCreateEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateEvent implements mm_service.ApiService
func (mmCreateEvent *ApiServiceMock) CreateEvent(ctx context.Context, event *models.Event) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateEvent.beforeCreateEventCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateEvent.afterCreateEventCounter, 1)

	mmCreateEvent.t.Helper()

	if mmCreateEvent.inspectFuncCreateEvent != nil {
		mmCreateEvent.inspectFuncCreateEvent(ctx, event)
	}

	mm_params := ApiServiceMockCreateEventParams{ctx, event}

	// Record call args
	mmCreateEvent.CreateEventMock.mutex.Lock()
	mmCreateEvent.CreateEventMock.callArgs = append(mmCreateEvent.CreateEventMock.callArgs, &mm_params)
	mmCreateEvent.CreateEventMock.mutex.Unlock()

	for _, e := range mmCreateEvent.CreateEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateEvent.CreateEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateEvent.CreateEventMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateEvent.CreateEventMock.defaultExpectation.params
		mm_want_ptrs := mmCreateEvent.CreateEventMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockCreateEventParams{ctx, event}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateEvent.t.Errorf("ApiServiceMock.CreateEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEvent.CreateEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.event != nil && !minimock.Equal(*mm_want_ptrs.event, mm_got.event) {
				mmCreateEvent.t.Errorf("ApiServiceMock.CreateEvent got unexpected parameter event, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEvent.CreateEventMock.defaultExpectation.expectationOrigins.originEvent, *mm_want_ptrs.event, mm_got.event, minimock.Diff(*mm_want_ptrs.event, mm_got.event))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateEvent.t.Errorf("ApiServiceMock.CreateEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateEvent.CreateEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateEvent.CreateEventMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateEvent.t.Fatal("No results are set for the ApiServiceMock.CreateEvent")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateEvent.funcCreateEvent != nil {
		return mmCreateEvent.funcCreateEvent(ctx, event)
	}
	mmCreateEvent.t.Fatalf("Unexpected call to ApiServiceMock.CreateEvent. %v %v", ctx, event)
	return
}

// CreateEventAfterCounter returns a count of finished ApiServiceMock.CreateEvent invocations
func (mmCreateEvent *ApiServiceMock) CreateEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEvent.afterCreateEventCounter)
}

// CreateEventBeforeCounter returns a count of ApiServiceMock.CreateEvent invocations
func (mmCreateEvent *ApiServiceMock) CreateEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEvent.beforeCreateEventCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.CreateEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateEvent *mApiServiceMockCreateEvent) Calls() []*ApiServiceMockCreateEventParams {
	mmCreateEvent.mutex.RLock()

	argCopy := make([]*ApiServiceMockCreateEventParams, len(mmCreateEvent.callArgs))
	copy(argCopy, mmCreateEvent.callArgs)

	mmCreateEvent.mutex.RUnlock()

	return argCopy
}

// MinimockCreateEventDone returns true if the count of the CreateEvent invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockCreateEventDone() bool {
	if m.CreateEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateEventMock.invocationsDone()
}

// MinimockCreateEventInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockCreateEventInspect() {
	for _, e := range m.CreateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.CreateEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateEventCounter := mm_atomic.LoadUint64(&m.afterCreateEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEventMock.defaultExpectation != nil && afterCreateEventCounter < 1 {
		if m.CreateEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.CreateEvent at\n%s", m.CreateEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.CreateEvent at\n%s with params: %#v", m.CreateEventMock.defaultExpectation.expectationOrigins.origin, *m.CreateEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEvent != nil && afterCreateEventCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.CreateEvent at\n%s", m.funcCreateEventOrigin)
	}

	if !m.CreateEventMock.invocationsDone() && afterCreateEventCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.CreateEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateEventMock.expectedInvocations), m.CreateEventMock.expectedInvocationsOrigin, afterCreateEventCounter)
	}
}

type mApiServiceMockDeleteEvent struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockDeleteEventExpectation
	expectations       []*ApiServiceMockDeleteEventExpectation

	callArgs []*ApiServiceMockDeleteEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockDeleteEventExpectation specifies expectation struct of the ApiService.DeleteEvent
type ApiServiceMockDeleteEventExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockDeleteEventParams
	paramPtrs          *ApiServiceMockDeleteEventParamPtrs
	expectationOrigins ApiServiceMockDeleteEventExpectationOrigins
	results            *ApiServiceMockDeleteEventResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockDeleteEventParams contains parameters of the ApiService.DeleteEvent
type ApiServiceMockDeleteEventParams struct {
	ctx      context.Context
	userID   int64
	urlTitle string
}

// ApiServiceMockDeleteEventParamPtrs contains pointers to parameters of the ApiService.DeleteEvent
type ApiServiceMockDeleteEventParamPtrs struct {
	ctx      *context.Context
	userID   *int64
	urlTitle *string
}

// ApiServiceMockDeleteEventResults contains results of the ApiService.DeleteEvent
type ApiServiceMockDeleteEventResults struct {
	err error
}

// ApiServiceMockDeleteEventOrigins contains origins of expectations of the ApiService.DeleteEvent
type ApiServiceMockDeleteEventExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserID   string
	originUrlTitle string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteEvent *mApiServiceMockDeleteEvent) Optional() *mApiServiceMockDeleteEvent {
	mmDeleteEvent.optional = true
	return mmDeleteEvent
}

// Expect sets up expected params for ApiService.DeleteEvent
func (mmDeleteEvent *mApiServiceMockDeleteEvent) Expect(ctx context.Context, userID int64, urlTitle string) *mApiServiceMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("ApiServiceMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &ApiServiceMockDeleteEventExpectation{}
	}

	if mmDeleteEvent.defaultExpectation.paramPtrs != nil {
		mmDeleteEvent.mock.t.Fatalf("ApiServiceMock.DeleteEvent mock is already set by ExpectParams functions")
	}

	mmDeleteEvent.defaultExpectation.params = &ApiServiceMockDeleteEventParams{ctx, userID, urlTitle}
	mmDeleteEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteEvent.expectations {
		if minimock.Equal(e.params, mmDeleteEvent.defaultExpectation.params) {
			mmDeleteEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEvent.defaultExpectation.params)
		}
	}

	return mmDeleteEvent
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.DeleteEvent
func (mmDeleteEvent *mApiServiceMockDeleteEvent) ExpectCtxParam1(ctx context.Context) *mApiServiceMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("ApiServiceMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &ApiServiceMockDeleteEventExpectation{}
	}

	if mmDeleteEvent.defaultExpectation.params != nil {
		mmDeleteEvent.mock.t.Fatalf("ApiServiceMock.DeleteEvent mock is already set by Expect")
	}

	if mmDeleteEvent.defaultExpectation.paramPtrs == nil {
		mmDeleteEvent.defaultExpectation.paramPtrs = &ApiServiceMockDeleteEventParamPtrs{}
	}
	mmDeleteEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteEvent
}

// ExpectUserIDParam2 sets up expected param userID for ApiService.DeleteEvent
func (mmDeleteEvent *mApiServiceMockDeleteEvent) ExpectUserIDParam2(userID int64) *mApiServiceMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("ApiServiceMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &ApiServiceMockDeleteEventExpectation{}
	}

	if mmDeleteEvent.defaultExpectation.params != nil {
		mmDeleteEvent.mock.t.Fatalf("ApiServiceMock.DeleteEvent mock is already set by Expect")
	}

	if mmDeleteEvent.defaultExpectation.paramPtrs == nil {
		mmDeleteEvent.defaultExpectation.paramPtrs = &ApiServiceMockDeleteEventParamPtrs{}
	}
	mmDeleteEvent.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteEvent.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteEvent
}

// ExpectUrlTitleParam3 sets up expected param urlTitle for ApiService.DeleteEvent
func (mmDeleteEvent *mApiServiceMockDeleteEvent) ExpectUrlTitleParam3(urlTitle string) *mApiServiceMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("ApiServiceMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &ApiServiceMockDeleteEventExpectation{}
	}

	if mmDeleteEvent.defaultExpectation.params != nil {
		mmDeleteEvent.mock.t.Fatalf("ApiServiceMock.DeleteEvent mock is already set by Expect")
	}

	if mmDeleteEvent.defaultExpectation.paramPtrs == nil {
		mmDeleteEvent.defaultExpectation.paramPtrs = &ApiServiceMockDeleteEventParamPtrs{}
	}
	mmDeleteEvent.defaultExpectation.paramPtrs.urlTitle = &urlTitle
	mmDeleteEvent.defaultExpectation.expectationOrigins.originUrlTitle = minimock.CallerInfo(1)

	return mmDeleteEvent
}

// Inspect accepts an inspector function that has same arguments as the ApiService.DeleteEvent
func (mmDeleteEvent *mApiServiceMockDeleteEvent) Inspect(f func(ctx context.Context, userID int64, urlTitle string)) *mApiServiceMockDeleteEvent {
	if mmDeleteEvent.mock.inspectFuncDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.DeleteEvent")
	}

	mmDeleteEvent.mock.inspectFuncDeleteEvent = f

	return mmDeleteEvent
}

// Return sets up results that will be returned by ApiService.DeleteEvent
func (mmDeleteEvent *mApiServiceMockDeleteEvent) Return(err error) *ApiServiceMock {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("ApiServiceMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &ApiServiceMockDeleteEventExpectation{mock: mmDeleteEvent.mock}
	}
	mmDeleteEvent.defaultExpectation.results = &ApiServiceMockDeleteEventResults{err}
	mmDeleteEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteEvent.mock
}

// Set uses given function f to mock the ApiService.DeleteEvent method
func (mmDeleteEvent *mApiServiceMockDeleteEvent) Set(f func(ctx context.Context, userID int64, urlTitle string) (err error)) *ApiServiceMock {
	if mmDeleteEvent.defaultExpectation != nil {
		mmDeleteEvent.mock.t.Fatalf("Default expectation is already set for the ApiService.DeleteEvent method")
	}

	if len(mmDeleteEvent.expectations) > 0 {
		mmDeleteEvent.mock.t.Fatalf("Some expectations are already set for the ApiService.DeleteEvent method")
	}

	mmDeleteEvent.mock.funcDeleteEvent = f
	mmDeleteEvent.mock.funcDeleteEventOrigin = minimock.CallerInfo(1)
	return mmDeleteEvent.mock
}

// When sets expectation for the ApiService.DeleteEvent which will trigger the result defined by the following
// Then helper
func (mmDeleteEvent *mApiServiceMockDeleteEvent) When(ctx context.Context, userID int64, urlTitle string) *ApiServiceMockDeleteEventExpectation {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("ApiServiceMock.DeleteEvent mock is already set by Set")
	}

	expectation := &ApiServiceMockDeleteEventExpectation{
		mock:               mmDeleteEvent.mock,
		params:             &ApiServiceMockDeleteEventParams{ctx, userID, urlTitle},
		expectationOrigins: ApiServiceMockDeleteEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteEvent.expectations = append(mmDeleteEvent.expectations, expectation)
	return expectation
}

// Then sets up ApiService.DeleteEvent return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockDeleteEventExpectation) Then(err error) *ApiServiceMock {
	e.results = &ApiServiceMockDeleteEventResults{err}
	return e.mock
}

// Times sets number of times ApiService.DeleteEvent should be invoked
func (mmDeleteEvent *mApiServiceMockDeleteEvent) Times(n uint64) *mApiServiceMockDeleteEvent {
	if n == 0 {
		mmDeleteEvent.mock.t.Fatalf("Times of ApiServiceMock.DeleteEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEvent.expectedInvocations, n)
	mmDeleteEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteEvent
}

func (mmDeleteEvent *mApiServiceMockDeleteEvent) invocationsDone() bool {
	if len(mmDeleteEvent.expectations) == 0 && mmDeleteEvent.defaultExpectation == nil && mmDeleteEvent.mock.funcDeleteEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEvent.mock.afterDeleteEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEvent implements mm_service.ApiService
func (mmDeleteEvent *ApiServiceMock) DeleteEvent(ctx context.Context, userID int64, urlTitle string) (err error) {
	mm_atomic.AddUint64(&mmDeleteEvent.beforeDeleteEventCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEvent.afterDeleteEventCounter, 1)

	mmDeleteEvent.t.Helper()

	if mmDeleteEvent.inspectFuncDeleteEvent != nil {
		mmDeleteEvent.inspectFuncDeleteEvent(ctx, userID, urlTitle)
	}

	mm_params := ApiServiceMockDeleteEventParams{ctx, userID, urlTitle}

	// Record call args
	mmDeleteEvent.DeleteEventMock.mutex.Lock()
	mmDeleteEvent.DeleteEventMock.callArgs = append(mmDeleteEvent.DeleteEventMock.callArgs, &mm_params)
	mmDeleteEvent.DeleteEventMock.mutex.Unlock()

	for _, e := range mmDeleteEvent.DeleteEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEvent.DeleteEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEvent.DeleteEventMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEvent.DeleteEventMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEvent.DeleteEventMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockDeleteEventParams{ctx, userID, urlTitle}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEvent.t.Errorf("ApiServiceMock.DeleteEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEvent.DeleteEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteEvent.t.Errorf("ApiServiceMock.DeleteEvent got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEvent.DeleteEventMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.urlTitle != nil && !minimock.Equal(*mm_want_ptrs.urlTitle, mm_got.urlTitle) {
				mmDeleteEvent.t.Errorf("ApiServiceMock.DeleteEvent got unexpected parameter urlTitle, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEvent.DeleteEventMock.defaultExpectation.expectationOrigins.originUrlTitle, *mm_want_ptrs.urlTitle, mm_got.urlTitle, minimock.Diff(*mm_want_ptrs.urlTitle, mm_got.urlTitle))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEvent.t.Errorf("ApiServiceMock.DeleteEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteEvent.DeleteEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEvent.DeleteEventMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEvent.t.Fatal("No results are set for the ApiServiceMock.DeleteEvent")
		}
		return (*mm_results).err
	}
	if mmDeleteEvent.funcDeleteEvent != nil {
		return mmDeleteEvent.funcDeleteEvent(ctx, userID, urlTitle)
	}
	mmDeleteEvent.t.Fatalf("Unexpected call to ApiServiceMock.DeleteEvent. %v %v %v", ctx, userID, urlTitle)
	return
}

// DeleteEventAfterCounter returns a count of finished ApiServiceMock.DeleteEvent invocations
func (mmDeleteEvent *ApiServiceMock) DeleteEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEvent.afterDeleteEventCounter)
}

// DeleteEventBeforeCounter returns a count of ApiServiceMock.DeleteEvent invocations
func (mmDeleteEvent *ApiServiceMock) DeleteEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEvent.beforeDeleteEventCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.DeleteEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEvent *mApiServiceMockDeleteEvent) Calls() []*ApiServiceMockDeleteEventParams {
	mmDeleteEvent.mutex.RLock()

	argCopy := make([]*ApiServiceMockDeleteEventParams, len(mmDeleteEvent.callArgs))
	copy(argCopy, mmDeleteEvent.callArgs)

	mmDeleteEvent.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEventDone returns true if the count of the DeleteEvent invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockDeleteEventDone() bool {
	if m.DeleteEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEventMock.invocationsDone()
}

// MinimockDeleteEventInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockDeleteEventInspect() {
	for _, e := range m.DeleteEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.DeleteEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteEventCounter := mm_atomic.LoadUint64(&m.afterDeleteEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEventMock.defaultExpectation != nil && afterDeleteEventCounter < 1 {
		if m.DeleteEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.DeleteEvent at\n%s", m.DeleteEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.DeleteEvent at\n%s with params: %#v", m.DeleteEventMock.defaultExpectation.expectationOrigins.origin, *m.DeleteEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEvent != nil && afterDeleteEventCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.DeleteEvent at\n%s", m.funcDeleteEventOrigin)
	}

	if !m.DeleteEventMock.invocationsDone() && afterDeleteEventCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.DeleteEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEventMock.expectedInvocations), m.DeleteEventMock.expectedInvocationsOrigin, afterDeleteEventCounter)
	}
}

type mApiServiceMockEvent struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockEventExpectation
	expectations       []*ApiServiceMockEventExpectation

	callArgs []*ApiServiceMockEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockEventExpectation specifies expectation struct of the ApiService.Event
type ApiServiceMockEventExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockEventParams
	paramPtrs          *ApiServiceMockEventParamPtrs
	expectationOrigins ApiServiceMockEventExpectationOrigins
	results            *ApiServiceMockEventResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockEventParams contains parameters of the ApiService.Event
type ApiServiceMockEventParams struct {
	ctx      context.Context
	urlTitle string
}

// ApiServiceMockEventParamPtrs contains pointers to parameters of the ApiService.Event
type ApiServiceMockEventParamPtrs struct {
	ctx      *context.Context
	urlTitle *string
}

// ApiServiceMockEventResults contains results of the ApiService.Event
type ApiServiceMockEventResults struct {
	ep1 *models.Event
	err error
}

// ApiServiceMockEventOrigins contains origins of expectations of the ApiService.Event
type ApiServiceMockEventExpectationOrigins struct {
	origin         string
	originCtx      string
	originUrlTitle string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEvent *mApiServiceMockEvent) Optional() *mApiServiceMockEvent {
	mmEvent.optional = true
	return mmEvent
}

// Expect sets up expected params for ApiService.Event
func (mmEvent *mApiServiceMockEvent) Expect(ctx context.Context, urlTitle string) *mApiServiceMockEvent {
	if mmEvent.mock.funcEvent != nil {
		mmEvent.mock.t.Fatalf("ApiServiceMock.Event mock is already set by Set")
	}

	if mmEvent.defaultExpectation == nil {
		mmEvent.defaultExpectation = &ApiServiceMockEventExpectation{}
	}

	if mmEvent.defaultExpectation.paramPtrs != nil {
		mmEvent.mock.t.Fatalf("ApiServiceMock.Event mock is already set by ExpectParams functions")
	}

	mmEvent.defaultExpectation.params = &ApiServiceMockEventParams{ctx, urlTitle}
	mmEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEvent.expectations {
		if minimock.Equal(e.params, mmEvent.defaultExpectation.params) {
			mmEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEvent.defaultExpectation.params)
		}
	}

	return mmEvent
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.Event
func (mmEvent *mApiServiceMockEvent) ExpectCtxParam1(ctx context.Context) *mApiServiceMockEvent {
	if mmEvent.mock.funcEvent != nil {
		mmEvent.mock.t.Fatalf("ApiServiceMock.Event mock is already set by Set")
	}

	if mmEvent.defaultExpectation == nil {
		mmEvent.defaultExpectation = &ApiServiceMockEventExpectation{}
	}

	if mmEvent.defaultExpectation.params != nil {
		mmEvent.mock.t.Fatalf("ApiServiceMock.Event mock is already set by Expect")
	}

	if mmEvent.defaultExpectation.paramPtrs == nil {
		mmEvent.defaultExpectation.paramPtrs = &ApiServiceMockEventParamPtrs{}
	}
	mmEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEvent
}

// ExpectUrlTitleParam2 sets up expected param urlTitle for ApiService.Event
func (mmEvent *mApiServiceMockEvent) ExpectUrlTitleParam2(urlTitle string) *mApiServiceMockEvent {
	if mmEvent.mock.funcEvent != nil {
		mmEvent.mock.t.Fatalf("ApiServiceMock.Event mock is already set by Set")
	}

	if mmEvent.defaultExpectation == nil {
		mmEvent.defaultExpectation = &ApiServiceMockEventExpectation{}
	}

	if mmEvent.defaultExpectation.params != nil {
		mmEvent.mock.t.Fatalf("ApiServiceMock.Event mock is already set by Expect")
	}

	if mmEvent.defaultExpectation.paramPtrs == nil {
		mmEvent.defaultExpectation.paramPtrs = &ApiServiceMockEventParamPtrs{}
	}
	mmEvent.defaultExpectation.paramPtrs.urlTitle = &urlTitle
	mmEvent.defaultExpectation.expectationOrigins.originUrlTitle = minimock.CallerInfo(1)

	return mmEvent
}

// Inspect accepts an inspector function that has same arguments as the ApiService.Event
func (mmEvent *mApiServiceMockEvent) Inspect(f func(ctx context.Context, urlTitle string)) *mApiServiceMockEvent {
	if mmEvent.mock.inspectFuncEvent != nil {
		mmEvent.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.Event")
	}

	mmEvent.mock.inspectFuncEvent = f

	return mmEvent
}

// Return sets up results that will be returned by ApiService.Event
func (mmEvent *mApiServiceMockEvent) Return(ep1 *models.Event, err error) *ApiServiceMock {
	if mmEvent.mock.funcEvent != nil {
		mmEvent.mock.t.Fatalf("ApiServiceMock.Event mock is already set by Set")
	}

	if mmEvent.defaultExpectation == nil {
		mmEvent.defaultExpectation = &ApiServiceMockEventExpectation{mock: mmEvent.mock}
	}
	mmEvent.defaultExpectation.results = &ApiServiceMockEventResults{ep1, err}
	mmEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEvent.mock
}

// Set uses given function f to mock the ApiService.Event method
func (mmEvent *mApiServiceMockEvent) Set(f func(ctx context.Context, urlTitle string) (ep1 *models.Event, err error)) *ApiServiceMock {
	if mmEvent.defaultExpectation != nil {
		mmEvent.mock.t.Fatalf("Default expectation is already set for the ApiService.Event method")
	}

	if len(mmEvent.expectations) > 0 {
		mmEvent.mock.t.Fatalf("Some expectations are already set for the ApiService.Event method")
	}

	mmEvent.mock.funcEvent = f
	mmEvent.mock.funcEventOrigin = minimock.CallerInfo(1)
	return mmEvent.mock
}

// When sets expectation for the ApiService.Event which will trigger the result defined by the following
// Then helper
func (mmEvent *mApiServiceMockEvent) When(ctx context.Context, urlTitle string) *ApiServiceMockEventExpectation {
	if mmEvent.mock.funcEvent != nil {
		mmEvent.mock.t.Fatalf("ApiServiceMock.Event mock is already set by Set")
	}

	expectation := &ApiServiceMockEventExpectation{
		mock:               mmEvent.mock,
		params:             &ApiServiceMockEventParams{ctx, urlTitle},
		expectationOrigins: ApiServiceMockEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEvent.expectations = append(mmEvent.expectations, expectation)
	return expectation
}

// Then sets up ApiService.Event return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockEventExpectation) Then(ep1 *models.Event, err error) *ApiServiceMock {
	e.results = &ApiServiceMockEventResults{ep1, err}
	return e.mock
}

// Times sets number of times ApiService.Event should be invoked
func (mmEvent *mApiServiceMockEvent) Times(n uint64) *mApiServiceMockEvent {
	if n == 0 {
		mmEvent.mock.t.Fatalf("Times of ApiServiceMock.Event mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEvent.expectedInvocations, n)
	mmEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEvent
}

func (mmEvent *mApiServiceMockEvent) invocationsDone() bool {
	if len(mmEvent.expectations) == 0 && mmEvent.defaultExpectation == nil && mmEvent.mock.funcEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEvent.mock.afterEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Event implements mm_service.ApiService
func (mmEvent *ApiServiceMock) Event(ctx context.Context, urlTitle string) (ep1 *models.Event, err error) {
	mm_atomic.AddUint64(&mmEvent.beforeEventCounter, 1)
	defer mm_atomic.AddUint64(&mmEvent.afterEventCounter, 1)

	mmEvent.t.Helper()

	if mmEvent.inspectFuncEvent != nil {
		mmEvent.inspectFuncEvent(ctx, urlTitle)
	}

	mm_params := ApiServiceMockEventParams{ctx, urlTitle}

	// Record call args
	mmEvent.EventMock.mutex.Lock()
	mmEvent.EventMock.callArgs = append(mmEvent.EventMock.callArgs, &mm_params)
	mmEvent.EventMock.mutex.Unlock()

	for _, e := range mmEvent.EventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmEvent.EventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEvent.EventMock.defaultExpectation.Counter, 1)
		mm_want := mmEvent.EventMock.defaultExpectation.params
		mm_want_ptrs := mmEvent.EventMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockEventParams{ctx, urlTitle}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEvent.t.Errorf("ApiServiceMock.Event got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEvent.EventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.urlTitle != nil && !minimock.Equal(*mm_want_ptrs.urlTitle, mm_got.urlTitle) {
				mmEvent.t.Errorf("ApiServiceMock.Event got unexpected parameter urlTitle, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEvent.EventMock.defaultExpectation.expectationOrigins.originUrlTitle, *mm_want_ptrs.urlTitle, mm_got.urlTitle, minimock.Diff(*mm_want_ptrs.urlTitle, mm_got.urlTitle))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEvent.t.Errorf("ApiServiceMock.Event got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEvent.EventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEvent.EventMock.defaultExpectation.results
		if mm_results == nil {
			mmEvent.t.Fatal("No results are set for the ApiServiceMock.Event")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmEvent.funcEvent != nil {
		return mmEvent.funcEvent(ctx, urlTitle)
	}
	mmEvent.t.Fatalf("Unexpected call to ApiServiceMock.Event. %v %v", ctx, urlTitle)
	return
}

// EventAfterCounter returns a count of finished ApiServiceMock.Event invocations
func (mmEvent *ApiServiceMock) EventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEvent.afterEventCounter)
}

// EventBeforeCounter returns a count of ApiServiceMock.Event invocations
func (mmEvent *ApiServiceMock) EventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEvent.beforeEventCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.Event.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEvent *mApiServiceMockEvent) Calls() []*ApiServiceMockEventParams {
	mmEvent.mutex.RLock()

	argCopy := make([]*ApiServiceMockEventParams, len(mmEvent.callArgs))
	copy(argCopy, mmEvent.callArgs)

	mmEvent.mutex.RUnlock()

	return argCopy
}

// MinimockEventDone returns true if the count of the Event invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockEventDone() bool {
	if m.EventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EventMock.invocationsDone()
}

// MinimockEventInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockEventInspect() {
	for _, e := range m.EventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.Event at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEventCounter := mm_atomic.LoadUint64(&m.afterEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EventMock.defaultExpectation != nil && afterEventCounter < 1 {
		if m.EventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.Event at\n%s", m.EventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.Event at\n%s with params: %#v", m.EventMock.defaultExpectation.expectationOrigins.origin, *m.EventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEvent != nil && afterEventCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.Event at\n%s", m.funcEventOrigin)
	}

	if !m.EventMock.invocationsDone() && afterEventCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.Event at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EventMock.expectedInvocations), m.EventMock.expectedInvocationsOrigin, afterEventCounter)
	}
}

type mApiServiceMockEvents struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockEventsExpectation
	expectations       []*ApiServiceMockEventsExpectation

	callArgs []*ApiServiceMockEventsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockEventsExpectation specifies expectation struct of the ApiService.Events
type ApiServiceMockEventsExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockEventsParams
	paramPtrs          *ApiServiceMockEventsParamPtrs
	expectationOrigins ApiServiceMockEventsExpectationOrigins
	results            *ApiServiceMockEventsResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockEventsParams contains parameters of the ApiService.Events
type ApiServiceMockEventsParams struct {
	ctx  context.Context
	page int
}

// ApiServiceMockEventsParamPtrs contains pointers to parameters of the ApiService.Events
type ApiServiceMockEventsParamPtrs struct {
	ctx  *context.Context
	page *int
}

// ApiServiceMockEventsResults contains results of the ApiService.Events
type ApiServiceMockEventsResults struct {
	epa1 []*models.Event
	err  error
}

// ApiServiceMockEventsOrigins contains origins of expectations of the ApiService.Events
type ApiServiceMockEventsExpectationOrigins struct {
	origin     string
	originCtx  string
	originPage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEvents *mApiServiceMockEvents) Optional() *mApiServiceMockEvents {
	mmEvents.optional = true
	return mmEvents
}

// Expect sets up expected params for ApiService.Events
func (mmEvents *mApiServiceMockEvents) Expect(ctx context.Context, page int) *mApiServiceMockEvents {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("ApiServiceMock.Events mock is already set by Set")
	}

	if mmEvents.defaultExpectation == nil {
		mmEvents.defaultExpectation = &ApiServiceMockEventsExpectation{}
	}

	if mmEvents.defaultExpectation.paramPtrs != nil {
		mmEvents.mock.t.Fatalf("ApiServiceMock.Events mock is already set by ExpectParams functions")
	}

	mmEvents.defaultExpectation.params = &ApiServiceMockEventsParams{ctx, page}
	mmEvents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEvents.expectations {
		if minimock.Equal(e.params, mmEvents.defaultExpectation.params) {
			mmEvents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEvents.defaultExpectation.params)
		}
	}

	return mmEvents
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.Events
func (mmEvents *mApiServiceMockEvents) ExpectCtxParam1(ctx context.Context) *mApiServiceMockEvents {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("ApiServiceMock.Events mock is already set by Set")
	}

	if mmEvents.defaultExpectation == nil {
		mmEvents.defaultExpectation = &ApiServiceMockEventsExpectation{}
	}

	if mmEvents.defaultExpectation.params != nil {
		mmEvents.mock.t.Fatalf("ApiServiceMock.Events mock is already set by Expect")
	}

	if mmEvents.defaultExpectation.paramPtrs == nil {
		mmEvents.defaultExpectation.paramPtrs = &ApiServiceMockEventsParamPtrs{}
	}
	mmEvents.defaultExpectation.paramPtrs.ctx = &ctx
	mmEvents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEvents
}

// ExpectPageParam2 sets up expected param page for ApiService.Events
func (mmEvents *mApiServiceMockEvents) ExpectPageParam2(page int) *mApiServiceMockEvents {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("ApiServiceMock.Events mock is already set by Set")
	}

	if mmEvents.defaultExpectation == nil {
		mmEvents.defaultExpectation = &ApiServiceMockEventsExpectation{}
	}

	if mmEvents.defaultExpectation.params != nil {
		mmEvents.mock.t.Fatalf("ApiServiceMock.Events mock is already set by Expect")
	}

	if mmEvents.defaultExpectation.paramPtrs == nil {
		mmEvents.defaultExpectation.paramPtrs = &ApiServiceMockEventsParamPtrs{}
	}
	mmEvents.defaultExpectation.paramPtrs.page = &page
	mmEvents.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmEvents
}

// Inspect accepts an inspector function that has same arguments as the ApiService.Events
func (mmEvents *mApiServiceMockEvents) Inspect(f func(ctx context.Context, page int)) *mApiServiceMockEvents {
	if mmEvents.mock.inspectFuncEvents != nil {
		mmEvents.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.Events")
	}

	mmEvents.mock.inspectFuncEvents = f

	return mmEvents
}

// Return sets up results that will be returned by ApiService.Events
func (mmEvents *mApiServiceMockEvents) Return(epa1 []*models.Event, err error) *ApiServiceMock {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("ApiServiceMock.Events mock is already set by Set")
	}

	if mmEvents.defaultExpectation == nil {
		mmEvents.defaultExpectation = &ApiServiceMockEventsExpectation{mock: mmEvents.mock}
	}
	mmEvents.defaultExpectation.results = &ApiServiceMockEventsResults{epa1, err}
	mmEvents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEvents.mock
}

// Set uses given function f to mock the ApiService.Events method
func (mmEvents *mApiServiceMockEvents) Set(f func(ctx context.Context, page int) (epa1 []*models.Event, err error)) *ApiServiceMock {
	if mmEvents.defaultExpectation != nil {
		mmEvents.mock.t.Fatalf("Default expectation is already set for the ApiService.Events method")
	}

	if len(mmEvents.expectations) > 0 {
		mmEvents.mock.t.Fatalf("Some expectations are already set for the ApiService.Events method")
	}

	mmEvents.mock.funcEvents = f
	mmEvents.mock.funcEventsOrigin = minimock.CallerInfo(1)
	return mmEvents.mock
}

// When sets expectation for the ApiService.Events which will trigger the result defined by the following
// Then helper
func (mmEvents *mApiServiceMockEvents) When(ctx context.Context, page int) *ApiServiceMockEventsExpectation {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("ApiServiceMock.Events mock is already set by Set")
	}

	expectation := &ApiServiceMockEventsExpectation{
		mock:               mmEvents.mock,
		params:             &ApiServiceMockEventsParams{ctx, page},
		expectationOrigins: ApiServiceMockEventsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEvents.expectations = append(mmEvents.expectations, expectation)
	return expectation
}

// Then sets up ApiService.Events return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockEventsExpectation) Then(epa1 []*models.Event, err error) *ApiServiceMock {
	e.results = &ApiServiceMockEventsResults{epa1, err}
	return e.mock
}

// Times sets number of times ApiService.Events should be invoked
func (mmEvents *mApiServiceMockEvents) Times(n uint64) *mApiServiceMockEvents {
	if n == 0 {
		mmEvents.mock.t.Fatalf("Times of ApiServiceMock.Events mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEvents.expectedInvocations, n)
	mmEvents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEvents
}

func (mmEvents *mApiServiceMockEvents) invocationsDone() bool {
	if len(mmEvents.expectations) == 0 && mmEvents.defaultExpectation == nil && mmEvents.mock.funcEvents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEvents.mock.afterEventsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEvents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Events implements mm_service.ApiService
func (mmEvents *ApiServiceMock) Events(ctx context.Context, page int) (epa1 []*models.Event, err error) {
	mm_atomic.AddUint64(&mmEvents.beforeEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmEvents.afterEventsCounter, 1)

	mmEvents.t.Helper()

	if mmEvents.inspectFuncEvents != nil {
		mmEvents.inspectFuncEvents(ctx, page)
	}

	mm_params := ApiServiceMockEventsParams{ctx, page}

	// Record call args
	mmEvents.EventsMock.mutex.Lock()
	mmEvents.EventsMock.callArgs = append(mmEvents.EventsMock.callArgs, &mm_params)
	mmEvents.EventsMock.mutex.Unlock()

	for _, e := range mmEvents.EventsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.epa1, e.results.err
		}
	}

	if mmEvents.EventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEvents.EventsMock.defaultExpectation.Counter, 1)
		mm_want := mmEvents.EventsMock.defaultExpectation.params
		mm_want_ptrs := mmEvents.EventsMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockEventsParams{ctx, page}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEvents.t.Errorf("ApiServiceMock.Events got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEvents.EventsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmEvents.t.Errorf("ApiServiceMock.Events got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEvents.EventsMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEvents.t.Errorf("ApiServiceMock.Events got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEvents.EventsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEvents.EventsMock.defaultExpectation.results
		if mm_results == nil {
			mmEvents.t.Fatal("No results are set for the ApiServiceMock.Events")
		}
		return (*mm_results).epa1, (*mm_results).err
	}
	if mmEvents.funcEvents != nil {
		return mmEvents.funcEvents(ctx, page)
	}
	mmEvents.t.Fatalf("Unexpected call to ApiServiceMock.Events. %v %v", ctx, page)
	return
}

// EventsAfterCounter returns a count of finished ApiServiceMock.Events invocations
func (mmEvents *ApiServiceMock) EventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEvents.afterEventsCounter)
}

// EventsBeforeCounter returns a count of ApiServiceMock.Events invocations
func (mmEvents *ApiServiceMock) EventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEvents.beforeEventsCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.Events.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEvents *mApiServiceMockEvents) Calls() []*ApiServiceMockEventsParams {
	mmEvents.mutex.RLock()

	argCopy := make([]*ApiServiceMockEventsParams, len(mmEvents.callArgs))
	copy(argCopy, mmEvents.callArgs)

	mmEvents.mutex.RUnlock()

	return argCopy
}

// MinimockEventsDone returns true if the count of the Events invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockEventsDone() bool {
	if m.EventsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EventsMock.invocationsDone()
}

// MinimockEventsInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockEventsInspect() {
	for _, e := range m.EventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.Events at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEventsCounter := mm_atomic.LoadUint64(&m.afterEventsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EventsMock.defaultExpectation != nil && afterEventsCounter < 1 {
		if m.EventsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.Events at\n%s", m.EventsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.Events at\n%s with params: %#v", m.EventsMock.defaultExpectation.expectationOrigins.origin, *m.EventsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEvents != nil && afterEventsCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.Events at\n%s", m.funcEventsOrigin)
	}

	if !m.EventsMock.invocationsDone() && afterEventsCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.Events at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EventsMock.expectedInvocations), m.EventsMock.expectedInvocationsOrigin, afterEventsCounter)
	}
}

type mApiServiceMockLogin struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockLoginExpectation
	expectations       []*ApiServiceMockLoginExpectation

	callArgs []*ApiServiceMockLoginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockLoginExpectation specifies expectation struct of the ApiService.Login
type ApiServiceMockLoginExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockLoginParams
	paramPtrs          *ApiServiceMockLoginParamPtrs
	expectationOrigins ApiServiceMockLoginExpectationOrigins
	results            *ApiServiceMockLoginResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockLoginParams contains parameters of the ApiService.Login
type ApiServiceMockLoginParams struct {
	ctx  context.Context
	user *models.User
}

// ApiServiceMockLoginParamPtrs contains pointers to parameters of the ApiService.Login
type ApiServiceMockLoginParamPtrs struct {
	ctx  *context.Context
	user **models.User
}

// ApiServiceMockLoginResults contains results of the ApiService.Login
type ApiServiceMockLoginResults struct {
	s1  string
	err error
}

// ApiServiceMockLoginOrigins contains origins of expectations of the ApiService.Login
type ApiServiceMockLoginExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mApiServiceMockLogin) Optional() *mApiServiceMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for ApiService.Login
func (mmLogin *mApiServiceMockLogin) Expect(ctx context.Context, user *models.User) *mApiServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ApiServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &ApiServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.paramPtrs != nil {
		mmLogin.mock.t.Fatalf("ApiServiceMock.Login mock is already set by ExpectParams functions")
	}

	mmLogin.defaultExpectation.params = &ApiServiceMockLoginParams{ctx, user}
	mmLogin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.Login
func (mmLogin *mApiServiceMockLogin) ExpectCtxParam1(ctx context.Context) *mApiServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ApiServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &ApiServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("ApiServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &ApiServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.ctx = &ctx
	mmLogin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLogin
}

// ExpectUserParam2 sets up expected param user for ApiService.Login
func (mmLogin *mApiServiceMockLogin) ExpectUserParam2(user *models.User) *mApiServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ApiServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &ApiServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("ApiServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &ApiServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.user = &user
	mmLogin.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the ApiService.Login
func (mmLogin *mApiServiceMockLogin) Inspect(f func(ctx context.Context, user *models.User)) *mApiServiceMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by ApiService.Login
func (mmLogin *mApiServiceMockLogin) Return(s1 string, err error) *ApiServiceMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ApiServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &ApiServiceMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &ApiServiceMockLoginResults{s1, err}
	mmLogin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// Set uses given function f to mock the ApiService.Login method
func (mmLogin *mApiServiceMockLogin) Set(f func(ctx context.Context, user *models.User) (s1 string, err error)) *ApiServiceMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the ApiService.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the ApiService.Login method")
	}

	mmLogin.mock.funcLogin = f
	mmLogin.mock.funcLoginOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// When sets expectation for the ApiService.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mApiServiceMockLogin) When(ctx context.Context, user *models.User) *ApiServiceMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ApiServiceMock.Login mock is already set by Set")
	}

	expectation := &ApiServiceMockLoginExpectation{
		mock:               mmLogin.mock,
		params:             &ApiServiceMockLoginParams{ctx, user},
		expectationOrigins: ApiServiceMockLoginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up ApiService.Login return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockLoginExpectation) Then(s1 string, err error) *ApiServiceMock {
	e.results = &ApiServiceMockLoginResults{s1, err}
	return e.mock
}

// Times sets number of times ApiService.Login should be invoked
func (mmLogin *mApiServiceMockLogin) Times(n uint64) *mApiServiceMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of ApiServiceMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	mmLogin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogin
}

func (mmLogin *mApiServiceMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements mm_service.ApiService
func (mmLogin *ApiServiceMock) Login(ctx context.Context, user *models.User) (s1 string, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	mmLogin.t.Helper()

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, user)
	}

	mm_params := ApiServiceMockLoginParams{ctx, user}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_want_ptrs := mmLogin.LoginMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockLoginParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogin.t.Errorf("ApiServiceMock.Login got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmLogin.t.Errorf("ApiServiceMock.Login got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("ApiServiceMock.Login got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLogin.LoginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the ApiServiceMock.Login")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, user)
	}
	mmLogin.t.Fatalf("Unexpected call to ApiServiceMock.Login. %v %v", ctx, user)
	return
}

// LoginAfterCounter returns a count of finished ApiServiceMock.Login invocations
func (mmLogin *ApiServiceMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of ApiServiceMock.Login invocations
func (mmLogin *ApiServiceMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mApiServiceMockLogin) Calls() []*ApiServiceMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*ApiServiceMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.Login at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.Login at\n%s", m.LoginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.Login at\n%s with params: %#v", m.LoginMock.defaultExpectation.expectationOrigins.origin, *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.Login at\n%s", m.funcLoginOrigin)
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.Login at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), m.LoginMock.expectedInvocationsOrigin, afterLoginCounter)
	}
}

type mApiServiceMockRegisterUser struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockRegisterUserExpectation
	expectations       []*ApiServiceMockRegisterUserExpectation

	callArgs []*ApiServiceMockRegisterUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockRegisterUserExpectation specifies expectation struct of the ApiService.RegisterUser
type ApiServiceMockRegisterUserExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockRegisterUserParams
	paramPtrs          *ApiServiceMockRegisterUserParamPtrs
	expectationOrigins ApiServiceMockRegisterUserExpectationOrigins
	results            *ApiServiceMockRegisterUserResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockRegisterUserParams contains parameters of the ApiService.RegisterUser
type ApiServiceMockRegisterUserParams struct {
	ctx  context.Context
	user *models.User
}

// ApiServiceMockRegisterUserParamPtrs contains pointers to parameters of the ApiService.RegisterUser
type ApiServiceMockRegisterUserParamPtrs struct {
	ctx  *context.Context
	user **models.User
}

// ApiServiceMockRegisterUserResults contains results of the ApiService.RegisterUser
type ApiServiceMockRegisterUserResults struct {
	err error
}

// ApiServiceMockRegisterUserOrigins contains origins of expectations of the ApiService.RegisterUser
type ApiServiceMockRegisterUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterUser *mApiServiceMockRegisterUser) Optional() *mApiServiceMockRegisterUser {
	mmRegisterUser.optional = true
	return mmRegisterUser
}

// Expect sets up expected params for ApiService.RegisterUser
func (mmRegisterUser *mApiServiceMockRegisterUser) Expect(ctx context.Context, user *models.User) *mApiServiceMockRegisterUser {
	if mmRegisterUser.mock.funcRegisterUser != nil {
		mmRegisterUser.mock.t.Fatalf("ApiServiceMock.RegisterUser mock is already set by Set")
	}

	if mmRegisterUser.defaultExpectation == nil {
		mmRegisterUser.defaultExpectation = &ApiServiceMockRegisterUserExpectation{}
	}

	if mmRegisterUser.defaultExpectation.paramPtrs != nil {
		mmRegisterUser.mock.t.Fatalf("ApiServiceMock.RegisterUser mock is already set by ExpectParams functions")
	}

	mmRegisterUser.defaultExpectation.params = &ApiServiceMockRegisterUserParams{ctx, user}
	mmRegisterUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterUser.expectations {
		if minimock.Equal(e.params, mmRegisterUser.defaultExpectation.params) {
			mmRegisterUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterUser.defaultExpectation.params)
		}
	}

	return mmRegisterUser
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.RegisterUser
func (mmRegisterUser *mApiServiceMockRegisterUser) ExpectCtxParam1(ctx context.Context) *mApiServiceMockRegisterUser {
	if mmRegisterUser.mock.funcRegisterUser != nil {
		mmRegisterUser.mock.t.Fatalf("ApiServiceMock.RegisterUser mock is already set by Set")
	}

	if mmRegisterUser.defaultExpectation == nil {
		mmRegisterUser.defaultExpectation = &ApiServiceMockRegisterUserExpectation{}
	}

	if mmRegisterUser.defaultExpectation.params != nil {
		mmRegisterUser.mock.t.Fatalf("ApiServiceMock.RegisterUser mock is already set by Expect")
	}

	if mmRegisterUser.defaultExpectation.paramPtrs == nil {
		mmRegisterUser.defaultExpectation.paramPtrs = &ApiServiceMockRegisterUserParamPtrs{}
	}
	mmRegisterUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmRegisterUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRegisterUser
}

// ExpectUserParam2 sets up expected param user for ApiService.RegisterUser
func (mmRegisterUser *mApiServiceMockRegisterUser) ExpectUserParam2(user *models.User) *mApiServiceMockRegisterUser {
	if mmRegisterUser.mock.funcRegisterUser != nil {
		mmRegisterUser.mock.t.Fatalf("ApiServiceMock.RegisterUser mock is already set by Set")
	}

	if mmRegisterUser.defaultExpectation == nil {
		mmRegisterUser.defaultExpectation = &ApiServiceMockRegisterUserExpectation{}
	}

	if mmRegisterUser.defaultExpectation.params != nil {
		mmRegisterUser.mock.t.Fatalf("ApiServiceMock.RegisterUser mock is already set by Expect")
	}

	if mmRegisterUser.defaultExpectation.paramPtrs == nil {
		mmRegisterUser.defaultExpectation.paramPtrs = &ApiServiceMockRegisterUserParamPtrs{}
	}
	mmRegisterUser.defaultExpectation.paramPtrs.user = &user
	mmRegisterUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmRegisterUser
}

// Inspect accepts an inspector function that has same arguments as the ApiService.RegisterUser
func (mmRegisterUser *mApiServiceMockRegisterUser) Inspect(f func(ctx context.Context, user *models.User)) *mApiServiceMockRegisterUser {
	if mmRegisterUser.mock.inspectFuncRegisterUser != nil {
		mmRegisterUser.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.RegisterUser")
	}

	mmRegisterUser.mock.inspectFuncRegisterUser = f

	return mmRegisterUser
}

// Return sets up results that will be returned by ApiService.RegisterUser
func (mmRegisterUser *mApiServiceMockRegisterUser) Return(err error) *ApiServiceMock {
	if mmRegisterUser.mock.funcRegisterUser != nil {
		mmRegisterUser.mock.t.Fatalf("ApiServiceMock.RegisterUser mock is already set by Set")
	}

	if mmRegisterUser.defaultExpectation == nil {
		mmRegisterUser.defaultExpectation = &ApiServiceMockRegisterUserExpectation{mock: mmRegisterUser.mock}
	}
	mmRegisterUser.defaultExpectation.results = &ApiServiceMockRegisterUserResults{err}
	mmRegisterUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterUser.mock
}

// Set uses given function f to mock the ApiService.RegisterUser method
func (mmRegisterUser *mApiServiceMockRegisterUser) Set(f func(ctx context.Context, user *models.User) (err error)) *ApiServiceMock {
	if mmRegisterUser.defaultExpectation != nil {
		mmRegisterUser.mock.t.Fatalf("Default expectation is already set for the ApiService.RegisterUser method")
	}

	if len(mmRegisterUser.expectations) > 0 {
		mmRegisterUser.mock.t.Fatalf("Some expectations are already set for the ApiService.RegisterUser method")
	}

	mmRegisterUser.mock.funcRegisterUser = f
	mmRegisterUser.mock.funcRegisterUserOrigin = minimock.CallerInfo(1)
	return mmRegisterUser.mock
}

// When sets expectation for the ApiService.RegisterUser which will trigger the result defined by the following
// Then helper
func (mmRegisterUser *mApiServiceMockRegisterUser) When(ctx context.Context, user *models.User) *ApiServiceMockRegisterUserExpectation {
	if mmRegisterUser.mock.funcRegisterUser != nil {
		mmRegisterUser.mock.t.Fatalf("ApiServiceMock.RegisterUser mock is already set by Set")
	}

	expectation := &ApiServiceMockRegisterUserExpectation{
		mock:               mmRegisterUser.mock,
		params:             &ApiServiceMockRegisterUserParams{ctx, user},
		expectationOrigins: ApiServiceMockRegisterUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterUser.expectations = append(mmRegisterUser.expectations, expectation)
	return expectation
}

// Then sets up ApiService.RegisterUser return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockRegisterUserExpectation) Then(err error) *ApiServiceMock {
	e.results = &ApiServiceMockRegisterUserResults{err}
	return e.mock
}

// Times sets number of times ApiService.RegisterUser should be invoked
func (mmRegisterUser *mApiServiceMockRegisterUser) Times(n uint64) *mApiServiceMockRegisterUser {
	if n == 0 {
		mmRegisterUser.mock.t.Fatalf("Times of ApiServiceMock.RegisterUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterUser.expectedInvocations, n)
	mmRegisterUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterUser
}

func (mmRegisterUser *mApiServiceMockRegisterUser) invocationsDone() bool {
	if len(mmRegisterUser.expectations) == 0 && mmRegisterUser.defaultExpectation == nil && mmRegisterUser.mock.funcRegisterUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterUser.mock.afterRegisterUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterUser implements mm_service.ApiService
func (mmRegisterUser *ApiServiceMock) RegisterUser(ctx context.Context, user *models.User) (err error) {
	mm_atomic.AddUint64(&mmRegisterUser.beforeRegisterUserCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterUser.afterRegisterUserCounter, 1)

	mmRegisterUser.t.Helper()

	if mmRegisterUser.inspectFuncRegisterUser != nil {
		mmRegisterUser.inspectFuncRegisterUser(ctx, user)
	}

	mm_params := ApiServiceMockRegisterUserParams{ctx, user}

	// Record call args
	mmRegisterUser.RegisterUserMock.mutex.Lock()
	mmRegisterUser.RegisterUserMock.callArgs = append(mmRegisterUser.RegisterUserMock.callArgs, &mm_params)
	mmRegisterUser.RegisterUserMock.mutex.Unlock()

	for _, e := range mmRegisterUser.RegisterUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRegisterUser.RegisterUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterUser.RegisterUserMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterUser.RegisterUserMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterUser.RegisterUserMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockRegisterUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRegisterUser.t.Errorf("ApiServiceMock.RegisterUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterUser.RegisterUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmRegisterUser.t.Errorf("ApiServiceMock.RegisterUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterUser.RegisterUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterUser.t.Errorf("ApiServiceMock.RegisterUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterUser.RegisterUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterUser.RegisterUserMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterUser.t.Fatal("No results are set for the ApiServiceMock.RegisterUser")
		}
		return (*mm_results).err
	}
	if mmRegisterUser.funcRegisterUser != nil {
		return mmRegisterUser.funcRegisterUser(ctx, user)
	}
	mmRegisterUser.t.Fatalf("Unexpected call to ApiServiceMock.RegisterUser. %v %v", ctx, user)
	return
}

// RegisterUserAfterCounter returns a count of finished ApiServiceMock.RegisterUser invocations
func (mmRegisterUser *ApiServiceMock) RegisterUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterUser.afterRegisterUserCounter)
}

// RegisterUserBeforeCounter returns a count of ApiServiceMock.RegisterUser invocations
func (mmRegisterUser *ApiServiceMock) RegisterUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterUser.beforeRegisterUserCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.RegisterUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterUser *mApiServiceMockRegisterUser) Calls() []*ApiServiceMockRegisterUserParams {
	mmRegisterUser.mutex.RLock()

	argCopy := make([]*ApiServiceMockRegisterUserParams, len(mmRegisterUser.callArgs))
	copy(argCopy, mmRegisterUser.callArgs)

	mmRegisterUser.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterUserDone returns true if the count of the RegisterUser invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockRegisterUserDone() bool {
	if m.RegisterUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterUserMock.invocationsDone()
}

// MinimockRegisterUserInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockRegisterUserInspect() {
	for _, e := range m.RegisterUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.RegisterUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterUserCounter := mm_atomic.LoadUint64(&m.afterRegisterUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterUserMock.defaultExpectation != nil && afterRegisterUserCounter < 1 {
		if m.RegisterUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.RegisterUser at\n%s", m.RegisterUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.RegisterUser at\n%s with params: %#v", m.RegisterUserMock.defaultExpectation.expectationOrigins.origin, *m.RegisterUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterUser != nil && afterRegisterUserCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.RegisterUser at\n%s", m.funcRegisterUserOrigin)
	}

	if !m.RegisterUserMock.invocationsDone() && afterRegisterUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.RegisterUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterUserMock.expectedInvocations), m.RegisterUserMock.expectedInvocationsOrigin, afterRegisterUserCounter)
	}
}

type mApiServiceMockTicket struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockTicketExpectation
	expectations       []*ApiServiceMockTicketExpectation

	callArgs []*ApiServiceMockTicketParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockTicketExpectation specifies expectation struct of the ApiService.Ticket
type ApiServiceMockTicketExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockTicketParams
	paramPtrs          *ApiServiceMockTicketParamPtrs
	expectationOrigins ApiServiceMockTicketExpectationOrigins
	results            *ApiServiceMockTicketResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockTicketParams contains parameters of the ApiService.Ticket
type ApiServiceMockTicketParams struct {
	ctx      context.Context
	ticketID string
}

// ApiServiceMockTicketParamPtrs contains pointers to parameters of the ApiService.Ticket
type ApiServiceMockTicketParamPtrs struct {
	ctx      *context.Context
	ticketID *string
}

// ApiServiceMockTicketResults contains results of the ApiService.Ticket
type ApiServiceMockTicketResults struct {
	tp1 *models.Ticket
	err error
}

// ApiServiceMockTicketOrigins contains origins of expectations of the ApiService.Ticket
type ApiServiceMockTicketExpectationOrigins struct {
	origin         string
	originCtx      string
	originTicketID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTicket *mApiServiceMockTicket) Optional() *mApiServiceMockTicket {
	mmTicket.optional = true
	return mmTicket
}

// Expect sets up expected params for ApiService.Ticket
func (mmTicket *mApiServiceMockTicket) Expect(ctx context.Context, ticketID string) *mApiServiceMockTicket {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("ApiServiceMock.Ticket mock is already set by Set")
	}

	if mmTicket.defaultExpectation == nil {
		mmTicket.defaultExpectation = &ApiServiceMockTicketExpectation{}
	}

	if mmTicket.defaultExpectation.paramPtrs != nil {
		mmTicket.mock.t.Fatalf("ApiServiceMock.Ticket mock is already set by ExpectParams functions")
	}

	mmTicket.defaultExpectation.params = &ApiServiceMockTicketParams{ctx, ticketID}
	mmTicket.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTicket.expectations {
		if minimock.Equal(e.params, mmTicket.defaultExpectation.params) {
			mmTicket.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTicket.defaultExpectation.params)
		}
	}

	return mmTicket
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.Ticket
func (mmTicket *mApiServiceMockTicket) ExpectCtxParam1(ctx context.Context) *mApiServiceMockTicket {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("ApiServiceMock.Ticket mock is already set by Set")
	}

	if mmTicket.defaultExpectation == nil {
		mmTicket.defaultExpectation = &ApiServiceMockTicketExpectation{}
	}

	if mmTicket.defaultExpectation.params != nil {
		mmTicket.mock.t.Fatalf("ApiServiceMock.Ticket mock is already set by Expect")
	}

	if mmTicket.defaultExpectation.paramPtrs == nil {
		mmTicket.defaultExpectation.paramPtrs = &ApiServiceMockTicketParamPtrs{}
	}
	mmTicket.defaultExpectation.paramPtrs.ctx = &ctx
	mmTicket.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTicket
}

// ExpectTicketIDParam2 sets up expected param ticketID for ApiService.Ticket
func (mmTicket *mApiServiceMockTicket) ExpectTicketIDParam2(ticketID string) *mApiServiceMockTicket {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("ApiServiceMock.Ticket mock is already set by Set")
	}

	if mmTicket.defaultExpectation == nil {
		mmTicket.defaultExpectation = &ApiServiceMockTicketExpectation{}
	}

	if mmTicket.defaultExpectation.params != nil {
		mmTicket.mock.t.Fatalf("ApiServiceMock.Ticket mock is already set by Expect")
	}

	if mmTicket.defaultExpectation.paramPtrs == nil {
		mmTicket.defaultExpectation.paramPtrs = &ApiServiceMockTicketParamPtrs{}
	}
	mmTicket.defaultExpectation.paramPtrs.ticketID = &ticketID
	mmTicket.defaultExpectation.expectationOrigins.originTicketID = minimock.CallerInfo(1)

	return mmTicket
}

// Inspect accepts an inspector function that has same arguments as the ApiService.Ticket
func (mmTicket *mApiServiceMockTicket) Inspect(f func(ctx context.Context, ticketID string)) *mApiServiceMockTicket {
	if mmTicket.mock.inspectFuncTicket != nil {
		mmTicket.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.Ticket")
	}

	mmTicket.mock.inspectFuncTicket = f

	return mmTicket
}

// Return sets up results that will be returned by ApiService.Ticket
func (mmTicket *mApiServiceMockTicket) Return(tp1 *models.Ticket, err error) *ApiServiceMock {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("ApiServiceMock.Ticket mock is already set by Set")
	}

	if mmTicket.defaultExpectation == nil {
		mmTicket.defaultExpectation = &ApiServiceMockTicketExpectation{mock: mmTicket.mock}
	}
	mmTicket.defaultExpectation.results = &ApiServiceMockTicketResults{tp1, err}
	mmTicket.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTicket.mock
}

// Set uses given function f to mock the ApiService.Ticket method
func (mmTicket *mApiServiceMockTicket) Set(f func(ctx context.Context, ticketID string) (tp1 *models.Ticket, err error)) *ApiServiceMock {
	if mmTicket.defaultExpectation != nil {
		mmTicket.mock.t.Fatalf("Default expectation is already set for the ApiService.Ticket method")
	}

	if len(mmTicket.expectations) > 0 {
		mmTicket.mock.t.Fatalf("Some expectations are already set for the ApiService.Ticket method")
	}

	mmTicket.mock.funcTicket = f
	mmTicket.mock.funcTicketOrigin = minimock.CallerInfo(1)
	return mmTicket.mock
}

// When sets expectation for the ApiService.Ticket which will trigger the result defined by the following
// Then helper
func (mmTicket *mApiServiceMockTicket) When(ctx context.Context, ticketID string) *ApiServiceMockTicketExpectation {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("ApiServiceMock.Ticket mock is already set by Set")
	}

	expectation := &ApiServiceMockTicketExpectation{
		mock:               mmTicket.mock,
		params:             &ApiServiceMockTicketParams{ctx, ticketID},
		expectationOrigins: ApiServiceMockTicketExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTicket.expectations = append(mmTicket.expectations, expectation)
	return expectation
}

// Then sets up ApiService.Ticket return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockTicketExpectation) Then(tp1 *models.Ticket, err error) *ApiServiceMock {
	e.results = &ApiServiceMockTicketResults{tp1, err}
	return e.mock
}

// Times sets number of times ApiService.Ticket should be invoked
func (mmTicket *mApiServiceMockTicket) Times(n uint64) *mApiServiceMockTicket {
	if n == 0 {
		mmTicket.mock.t.Fatalf("Times of ApiServiceMock.Ticket mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTicket.expectedInvocations, n)
	mmTicket.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTicket
}

func (mmTicket *mApiServiceMockTicket) invocationsDone() bool {
	if len(mmTicket.expectations) == 0 && mmTicket.defaultExpectation == nil && mmTicket.mock.funcTicket == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTicket.mock.afterTicketCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTicket.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Ticket implements mm_service.ApiService
func (mmTicket *ApiServiceMock) Ticket(ctx context.Context, ticketID string) (tp1 *models.Ticket, err error) {
	mm_atomic.AddUint64(&mmTicket.beforeTicketCounter, 1)
	defer mm_atomic.AddUint64(&mmTicket.afterTicketCounter, 1)

	mmTicket.t.Helper()

	if mmTicket.inspectFuncTicket != nil {
		mmTicket.inspectFuncTicket(ctx, ticketID)
	}

	mm_params := ApiServiceMockTicketParams{ctx, ticketID}

	// Record call args
	mmTicket.TicketMock.mutex.Lock()
	mmTicket.TicketMock.callArgs = append(mmTicket.TicketMock.callArgs, &mm_params)
	mmTicket.TicketMock.mutex.Unlock()

	for _, e := range mmTicket.TicketMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmTicket.TicketMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTicket.TicketMock.defaultExpectation.Counter, 1)
		mm_want := mmTicket.TicketMock.defaultExpectation.params
		mm_want_ptrs := mmTicket.TicketMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockTicketParams{ctx, ticketID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTicket.t.Errorf("ApiServiceMock.Ticket got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTicket.TicketMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ticketID != nil && !minimock.Equal(*mm_want_ptrs.ticketID, mm_got.ticketID) {
				mmTicket.t.Errorf("ApiServiceMock.Ticket got unexpected parameter ticketID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTicket.TicketMock.defaultExpectation.expectationOrigins.originTicketID, *mm_want_ptrs.ticketID, mm_got.ticketID, minimock.Diff(*mm_want_ptrs.ticketID, mm_got.ticketID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTicket.t.Errorf("ApiServiceMock.Ticket got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTicket.TicketMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTicket.TicketMock.defaultExpectation.results
		if mm_results == nil {
			mmTicket.t.Fatal("No results are set for the ApiServiceMock.Ticket")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmTicket.funcTicket != nil {
		return mmTicket.funcTicket(ctx, ticketID)
	}
	mmTicket.t.Fatalf("Unexpected call to ApiServiceMock.Ticket. %v %v", ctx, ticketID)
	return
}

// TicketAfterCounter returns a count of finished ApiServiceMock.Ticket invocations
func (mmTicket *ApiServiceMock) TicketAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTicket.afterTicketCounter)
}

// TicketBeforeCounter returns a count of ApiServiceMock.Ticket invocations
func (mmTicket *ApiServiceMock) TicketBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTicket.beforeTicketCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.Ticket.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTicket *mApiServiceMockTicket) Calls() []*ApiServiceMockTicketParams {
	mmTicket.mutex.RLock()

	argCopy := make([]*ApiServiceMockTicketParams, len(mmTicket.callArgs))
	copy(argCopy, mmTicket.callArgs)

	mmTicket.mutex.RUnlock()

	return argCopy
}

// MinimockTicketDone returns true if the count of the Ticket invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockTicketDone() bool {
	if m.TicketMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TicketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TicketMock.invocationsDone()
}

// MinimockTicketInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockTicketInspect() {
	for _, e := range m.TicketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.Ticket at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTicketCounter := mm_atomic.LoadUint64(&m.afterTicketCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TicketMock.defaultExpectation != nil && afterTicketCounter < 1 {
		if m.TicketMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.Ticket at\n%s", m.TicketMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.Ticket at\n%s with params: %#v", m.TicketMock.defaultExpectation.expectationOrigins.origin, *m.TicketMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTicket != nil && afterTicketCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.Ticket at\n%s", m.funcTicketOrigin)
	}

	if !m.TicketMock.invocationsDone() && afterTicketCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.Ticket at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TicketMock.expectedInvocations), m.TicketMock.expectedInvocationsOrigin, afterTicketCounter)
	}
}

type mApiServiceMockUpdateEvent struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockUpdateEventExpectation
	expectations       []*ApiServiceMockUpdateEventExpectation

	callArgs []*ApiServiceMockUpdateEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockUpdateEventExpectation specifies expectation struct of the ApiService.UpdateEvent
type ApiServiceMockUpdateEventExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockUpdateEventParams
	paramPtrs          *ApiServiceMockUpdateEventParamPtrs
	expectationOrigins ApiServiceMockUpdateEventExpectationOrigins
	results            *ApiServiceMockUpdateEventResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockUpdateEventParams contains parameters of the ApiService.UpdateEvent
type ApiServiceMockUpdateEventParams struct {
	ctx    context.Context
	userID int64
	event  *models.Event
}

// ApiServiceMockUpdateEventParamPtrs contains pointers to parameters of the ApiService.UpdateEvent
type ApiServiceMockUpdateEventParamPtrs struct {
	ctx    *context.Context
	userID *int64
	event  **models.Event
}

// ApiServiceMockUpdateEventResults contains results of the ApiService.UpdateEvent
type ApiServiceMockUpdateEventResults struct {
	err error
}

// ApiServiceMockUpdateEventOrigins contains origins of expectations of the ApiService.UpdateEvent
type ApiServiceMockUpdateEventExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originEvent  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateEvent *mApiServiceMockUpdateEvent) Optional() *mApiServiceMockUpdateEvent {
	mmUpdateEvent.optional = true
	return mmUpdateEvent
}

// Expect sets up expected params for ApiService.UpdateEvent
func (mmUpdateEvent *mApiServiceMockUpdateEvent) Expect(ctx context.Context, userID int64, event *models.Event) *mApiServiceMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("ApiServiceMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &ApiServiceMockUpdateEventExpectation{}
	}

	if mmUpdateEvent.defaultExpectation.paramPtrs != nil {
		mmUpdateEvent.mock.t.Fatalf("ApiServiceMock.UpdateEvent mock is already set by ExpectParams functions")
	}

	mmUpdateEvent.defaultExpectation.params = &ApiServiceMockUpdateEventParams{ctx, userID, event}
	mmUpdateEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateEvent.expectations {
		if minimock.Equal(e.params, mmUpdateEvent.defaultExpectation.params) {
			mmUpdateEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateEvent.defaultExpectation.params)
		}
	}

	return mmUpdateEvent
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.UpdateEvent
func (mmUpdateEvent *mApiServiceMockUpdateEvent) ExpectCtxParam1(ctx context.Context) *mApiServiceMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("ApiServiceMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &ApiServiceMockUpdateEventExpectation{}
	}

	if mmUpdateEvent.defaultExpectation.params != nil {
		mmUpdateEvent.mock.t.Fatalf("ApiServiceMock.UpdateEvent mock is already set by Expect")
	}

	if mmUpdateEvent.defaultExpectation.paramPtrs == nil {
		mmUpdateEvent.defaultExpectation.paramPtrs = &ApiServiceMockUpdateEventParamPtrs{}
	}
	mmUpdateEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateEvent
}

// ExpectUserIDParam2 sets up expected param userID for ApiService.UpdateEvent
func (mmUpdateEvent *mApiServiceMockUpdateEvent) ExpectUserIDParam2(userID int64) *mApiServiceMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("ApiServiceMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &ApiServiceMockUpdateEventExpectation{}
	}

	if mmUpdateEvent.defaultExpectation.params != nil {
		mmUpdateEvent.mock.t.Fatalf("ApiServiceMock.UpdateEvent mock is already set by Expect")
	}

	if mmUpdateEvent.defaultExpectation.paramPtrs == nil {
		mmUpdateEvent.defaultExpectation.paramPtrs = &ApiServiceMockUpdateEventParamPtrs{}
	}
	mmUpdateEvent.defaultExpectation.paramPtrs.userID = &userID
	mmUpdateEvent.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUpdateEvent
}

// ExpectEventParam3 sets up expected param event for ApiService.UpdateEvent
func (mmUpdateEvent *mApiServiceMockUpdateEvent) ExpectEventParam3(event *models.Event) *mApiServiceMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("ApiServiceMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &ApiServiceMockUpdateEventExpectation{}
	}

	if mmUpdateEvent.defaultExpectation.params != nil {
		mmUpdateEvent.mock.t.Fatalf("ApiServiceMock.UpdateEvent mock is already set by Expect")
	}

	if mmUpdateEvent.defaultExpectation.paramPtrs == nil {
		mmUpdateEvent.defaultExpectation.paramPtrs = &ApiServiceMockUpdateEventParamPtrs{}
	}
	mmUpdateEvent.defaultExpectation.paramPtrs.event = &event
	mmUpdateEvent.defaultExpectation.expectationOrigins.originEvent = minimock.CallerInfo(1)

	return mmUpdateEvent
}

// Inspect accepts an inspector function that has same arguments as the ApiService.UpdateEvent
func (mmUpdateEvent *mApiServiceMockUpdateEvent) Inspect(f func(ctx context.Context, userID int64, event *models.Event)) *mApiServiceMockUpdateEvent {
	if mmUpdateEvent.mock.inspectFuncUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.UpdateEvent")
	}

	mmUpdateEvent.mock.inspectFuncUpdateEvent = f

	return mmUpdateEvent
}

// Return sets up results that will be returned by ApiService.UpdateEvent
func (mmUpdateEvent *mApiServiceMockUpdateEvent) Return(err error) *ApiServiceMock {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("ApiServiceMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &ApiServiceMockUpdateEventExpectation{mock: mmUpdateEvent.mock}
	}
	mmUpdateEvent.defaultExpectation.results = &ApiServiceMockUpdateEventResults{err}
	mmUpdateEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateEvent.mock
}

// Set uses given function f to mock the ApiService.UpdateEvent method
func (mmUpdateEvent *mApiServiceMockUpdateEvent) Set(f func(ctx context.Context, userID int64, event *models.Event) (err error)) *ApiServiceMock {
	if mmUpdateEvent.defaultExpectation != nil {
		mmUpdateEvent.mock.t.Fatalf("Default expectation is already set for the ApiService.UpdateEvent method")
	}

	if len(mmUpdateEvent.expectations) > 0 {
		mmUpdateEvent.mock.t.Fatalf("Some expectations are already set for the ApiService.UpdateEvent method")
	}

	mmUpdateEvent.mock.funcUpdateEvent = f
	mmUpdateEvent.mock.funcUpdateEventOrigin = minimock.CallerInfo(1)
	return mmUpdateEvent.mock
}

// When sets expectation for the ApiService.UpdateEvent which will trigger the result defined by the following
// Then helper
func (mmUpdateEvent *mApiServiceMockUpdateEvent) When(ctx context.Context, userID int64, event *models.Event) *ApiServiceMockUpdateEventExpectation {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("ApiServiceMock.UpdateEvent mock is already set by Set")
	}

	expectation := &ApiServiceMockUpdateEventExpectation{
		mock:               mmUpdateEvent.mock,
		params:             &ApiServiceMockUpdateEventParams{ctx, userID, event},
		expectationOrigins: ApiServiceMockUpdateEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateEvent.expectations = append(mmUpdateEvent.expectations, expectation)
	return expectation
}

// Then sets up ApiService.UpdateEvent return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockUpdateEventExpectation) Then(err error) *ApiServiceMock {
	e.results = &ApiServiceMockUpdateEventResults{err}
	return e.mock
}

// Times sets number of times ApiService.UpdateEvent should be invoked
func (mmUpdateEvent *mApiServiceMockUpdateEvent) Times(n uint64) *mApiServiceMockUpdateEvent {
	if n == 0 {
		mmUpdateEvent.mock.t.Fatalf("Times of ApiServiceMock.UpdateEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateEvent.expectedInvocations, n)
	mmUpdateEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateEvent
}

func (mmUpdateEvent *mApiServiceMockUpdateEvent) invocationsDone() bool {
	if len(mmUpdateEvent.expectations) == 0 && mmUpdateEvent.defaultExpectation == nil && mmUpdateEvent.mock.funcUpdateEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateEvent.mock.afterUpdateEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateEvent implements mm_service.ApiService
func (mmUpdateEvent *ApiServiceMock) UpdateEvent(ctx context.Context, userID int64, event *models.Event) (err error) {
	mm_atomic.AddUint64(&mmUpdateEvent.beforeUpdateEventCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateEvent.afterUpdateEventCounter, 1)

	mmUpdateEvent.t.Helper()

	if mmUpdateEvent.inspectFuncUpdateEvent != nil {
		mmUpdateEvent.inspectFuncUpdateEvent(ctx, userID, event)
	}

	mm_params := ApiServiceMockUpdateEventParams{ctx, userID, event}

	// Record call args
	mmUpdateEvent.UpdateEventMock.mutex.Lock()
	mmUpdateEvent.UpdateEventMock.callArgs = append(mmUpdateEvent.UpdateEventMock.callArgs, &mm_params)
	mmUpdateEvent.UpdateEventMock.mutex.Unlock()

	for _, e := range mmUpdateEvent.UpdateEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateEvent.UpdateEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateEvent.UpdateEventMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateEvent.UpdateEventMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateEvent.UpdateEventMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockUpdateEventParams{ctx, userID, event}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateEvent.t.Errorf("ApiServiceMock.UpdateEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEvent.UpdateEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUpdateEvent.t.Errorf("ApiServiceMock.UpdateEvent got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEvent.UpdateEventMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.event != nil && !minimock.Equal(*mm_want_ptrs.event, mm_got.event) {
				mmUpdateEvent.t.Errorf("ApiServiceMock.UpdateEvent got unexpected parameter event, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEvent.UpdateEventMock.defaultExpectation.expectationOrigins.originEvent, *mm_want_ptrs.event, mm_got.event, minimock.Diff(*mm_want_ptrs.event, mm_got.event))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateEvent.t.Errorf("ApiServiceMock.UpdateEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateEvent.UpdateEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateEvent.UpdateEventMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateEvent.t.Fatal("No results are set for the ApiServiceMock.UpdateEvent")
		}
		return (*mm_results).err
	}
	if mmUpdateEvent.funcUpdateEvent != nil {
		return mmUpdateEvent.funcUpdateEvent(ctx, userID, event)
	}
	mmUpdateEvent.t.Fatalf("Unexpected call to ApiServiceMock.UpdateEvent. %v %v %v", ctx, userID, event)
	return
}

// UpdateEventAfterCounter returns a count of finished ApiServiceMock.UpdateEvent invocations
func (mmUpdateEvent *ApiServiceMock) UpdateEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEvent.afterUpdateEventCounter)
}

// UpdateEventBeforeCounter returns a count of ApiServiceMock.UpdateEvent invocations
func (mmUpdateEvent *ApiServiceMock) UpdateEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEvent.beforeUpdateEventCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.UpdateEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateEvent *mApiServiceMockUpdateEvent) Calls() []*ApiServiceMockUpdateEventParams {
	mmUpdateEvent.mutex.RLock()

	argCopy := make([]*ApiServiceMockUpdateEventParams, len(mmUpdateEvent.callArgs))
	copy(argCopy, mmUpdateEvent.callArgs)

	mmUpdateEvent.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateEventDone returns true if the count of the UpdateEvent invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockUpdateEventDone() bool {
	if m.UpdateEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateEventMock.invocationsDone()
}

// MinimockUpdateEventInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockUpdateEventInspect() {
	for _, e := range m.UpdateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.UpdateEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateEventCounter := mm_atomic.LoadUint64(&m.afterUpdateEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateEventMock.defaultExpectation != nil && afterUpdateEventCounter < 1 {
		if m.UpdateEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.UpdateEvent at\n%s", m.UpdateEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.UpdateEvent at\n%s with params: %#v", m.UpdateEventMock.defaultExpectation.expectationOrigins.origin, *m.UpdateEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateEvent != nil && afterUpdateEventCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.UpdateEvent at\n%s", m.funcUpdateEventOrigin)
	}

	if !m.UpdateEventMock.invocationsDone() && afterUpdateEventCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.UpdateEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateEventMock.expectedInvocations), m.UpdateEventMock.expectedInvocationsOrigin, afterUpdateEventCounter)
	}
}

type mApiServiceMockUpdateUser struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockUpdateUserExpectation
	expectations       []*ApiServiceMockUpdateUserExpectation

	callArgs []*ApiServiceMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockUpdateUserExpectation specifies expectation struct of the ApiService.UpdateUser
type ApiServiceMockUpdateUserExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockUpdateUserParams
	paramPtrs          *ApiServiceMockUpdateUserParamPtrs
	expectationOrigins ApiServiceMockUpdateUserExpectationOrigins
	results            *ApiServiceMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockUpdateUserParams contains parameters of the ApiService.UpdateUser
type ApiServiceMockUpdateUserParams struct {
	ctx  context.Context
	user *models.User
}

// ApiServiceMockUpdateUserParamPtrs contains pointers to parameters of the ApiService.UpdateUser
type ApiServiceMockUpdateUserParamPtrs struct {
	ctx  *context.Context
	user **models.User
}

// ApiServiceMockUpdateUserResults contains results of the ApiService.UpdateUser
type ApiServiceMockUpdateUserResults struct {
	err error
}

// ApiServiceMockUpdateUserOrigins contains origins of expectations of the ApiService.UpdateUser
type ApiServiceMockUpdateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mApiServiceMockUpdateUser) Optional() *mApiServiceMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for ApiService.UpdateUser
func (mmUpdateUser *mApiServiceMockUpdateUser) Expect(ctx context.Context, user *models.User) *mApiServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("ApiServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &ApiServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("ApiServiceMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &ApiServiceMockUpdateUserParams{ctx, user}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.UpdateUser
func (mmUpdateUser *mApiServiceMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mApiServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("ApiServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &ApiServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("ApiServiceMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &ApiServiceMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectUserParam2 sets up expected param user for ApiService.UpdateUser
func (mmUpdateUser *mApiServiceMockUpdateUser) ExpectUserParam2(user *models.User) *mApiServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("ApiServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &ApiServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("ApiServiceMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &ApiServiceMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.user = &user
	mmUpdateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the ApiService.UpdateUser
func (mmUpdateUser *mApiServiceMockUpdateUser) Inspect(f func(ctx context.Context, user *models.User)) *mApiServiceMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by ApiService.UpdateUser
func (mmUpdateUser *mApiServiceMockUpdateUser) Return(err error) *ApiServiceMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("ApiServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &ApiServiceMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &ApiServiceMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the ApiService.UpdateUser method
func (mmUpdateUser *mApiServiceMockUpdateUser) Set(f func(ctx context.Context, user *models.User) (err error)) *ApiServiceMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the ApiService.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the ApiService.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the ApiService.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mApiServiceMockUpdateUser) When(ctx context.Context, user *models.User) *ApiServiceMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("ApiServiceMock.UpdateUser mock is already set by Set")
	}

	expectation := &ApiServiceMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &ApiServiceMockUpdateUserParams{ctx, user},
		expectationOrigins: ApiServiceMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up ApiService.UpdateUser return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockUpdateUserExpectation) Then(err error) *ApiServiceMock {
	e.results = &ApiServiceMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times ApiService.UpdateUser should be invoked
func (mmUpdateUser *mApiServiceMockUpdateUser) Times(n uint64) *mApiServiceMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of ApiServiceMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mApiServiceMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_service.ApiService
func (mmUpdateUser *ApiServiceMock) UpdateUser(ctx context.Context, user *models.User) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, user)
	}

	mm_params := ApiServiceMockUpdateUserParams{ctx, user}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockUpdateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("ApiServiceMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmUpdateUser.t.Errorf("ApiServiceMock.UpdateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("ApiServiceMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the ApiServiceMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, user)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to ApiServiceMock.UpdateUser. %v %v", ctx, user)
	return
}

// UpdateUserAfterCounter returns a count of finished ApiServiceMock.UpdateUser invocations
func (mmUpdateUser *ApiServiceMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of ApiServiceMock.UpdateUser invocations
func (mmUpdateUser *ApiServiceMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mApiServiceMockUpdateUser) Calls() []*ApiServiceMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*ApiServiceMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

type mApiServiceMockUser struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockUserExpectation
	expectations       []*ApiServiceMockUserExpectation

	callArgs []*ApiServiceMockUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockUserExpectation specifies expectation struct of the ApiService.User
type ApiServiceMockUserExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockUserParams
	paramPtrs          *ApiServiceMockUserParamPtrs
	expectationOrigins ApiServiceMockUserExpectationOrigins
	results            *ApiServiceMockUserResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockUserParams contains parameters of the ApiService.User
type ApiServiceMockUserParams struct {
	ctx       context.Context
	userEmail string
}

// ApiServiceMockUserParamPtrs contains pointers to parameters of the ApiService.User
type ApiServiceMockUserParamPtrs struct {
	ctx       *context.Context
	userEmail *string
}

// ApiServiceMockUserResults contains results of the ApiService.User
type ApiServiceMockUserResults struct {
	up1 *models.User
	err error
}

// ApiServiceMockUserOrigins contains origins of expectations of the ApiService.User
type ApiServiceMockUserExpectationOrigins struct {
	origin          string
	originCtx       string
	originUserEmail string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUser *mApiServiceMockUser) Optional() *mApiServiceMockUser {
	mmUser.optional = true
	return mmUser
}

// Expect sets up expected params for ApiService.User
func (mmUser *mApiServiceMockUser) Expect(ctx context.Context, userEmail string) *mApiServiceMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("ApiServiceMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &ApiServiceMockUserExpectation{}
	}

	if mmUser.defaultExpectation.paramPtrs != nil {
		mmUser.mock.t.Fatalf("ApiServiceMock.User mock is already set by ExpectParams functions")
	}

	mmUser.defaultExpectation.params = &ApiServiceMockUserParams{ctx, userEmail}
	mmUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUser.expectations {
		if minimock.Equal(e.params, mmUser.defaultExpectation.params) {
			mmUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUser.defaultExpectation.params)
		}
	}

	return mmUser
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.User
func (mmUser *mApiServiceMockUser) ExpectCtxParam1(ctx context.Context) *mApiServiceMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("ApiServiceMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &ApiServiceMockUserExpectation{}
	}

	if mmUser.defaultExpectation.params != nil {
		mmUser.mock.t.Fatalf("ApiServiceMock.User mock is already set by Expect")
	}

	if mmUser.defaultExpectation.paramPtrs == nil {
		mmUser.defaultExpectation.paramPtrs = &ApiServiceMockUserParamPtrs{}
	}
	mmUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUser
}

// ExpectUserEmailParam2 sets up expected param userEmail for ApiService.User
func (mmUser *mApiServiceMockUser) ExpectUserEmailParam2(userEmail string) *mApiServiceMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("ApiServiceMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &ApiServiceMockUserExpectation{}
	}

	if mmUser.defaultExpectation.params != nil {
		mmUser.mock.t.Fatalf("ApiServiceMock.User mock is already set by Expect")
	}

	if mmUser.defaultExpectation.paramPtrs == nil {
		mmUser.defaultExpectation.paramPtrs = &ApiServiceMockUserParamPtrs{}
	}
	mmUser.defaultExpectation.paramPtrs.userEmail = &userEmail
	mmUser.defaultExpectation.expectationOrigins.originUserEmail = minimock.CallerInfo(1)

	return mmUser
}

// Inspect accepts an inspector function that has same arguments as the ApiService.User
func (mmUser *mApiServiceMockUser) Inspect(f func(ctx context.Context, userEmail string)) *mApiServiceMockUser {
	if mmUser.mock.inspectFuncUser != nil {
		mmUser.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.User")
	}

	mmUser.mock.inspectFuncUser = f

	return mmUser
}

// Return sets up results that will be returned by ApiService.User
func (mmUser *mApiServiceMockUser) Return(up1 *models.User, err error) *ApiServiceMock {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("ApiServiceMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &ApiServiceMockUserExpectation{mock: mmUser.mock}
	}
	mmUser.defaultExpectation.results = &ApiServiceMockUserResults{up1, err}
	mmUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUser.mock
}

// Set uses given function f to mock the ApiService.User method
func (mmUser *mApiServiceMockUser) Set(f func(ctx context.Context, userEmail string) (up1 *models.User, err error)) *ApiServiceMock {
	if mmUser.defaultExpectation != nil {
		mmUser.mock.t.Fatalf("Default expectation is already set for the ApiService.User method")
	}

	if len(mmUser.expectations) > 0 {
		mmUser.mock.t.Fatalf("Some expectations are already set for the ApiService.User method")
	}

	mmUser.mock.funcUser = f
	mmUser.mock.funcUserOrigin = minimock.CallerInfo(1)
	return mmUser.mock
}

// When sets expectation for the ApiService.User which will trigger the result defined by the following
// Then helper
func (mmUser *mApiServiceMockUser) When(ctx context.Context, userEmail string) *ApiServiceMockUserExpectation {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("ApiServiceMock.User mock is already set by Set")
	}

	expectation := &ApiServiceMockUserExpectation{
		mock:               mmUser.mock,
		params:             &ApiServiceMockUserParams{ctx, userEmail},
		expectationOrigins: ApiServiceMockUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUser.expectations = append(mmUser.expectations, expectation)
	return expectation
}

// Then sets up ApiService.User return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockUserExpectation) Then(up1 *models.User, err error) *ApiServiceMock {
	e.results = &ApiServiceMockUserResults{up1, err}
	return e.mock
}

// Times sets number of times ApiService.User should be invoked
func (mmUser *mApiServiceMockUser) Times(n uint64) *mApiServiceMockUser {
	if n == 0 {
		mmUser.mock.t.Fatalf("Times of ApiServiceMock.User mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUser.expectedInvocations, n)
	mmUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUser
}

func (mmUser *mApiServiceMockUser) invocationsDone() bool {
	if len(mmUser.expectations) == 0 && mmUser.defaultExpectation == nil && mmUser.mock.funcUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUser.mock.afterUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// User implements mm_service.ApiService
func (mmUser *ApiServiceMock) User(ctx context.Context, userEmail string) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmUser.beforeUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUser.afterUserCounter, 1)

	mmUser.t.Helper()

	if mmUser.inspectFuncUser != nil {
		mmUser.inspectFuncUser(ctx, userEmail)
	}

	mm_params := ApiServiceMockUserParams{ctx, userEmail}

	// Record call args
	mmUser.UserMock.mutex.Lock()
	mmUser.UserMock.callArgs = append(mmUser.UserMock.callArgs, &mm_params)
	mmUser.UserMock.mutex.Unlock()

	for _, e := range mmUser.UserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUser.UserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUser.UserMock.defaultExpectation.Counter, 1)
		mm_want := mmUser.UserMock.defaultExpectation.params
		mm_want_ptrs := mmUser.UserMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockUserParams{ctx, userEmail}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUser.t.Errorf("ApiServiceMock.User got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUser.UserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userEmail != nil && !minimock.Equal(*mm_want_ptrs.userEmail, mm_got.userEmail) {
				mmUser.t.Errorf("ApiServiceMock.User got unexpected parameter userEmail, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUser.UserMock.defaultExpectation.expectationOrigins.originUserEmail, *mm_want_ptrs.userEmail, mm_got.userEmail, minimock.Diff(*mm_want_ptrs.userEmail, mm_got.userEmail))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUser.t.Errorf("ApiServiceMock.User got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUser.UserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUser.UserMock.defaultExpectation.results
		if mm_results == nil {
			mmUser.t.Fatal("No results are set for the ApiServiceMock.User")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUser.funcUser != nil {
		return mmUser.funcUser(ctx, userEmail)
	}
	mmUser.t.Fatalf("Unexpected call to ApiServiceMock.User. %v %v", ctx, userEmail)
	return
}

// UserAfterCounter returns a count of finished ApiServiceMock.User invocations
func (mmUser *ApiServiceMock) UserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.afterUserCounter)
}

// UserBeforeCounter returns a count of ApiServiceMock.User invocations
func (mmUser *ApiServiceMock) UserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.beforeUserCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.User.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUser *mApiServiceMockUser) Calls() []*ApiServiceMockUserParams {
	mmUser.mutex.RLock()

	argCopy := make([]*ApiServiceMockUserParams, len(mmUser.callArgs))
	copy(argCopy, mmUser.callArgs)

	mmUser.mutex.RUnlock()

	return argCopy
}

// MinimockUserDone returns true if the count of the User invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockUserDone() bool {
	if m.UserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserMock.invocationsDone()
}

// MinimockUserInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockUserInspect() {
	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.User at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserCounter := mm_atomic.LoadUint64(&m.afterUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserMock.defaultExpectation != nil && afterUserCounter < 1 {
		if m.UserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.User at\n%s", m.UserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.User at\n%s with params: %#v", m.UserMock.defaultExpectation.expectationOrigins.origin, *m.UserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUser != nil && afterUserCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.User at\n%s", m.funcUserOrigin)
	}

	if !m.UserMock.invocationsDone() && afterUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.User at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserMock.expectedInvocations), m.UserMock.expectedInvocationsOrigin, afterUserCounter)
	}
}

type mApiServiceMockUserEvents struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockUserEventsExpectation
	expectations       []*ApiServiceMockUserEventsExpectation

	callArgs []*ApiServiceMockUserEventsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockUserEventsExpectation specifies expectation struct of the ApiService.UserEvents
type ApiServiceMockUserEventsExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockUserEventsParams
	paramPtrs          *ApiServiceMockUserEventsParamPtrs
	expectationOrigins ApiServiceMockUserEventsExpectationOrigins
	results            *ApiServiceMockUserEventsResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockUserEventsParams contains parameters of the ApiService.UserEvents
type ApiServiceMockUserEventsParams struct {
	ctx    context.Context
	userID int64
}

// ApiServiceMockUserEventsParamPtrs contains pointers to parameters of the ApiService.UserEvents
type ApiServiceMockUserEventsParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// ApiServiceMockUserEventsResults contains results of the ApiService.UserEvents
type ApiServiceMockUserEventsResults struct {
	epa1 []*models.Event
	err  error
}

// ApiServiceMockUserEventsOrigins contains origins of expectations of the ApiService.UserEvents
type ApiServiceMockUserEventsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserEvents *mApiServiceMockUserEvents) Optional() *mApiServiceMockUserEvents {
	mmUserEvents.optional = true
	return mmUserEvents
}

// Expect sets up expected params for ApiService.UserEvents
func (mmUserEvents *mApiServiceMockUserEvents) Expect(ctx context.Context, userID int64) *mApiServiceMockUserEvents {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("ApiServiceMock.UserEvents mock is already set by Set")
	}

	if mmUserEvents.defaultExpectation == nil {
		mmUserEvents.defaultExpectation = &ApiServiceMockUserEventsExpectation{}
	}

	if mmUserEvents.defaultExpectation.paramPtrs != nil {
		mmUserEvents.mock.t.Fatalf("ApiServiceMock.UserEvents mock is already set by ExpectParams functions")
	}

	mmUserEvents.defaultExpectation.params = &ApiServiceMockUserEventsParams{ctx, userID}
	mmUserEvents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserEvents.expectations {
		if minimock.Equal(e.params, mmUserEvents.defaultExpectation.params) {
			mmUserEvents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserEvents.defaultExpectation.params)
		}
	}

	return mmUserEvents
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.UserEvents
func (mmUserEvents *mApiServiceMockUserEvents) ExpectCtxParam1(ctx context.Context) *mApiServiceMockUserEvents {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("ApiServiceMock.UserEvents mock is already set by Set")
	}

	if mmUserEvents.defaultExpectation == nil {
		mmUserEvents.defaultExpectation = &ApiServiceMockUserEventsExpectation{}
	}

	if mmUserEvents.defaultExpectation.params != nil {
		mmUserEvents.mock.t.Fatalf("ApiServiceMock.UserEvents mock is already set by Expect")
	}

	if mmUserEvents.defaultExpectation.paramPtrs == nil {
		mmUserEvents.defaultExpectation.paramPtrs = &ApiServiceMockUserEventsParamPtrs{}
	}
	mmUserEvents.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserEvents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserEvents
}

// ExpectUserIDParam2 sets up expected param userID for ApiService.UserEvents
func (mmUserEvents *mApiServiceMockUserEvents) ExpectUserIDParam2(userID int64) *mApiServiceMockUserEvents {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("ApiServiceMock.UserEvents mock is already set by Set")
	}

	if mmUserEvents.defaultExpectation == nil {
		mmUserEvents.defaultExpectation = &ApiServiceMockUserEventsExpectation{}
	}

	if mmUserEvents.defaultExpectation.params != nil {
		mmUserEvents.mock.t.Fatalf("ApiServiceMock.UserEvents mock is already set by Expect")
	}

	if mmUserEvents.defaultExpectation.paramPtrs == nil {
		mmUserEvents.defaultExpectation.paramPtrs = &ApiServiceMockUserEventsParamPtrs{}
	}
	mmUserEvents.defaultExpectation.paramPtrs.userID = &userID
	mmUserEvents.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUserEvents
}

// Inspect accepts an inspector function that has same arguments as the ApiService.UserEvents
func (mmUserEvents *mApiServiceMockUserEvents) Inspect(f func(ctx context.Context, userID int64)) *mApiServiceMockUserEvents {
	if mmUserEvents.mock.inspectFuncUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.UserEvents")
	}

	mmUserEvents.mock.inspectFuncUserEvents = f

	return mmUserEvents
}

// Return sets up results that will be returned by ApiService.UserEvents
func (mmUserEvents *mApiServiceMockUserEvents) Return(epa1 []*models.Event, err error) *ApiServiceMock {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("ApiServiceMock.UserEvents mock is already set by Set")
	}

	if mmUserEvents.defaultExpectation == nil {
		mmUserEvents.defaultExpectation = &ApiServiceMockUserEventsExpectation{mock: mmUserEvents.mock}
	}
	mmUserEvents.defaultExpectation.results = &ApiServiceMockUserEventsResults{epa1, err}
	mmUserEvents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserEvents.mock
}

// Set uses given function f to mock the ApiService.UserEvents method
func (mmUserEvents *mApiServiceMockUserEvents) Set(f func(ctx context.Context, userID int64) (epa1 []*models.Event, err error)) *ApiServiceMock {
	if mmUserEvents.defaultExpectation != nil {
		mmUserEvents.mock.t.Fatalf("Default expectation is already set for the ApiService.UserEvents method")
	}

	if len(mmUserEvents.expectations) > 0 {
		mmUserEvents.mock.t.Fatalf("Some expectations are already set for the ApiService.UserEvents method")
	}

	mmUserEvents.mock.funcUserEvents = f
	mmUserEvents.mock.funcUserEventsOrigin = minimock.CallerInfo(1)
	return mmUserEvents.mock
}

// When sets expectation for the ApiService.UserEvents which will trigger the result defined by the following
// Then helper
func (mmUserEvents *mApiServiceMockUserEvents) When(ctx context.Context, userID int64) *ApiServiceMockUserEventsExpectation {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("ApiServiceMock.UserEvents mock is already set by Set")
	}

	expectation := &ApiServiceMockUserEventsExpectation{
		mock:               mmUserEvents.mock,
		params:             &ApiServiceMockUserEventsParams{ctx, userID},
		expectationOrigins: ApiServiceMockUserEventsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserEvents.expectations = append(mmUserEvents.expectations, expectation)
	return expectation
}

// Then sets up ApiService.UserEvents return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockUserEventsExpectation) Then(epa1 []*models.Event, err error) *ApiServiceMock {
	e.results = &ApiServiceMockUserEventsResults{epa1, err}
	return e.mock
}

// Times sets number of times ApiService.UserEvents should be invoked
func (mmUserEvents *mApiServiceMockUserEvents) Times(n uint64) *mApiServiceMockUserEvents {
	if n == 0 {
		mmUserEvents.mock.t.Fatalf("Times of ApiServiceMock.UserEvents mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserEvents.expectedInvocations, n)
	mmUserEvents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserEvents
}

func (mmUserEvents *mApiServiceMockUserEvents) invocationsDone() bool {
	if len(mmUserEvents.expectations) == 0 && mmUserEvents.defaultExpectation == nil && mmUserEvents.mock.funcUserEvents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserEvents.mock.afterUserEventsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserEvents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserEvents implements mm_service.ApiService
func (mmUserEvents *ApiServiceMock) UserEvents(ctx context.Context, userID int64) (epa1 []*models.Event, err error) {
	mm_atomic.AddUint64(&mmUserEvents.beforeUserEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmUserEvents.afterUserEventsCounter, 1)

	mmUserEvents.t.Helper()

	if mmUserEvents.inspectFuncUserEvents != nil {
		mmUserEvents.inspectFuncUserEvents(ctx, userID)
	}

	mm_params := ApiServiceMockUserEventsParams{ctx, userID}

	// Record call args
	mmUserEvents.UserEventsMock.mutex.Lock()
	mmUserEvents.UserEventsMock.callArgs = append(mmUserEvents.UserEventsMock.callArgs, &mm_params)
	mmUserEvents.UserEventsMock.mutex.Unlock()

	for _, e := range mmUserEvents.UserEventsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.epa1, e.results.err
		}
	}

	if mmUserEvents.UserEventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserEvents.UserEventsMock.defaultExpectation.Counter, 1)
		mm_want := mmUserEvents.UserEventsMock.defaultExpectation.params
		mm_want_ptrs := mmUserEvents.UserEventsMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockUserEventsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserEvents.t.Errorf("ApiServiceMock.UserEvents got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserEvents.UserEventsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUserEvents.t.Errorf("ApiServiceMock.UserEvents got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserEvents.UserEventsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserEvents.t.Errorf("ApiServiceMock.UserEvents got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserEvents.UserEventsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserEvents.UserEventsMock.defaultExpectation.results
		if mm_results == nil {
			mmUserEvents.t.Fatal("No results are set for the ApiServiceMock.UserEvents")
		}
		return (*mm_results).epa1, (*mm_results).err
	}
	if mmUserEvents.funcUserEvents != nil {
		return mmUserEvents.funcUserEvents(ctx, userID)
	}
	mmUserEvents.t.Fatalf("Unexpected call to ApiServiceMock.UserEvents. %v %v", ctx, userID)
	return
}

// UserEventsAfterCounter returns a count of finished ApiServiceMock.UserEvents invocations
func (mmUserEvents *ApiServiceMock) UserEventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserEvents.afterUserEventsCounter)
}

// UserEventsBeforeCounter returns a count of ApiServiceMock.UserEvents invocations
func (mmUserEvents *ApiServiceMock) UserEventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserEvents.beforeUserEventsCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.UserEvents.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserEvents *mApiServiceMockUserEvents) Calls() []*ApiServiceMockUserEventsParams {
	mmUserEvents.mutex.RLock()

	argCopy := make([]*ApiServiceMockUserEventsParams, len(mmUserEvents.callArgs))
	copy(argCopy, mmUserEvents.callArgs)

	mmUserEvents.mutex.RUnlock()

	return argCopy
}

// MinimockUserEventsDone returns true if the count of the UserEvents invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockUserEventsDone() bool {
	if m.UserEventsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserEventsMock.invocationsDone()
}

// MinimockUserEventsInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockUserEventsInspect() {
	for _, e := range m.UserEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.UserEvents at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserEventsCounter := mm_atomic.LoadUint64(&m.afterUserEventsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserEventsMock.defaultExpectation != nil && afterUserEventsCounter < 1 {
		if m.UserEventsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.UserEvents at\n%s", m.UserEventsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.UserEvents at\n%s with params: %#v", m.UserEventsMock.defaultExpectation.expectationOrigins.origin, *m.UserEventsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserEvents != nil && afterUserEventsCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.UserEvents at\n%s", m.funcUserEventsOrigin)
	}

	if !m.UserEventsMock.invocationsDone() && afterUserEventsCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.UserEvents at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserEventsMock.expectedInvocations), m.UserEventsMock.expectedInvocationsOrigin, afterUserEventsCounter)
	}
}

type mApiServiceMockUserTickets struct {
	optional           bool
	mock               *ApiServiceMock
	defaultExpectation *ApiServiceMockUserTicketsExpectation
	expectations       []*ApiServiceMockUserTicketsExpectation

	callArgs []*ApiServiceMockUserTicketsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiServiceMockUserTicketsExpectation specifies expectation struct of the ApiService.UserTickets
type ApiServiceMockUserTicketsExpectation struct {
	mock               *ApiServiceMock
	params             *ApiServiceMockUserTicketsParams
	paramPtrs          *ApiServiceMockUserTicketsParamPtrs
	expectationOrigins ApiServiceMockUserTicketsExpectationOrigins
	results            *ApiServiceMockUserTicketsResults
	returnOrigin       string
	Counter            uint64
}

// ApiServiceMockUserTicketsParams contains parameters of the ApiService.UserTickets
type ApiServiceMockUserTicketsParams struct {
	ctx    context.Context
	userID int64
}

// ApiServiceMockUserTicketsParamPtrs contains pointers to parameters of the ApiService.UserTickets
type ApiServiceMockUserTicketsParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// ApiServiceMockUserTicketsResults contains results of the ApiService.UserTickets
type ApiServiceMockUserTicketsResults struct {
	tpa1 []*models.Ticket
	err  error
}

// ApiServiceMockUserTicketsOrigins contains origins of expectations of the ApiService.UserTickets
type ApiServiceMockUserTicketsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserTickets *mApiServiceMockUserTickets) Optional() *mApiServiceMockUserTickets {
	mmUserTickets.optional = true
	return mmUserTickets
}

// Expect sets up expected params for ApiService.UserTickets
func (mmUserTickets *mApiServiceMockUserTickets) Expect(ctx context.Context, userID int64) *mApiServiceMockUserTickets {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("ApiServiceMock.UserTickets mock is already set by Set")
	}

	if mmUserTickets.defaultExpectation == nil {
		mmUserTickets.defaultExpectation = &ApiServiceMockUserTicketsExpectation{}
	}

	if mmUserTickets.defaultExpectation.paramPtrs != nil {
		mmUserTickets.mock.t.Fatalf("ApiServiceMock.UserTickets mock is already set by ExpectParams functions")
	}

	mmUserTickets.defaultExpectation.params = &ApiServiceMockUserTicketsParams{ctx, userID}
	mmUserTickets.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserTickets.expectations {
		if minimock.Equal(e.params, mmUserTickets.defaultExpectation.params) {
			mmUserTickets.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserTickets.defaultExpectation.params)
		}
	}

	return mmUserTickets
}

// ExpectCtxParam1 sets up expected param ctx for ApiService.UserTickets
func (mmUserTickets *mApiServiceMockUserTickets) ExpectCtxParam1(ctx context.Context) *mApiServiceMockUserTickets {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("ApiServiceMock.UserTickets mock is already set by Set")
	}

	if mmUserTickets.defaultExpectation == nil {
		mmUserTickets.defaultExpectation = &ApiServiceMockUserTicketsExpectation{}
	}

	if mmUserTickets.defaultExpectation.params != nil {
		mmUserTickets.mock.t.Fatalf("ApiServiceMock.UserTickets mock is already set by Expect")
	}

	if mmUserTickets.defaultExpectation.paramPtrs == nil {
		mmUserTickets.defaultExpectation.paramPtrs = &ApiServiceMockUserTicketsParamPtrs{}
	}
	mmUserTickets.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserTickets.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserTickets
}

// ExpectUserIDParam2 sets up expected param userID for ApiService.UserTickets
func (mmUserTickets *mApiServiceMockUserTickets) ExpectUserIDParam2(userID int64) *mApiServiceMockUserTickets {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("ApiServiceMock.UserTickets mock is already set by Set")
	}

	if mmUserTickets.defaultExpectation == nil {
		mmUserTickets.defaultExpectation = &ApiServiceMockUserTicketsExpectation{}
	}

	if mmUserTickets.defaultExpectation.params != nil {
		mmUserTickets.mock.t.Fatalf("ApiServiceMock.UserTickets mock is already set by Expect")
	}

	if mmUserTickets.defaultExpectation.paramPtrs == nil {
		mmUserTickets.defaultExpectation.paramPtrs = &ApiServiceMockUserTicketsParamPtrs{}
	}
	mmUserTickets.defaultExpectation.paramPtrs.userID = &userID
	mmUserTickets.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUserTickets
}

// Inspect accepts an inspector function that has same arguments as the ApiService.UserTickets
func (mmUserTickets *mApiServiceMockUserTickets) Inspect(f func(ctx context.Context, userID int64)) *mApiServiceMockUserTickets {
	if mmUserTickets.mock.inspectFuncUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("Inspect function is already set for ApiServiceMock.UserTickets")
	}

	mmUserTickets.mock.inspectFuncUserTickets = f

	return mmUserTickets
}

// Return sets up results that will be returned by ApiService.UserTickets
func (mmUserTickets *mApiServiceMockUserTickets) Return(tpa1 []*models.Ticket, err error) *ApiServiceMock {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("ApiServiceMock.UserTickets mock is already set by Set")
	}

	if mmUserTickets.defaultExpectation == nil {
		mmUserTickets.defaultExpectation = &ApiServiceMockUserTicketsExpectation{mock: mmUserTickets.mock}
	}
	mmUserTickets.defaultExpectation.results = &ApiServiceMockUserTicketsResults{tpa1, err}
	mmUserTickets.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserTickets.mock
}

// Set uses given function f to mock the ApiService.UserTickets method
func (mmUserTickets *mApiServiceMockUserTickets) Set(f func(ctx context.Context, userID int64) (tpa1 []*models.Ticket, err error)) *ApiServiceMock {
	if mmUserTickets.defaultExpectation != nil {
		mmUserTickets.mock.t.Fatalf("Default expectation is already set for the ApiService.UserTickets method")
	}

	if len(mmUserTickets.expectations) > 0 {
		mmUserTickets.mock.t.Fatalf("Some expectations are already set for the ApiService.UserTickets method")
	}

	mmUserTickets.mock.funcUserTickets = f
	mmUserTickets.mock.funcUserTicketsOrigin = minimock.CallerInfo(1)
	return mmUserTickets.mock
}

// When sets expectation for the ApiService.UserTickets which will trigger the result defined by the following
// Then helper
func (mmUserTickets *mApiServiceMockUserTickets) When(ctx context.Context, userID int64) *ApiServiceMockUserTicketsExpectation {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("ApiServiceMock.UserTickets mock is already set by Set")
	}

	expectation := &ApiServiceMockUserTicketsExpectation{
		mock:               mmUserTickets.mock,
		params:             &ApiServiceMockUserTicketsParams{ctx, userID},
		expectationOrigins: ApiServiceMockUserTicketsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserTickets.expectations = append(mmUserTickets.expectations, expectation)
	return expectation
}

// Then sets up ApiService.UserTickets return parameters for the expectation previously defined by the When method
func (e *ApiServiceMockUserTicketsExpectation) Then(tpa1 []*models.Ticket, err error) *ApiServiceMock {
	e.results = &ApiServiceMockUserTicketsResults{tpa1, err}
	return e.mock
}

// Times sets number of times ApiService.UserTickets should be invoked
func (mmUserTickets *mApiServiceMockUserTickets) Times(n uint64) *mApiServiceMockUserTickets {
	if n == 0 {
		mmUserTickets.mock.t.Fatalf("Times of ApiServiceMock.UserTickets mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserTickets.expectedInvocations, n)
	mmUserTickets.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserTickets
}

func (mmUserTickets *mApiServiceMockUserTickets) invocationsDone() bool {
	if len(mmUserTickets.expectations) == 0 && mmUserTickets.defaultExpectation == nil && mmUserTickets.mock.funcUserTickets == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserTickets.mock.afterUserTicketsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserTickets.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserTickets implements mm_service.ApiService
func (mmUserTickets *ApiServiceMock) UserTickets(ctx context.Context, userID int64) (tpa1 []*models.Ticket, err error) {
	mm_atomic.AddUint64(&mmUserTickets.beforeUserTicketsCounter, 1)
	defer mm_atomic.AddUint64(&mmUserTickets.afterUserTicketsCounter, 1)

	mmUserTickets.t.Helper()

	if mmUserTickets.inspectFuncUserTickets != nil {
		mmUserTickets.inspectFuncUserTickets(ctx, userID)
	}

	mm_params := ApiServiceMockUserTicketsParams{ctx, userID}

	// Record call args
	mmUserTickets.UserTicketsMock.mutex.Lock()
	mmUserTickets.UserTicketsMock.callArgs = append(mmUserTickets.UserTicketsMock.callArgs, &mm_params)
	mmUserTickets.UserTicketsMock.mutex.Unlock()

	for _, e := range mmUserTickets.UserTicketsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmUserTickets.UserTicketsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserTickets.UserTicketsMock.defaultExpectation.Counter, 1)
		mm_want := mmUserTickets.UserTicketsMock.defaultExpectation.params
		mm_want_ptrs := mmUserTickets.UserTicketsMock.defaultExpectation.paramPtrs

		mm_got := ApiServiceMockUserTicketsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserTickets.t.Errorf("ApiServiceMock.UserTickets got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserTickets.UserTicketsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUserTickets.t.Errorf("ApiServiceMock.UserTickets got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserTickets.UserTicketsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserTickets.t.Errorf("ApiServiceMock.UserTickets got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserTickets.UserTicketsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserTickets.UserTicketsMock.defaultExpectation.results
		if mm_results == nil {
			mmUserTickets.t.Fatal("No results are set for the ApiServiceMock.UserTickets")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmUserTickets.funcUserTickets != nil {
		return mmUserTickets.funcUserTickets(ctx, userID)
	}
	mmUserTickets.t.Fatalf("Unexpected call to ApiServiceMock.UserTickets. %v %v", ctx, userID)
	return
}

// UserTicketsAfterCounter returns a count of finished ApiServiceMock.UserTickets invocations
func (mmUserTickets *ApiServiceMock) UserTicketsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserTickets.afterUserTicketsCounter)
}

// UserTicketsBeforeCounter returns a count of ApiServiceMock.UserTickets invocations
func (mmUserTickets *ApiServiceMock) UserTicketsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserTickets.beforeUserTicketsCounter)
}

// Calls returns a list of arguments used in each call to ApiServiceMock.UserTickets.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserTickets *mApiServiceMockUserTickets) Calls() []*ApiServiceMockUserTicketsParams {
	mmUserTickets.mutex.RLock()

	argCopy := make([]*ApiServiceMockUserTicketsParams, len(mmUserTickets.callArgs))
	copy(argCopy, mmUserTickets.callArgs)

	mmUserTickets.mutex.RUnlock()

	return argCopy
}

// MinimockUserTicketsDone returns true if the count of the UserTickets invocations corresponds
// the number of defined expectations
func (m *ApiServiceMock) MinimockUserTicketsDone() bool {
	if m.UserTicketsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserTicketsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserTicketsMock.invocationsDone()
}

// MinimockUserTicketsInspect logs each unmet expectation
func (m *ApiServiceMock) MinimockUserTicketsInspect() {
	for _, e := range m.UserTicketsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApiServiceMock.UserTickets at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserTicketsCounter := mm_atomic.LoadUint64(&m.afterUserTicketsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserTicketsMock.defaultExpectation != nil && afterUserTicketsCounter < 1 {
		if m.UserTicketsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ApiServiceMock.UserTickets at\n%s", m.UserTicketsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ApiServiceMock.UserTickets at\n%s with params: %#v", m.UserTicketsMock.defaultExpectation.expectationOrigins.origin, *m.UserTicketsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserTickets != nil && afterUserTicketsCounter < 1 {
		m.t.Errorf("Expected call to ApiServiceMock.UserTickets at\n%s", m.funcUserTicketsOrigin)
	}

	if !m.UserTicketsMock.invocationsDone() && afterUserTicketsCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiServiceMock.UserTickets at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserTicketsMock.expectedInvocations), m.UserTicketsMock.expectedInvocationsOrigin, afterUserTicketsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ApiServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAccessTokenInspect()

			m.MinimockBuyTicketInspect()

			m.MinimockCreateEventInspect()

			m.MinimockDeleteEventInspect()

			m.MinimockEventInspect()

			m.MinimockEventsInspect()

			m.MinimockLoginInspect()

			m.MinimockRegisterUserInspect()

			m.MinimockTicketInspect()

			m.MinimockUpdateEventInspect()

			m.MinimockUpdateUserInspect()

			m.MinimockUserInspect()

			m.MinimockUserEventsInspect()

			m.MinimockUserTicketsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ApiServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ApiServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAccessTokenDone() &&
		m.MinimockBuyTicketDone() &&
		m.MinimockCreateEventDone() &&
		m.MinimockDeleteEventDone() &&
		m.MinimockEventDone() &&
		m.MinimockEventsDone() &&
		m.MinimockLoginDone() &&
		m.MinimockRegisterUserDone() &&
		m.MinimockTicketDone() &&
		m.MinimockUpdateEventDone() &&
		m.MinimockUpdateUserDone() &&
		m.MinimockUserDone() &&
		m.MinimockUserEventsDone() &&
		m.MinimockUserTicketsDone()
}
