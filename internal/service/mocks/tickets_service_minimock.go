// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/wDRxxx/eventflow-backend/internal/service.TicketsService -o tickets_service_minimock.go -n TicketsServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/wDRxxx/eventflow-backend/internal/models"
)

// TicketsServiceMock implements mm_service.TicketsService
type TicketsServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBuyTicket          func(ctx context.Context, req *models.BuyTicketRequest) (s1 string, err error)
	funcBuyTicketOrigin    string
	inspectFuncBuyTicket   func(ctx context.Context, req *models.BuyTicketRequest)
	afterBuyTicketCounter  uint64
	beforeBuyTicketCounter uint64
	BuyTicketMock          mTicketsServiceMockBuyTicket

	funcTicket          func(ctx context.Context, ticketID string) (tp1 *models.Ticket, err error)
	funcTicketOrigin    string
	inspectFuncTicket   func(ctx context.Context, ticketID string)
	afterTicketCounter  uint64
	beforeTicketCounter uint64
	TicketMock          mTicketsServiceMockTicket

	funcUserTickets          func(ctx context.Context, userID int64) (tpa1 []*models.Ticket, err error)
	funcUserTicketsOrigin    string
	inspectFuncUserTickets   func(ctx context.Context, userID int64)
	afterUserTicketsCounter  uint64
	beforeUserTicketsCounter uint64
	UserTicketsMock          mTicketsServiceMockUserTickets
}

// NewTicketsServiceMock returns a mock for mm_service.TicketsService
func NewTicketsServiceMock(t minimock.Tester) *TicketsServiceMock {
	m := &TicketsServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BuyTicketMock = mTicketsServiceMockBuyTicket{mock: m}
	m.BuyTicketMock.callArgs = []*TicketsServiceMockBuyTicketParams{}

	m.TicketMock = mTicketsServiceMockTicket{mock: m}
	m.TicketMock.callArgs = []*TicketsServiceMockTicketParams{}

	m.UserTicketsMock = mTicketsServiceMockUserTickets{mock: m}
	m.UserTicketsMock.callArgs = []*TicketsServiceMockUserTicketsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTicketsServiceMockBuyTicket struct {
	optional           bool
	mock               *TicketsServiceMock
	defaultExpectation *TicketsServiceMockBuyTicketExpectation
	expectations       []*TicketsServiceMockBuyTicketExpectation

	callArgs []*TicketsServiceMockBuyTicketParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TicketsServiceMockBuyTicketExpectation specifies expectation struct of the TicketsService.BuyTicket
type TicketsServiceMockBuyTicketExpectation struct {
	mock               *TicketsServiceMock
	params             *TicketsServiceMockBuyTicketParams
	paramPtrs          *TicketsServiceMockBuyTicketParamPtrs
	expectationOrigins TicketsServiceMockBuyTicketExpectationOrigins
	results            *TicketsServiceMockBuyTicketResults
	returnOrigin       string
	Counter            uint64
}

// TicketsServiceMockBuyTicketParams contains parameters of the TicketsService.BuyTicket
type TicketsServiceMockBuyTicketParams struct {
	ctx context.Context
	req *models.BuyTicketRequest
}

// TicketsServiceMockBuyTicketParamPtrs contains pointers to parameters of the TicketsService.BuyTicket
type TicketsServiceMockBuyTicketParamPtrs struct {
	ctx *context.Context
	req **models.BuyTicketRequest
}

// TicketsServiceMockBuyTicketResults contains results of the TicketsService.BuyTicket
type TicketsServiceMockBuyTicketResults struct {
	s1  string
	err error
}

// TicketsServiceMockBuyTicketOrigins contains origins of expectations of the TicketsService.BuyTicket
type TicketsServiceMockBuyTicketExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBuyTicket *mTicketsServiceMockBuyTicket) Optional() *mTicketsServiceMockBuyTicket {
	mmBuyTicket.optional = true
	return mmBuyTicket
}

// Expect sets up expected params for TicketsService.BuyTicket
func (mmBuyTicket *mTicketsServiceMockBuyTicket) Expect(ctx context.Context, req *models.BuyTicketRequest) *mTicketsServiceMockBuyTicket {
	if mmBuyTicket.mock.funcBuyTicket != nil {
		mmBuyTicket.mock.t.Fatalf("TicketsServiceMock.BuyTicket mock is already set by Set")
	}

	if mmBuyTicket.defaultExpectation == nil {
		mmBuyTicket.defaultExpectation = &TicketsServiceMockBuyTicketExpectation{}
	}

	if mmBuyTicket.defaultExpectation.paramPtrs != nil {
		mmBuyTicket.mock.t.Fatalf("TicketsServiceMock.BuyTicket mock is already set by ExpectParams functions")
	}

	mmBuyTicket.defaultExpectation.params = &TicketsServiceMockBuyTicketParams{ctx, req}
	mmBuyTicket.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmBuyTicket.expectations {
		if minimock.Equal(e.params, mmBuyTicket.defaultExpectation.params) {
			mmBuyTicket.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuyTicket.defaultExpectation.params)
		}
	}

	return mmBuyTicket
}

// ExpectCtxParam1 sets up expected param ctx for TicketsService.BuyTicket
func (mmBuyTicket *mTicketsServiceMockBuyTicket) ExpectCtxParam1(ctx context.Context) *mTicketsServiceMockBuyTicket {
	if mmBuyTicket.mock.funcBuyTicket != nil {
		mmBuyTicket.mock.t.Fatalf("TicketsServiceMock.BuyTicket mock is already set by Set")
	}

	if mmBuyTicket.defaultExpectation == nil {
		mmBuyTicket.defaultExpectation = &TicketsServiceMockBuyTicketExpectation{}
	}

	if mmBuyTicket.defaultExpectation.params != nil {
		mmBuyTicket.mock.t.Fatalf("TicketsServiceMock.BuyTicket mock is already set by Expect")
	}

	if mmBuyTicket.defaultExpectation.paramPtrs == nil {
		mmBuyTicket.defaultExpectation.paramPtrs = &TicketsServiceMockBuyTicketParamPtrs{}
	}
	mmBuyTicket.defaultExpectation.paramPtrs.ctx = &ctx
	mmBuyTicket.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmBuyTicket
}

// ExpectReqParam2 sets up expected param req for TicketsService.BuyTicket
func (mmBuyTicket *mTicketsServiceMockBuyTicket) ExpectReqParam2(req *models.BuyTicketRequest) *mTicketsServiceMockBuyTicket {
	if mmBuyTicket.mock.funcBuyTicket != nil {
		mmBuyTicket.mock.t.Fatalf("TicketsServiceMock.BuyTicket mock is already set by Set")
	}

	if mmBuyTicket.defaultExpectation == nil {
		mmBuyTicket.defaultExpectation = &TicketsServiceMockBuyTicketExpectation{}
	}

	if mmBuyTicket.defaultExpectation.params != nil {
		mmBuyTicket.mock.t.Fatalf("TicketsServiceMock.BuyTicket mock is already set by Expect")
	}

	if mmBuyTicket.defaultExpectation.paramPtrs == nil {
		mmBuyTicket.defaultExpectation.paramPtrs = &TicketsServiceMockBuyTicketParamPtrs{}
	}
	mmBuyTicket.defaultExpectation.paramPtrs.req = &req
	mmBuyTicket.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmBuyTicket
}

// Inspect accepts an inspector function that has same arguments as the TicketsService.BuyTicket
func (mmBuyTicket *mTicketsServiceMockBuyTicket) Inspect(f func(ctx context.Context, req *models.BuyTicketRequest)) *mTicketsServiceMockBuyTicket {
	if mmBuyTicket.mock.inspectFuncBuyTicket != nil {
		mmBuyTicket.mock.t.Fatalf("Inspect function is already set for TicketsServiceMock.BuyTicket")
	}

	mmBuyTicket.mock.inspectFuncBuyTicket = f

	return mmBuyTicket
}

// Return sets up results that will be returned by TicketsService.BuyTicket
func (mmBuyTicket *mTicketsServiceMockBuyTicket) Return(s1 string, err error) *TicketsServiceMock {
	if mmBuyTicket.mock.funcBuyTicket != nil {
		mmBuyTicket.mock.t.Fatalf("TicketsServiceMock.BuyTicket mock is already set by Set")
	}

	if mmBuyTicket.defaultExpectation == nil {
		mmBuyTicket.defaultExpectation = &TicketsServiceMockBuyTicketExpectation{mock: mmBuyTicket.mock}
	}
	mmBuyTicket.defaultExpectation.results = &TicketsServiceMockBuyTicketResults{s1, err}
	mmBuyTicket.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBuyTicket.mock
}

// Set uses given function f to mock the TicketsService.BuyTicket method
func (mmBuyTicket *mTicketsServiceMockBuyTicket) Set(f func(ctx context.Context, req *models.BuyTicketRequest) (s1 string, err error)) *TicketsServiceMock {
	if mmBuyTicket.defaultExpectation != nil {
		mmBuyTicket.mock.t.Fatalf("Default expectation is already set for the TicketsService.BuyTicket method")
	}

	if len(mmBuyTicket.expectations) > 0 {
		mmBuyTicket.mock.t.Fatalf("Some expectations are already set for the TicketsService.BuyTicket method")
	}

	mmBuyTicket.mock.funcBuyTicket = f
	mmBuyTicket.mock.funcBuyTicketOrigin = minimock.CallerInfo(1)
	return mmBuyTicket.mock
}

// When sets expectation for the TicketsService.BuyTicket which will trigger the result defined by the following
// Then helper
func (mmBuyTicket *mTicketsServiceMockBuyTicket) When(ctx context.Context, req *models.BuyTicketRequest) *TicketsServiceMockBuyTicketExpectation {
	if mmBuyTicket.mock.funcBuyTicket != nil {
		mmBuyTicket.mock.t.Fatalf("TicketsServiceMock.BuyTicket mock is already set by Set")
	}

	expectation := &TicketsServiceMockBuyTicketExpectation{
		mock:               mmBuyTicket.mock,
		params:             &TicketsServiceMockBuyTicketParams{ctx, req},
		expectationOrigins: TicketsServiceMockBuyTicketExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmBuyTicket.expectations = append(mmBuyTicket.expectations, expectation)
	return expectation
}

// Then sets up TicketsService.BuyTicket return parameters for the expectation previously defined by the When method
func (e *TicketsServiceMockBuyTicketExpectation) Then(s1 string, err error) *TicketsServiceMock {
	e.results = &TicketsServiceMockBuyTicketResults{s1, err}
	return e.mock
}

// Times sets number of times TicketsService.BuyTicket should be invoked
func (mmBuyTicket *mTicketsServiceMockBuyTicket) Times(n uint64) *mTicketsServiceMockBuyTicket {
	if n == 0 {
		mmBuyTicket.mock.t.Fatalf("Times of TicketsServiceMock.BuyTicket mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBuyTicket.expectedInvocations, n)
	mmBuyTicket.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBuyTicket
}

func (mmBuyTicket *mTicketsServiceMockBuyTicket) invocationsDone() bool {
	if len(mmBuyTicket.expectations) == 0 && mmBuyTicket.defaultExpectation == nil && mmBuyTicket.mock.funcBuyTicket == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBuyTicket.mock.afterBuyTicketCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBuyTicket.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BuyTicket implements mm_service.TicketsService
func (mmBuyTicket *TicketsServiceMock) BuyTicket(ctx context.Context, req *models.BuyTicketRequest) (s1 string, err error) {
	mm_atomic.AddUint64(&mmBuyTicket.beforeBuyTicketCounter, 1)
	defer mm_atomic.AddUint64(&mmBuyTicket.afterBuyTicketCounter, 1)

	mmBuyTicket.t.Helper()

	if mmBuyTicket.inspectFuncBuyTicket != nil {
		mmBuyTicket.inspectFuncBuyTicket(ctx, req)
	}

	mm_params := TicketsServiceMockBuyTicketParams{ctx, req}

	// Record call args
	mmBuyTicket.BuyTicketMock.mutex.Lock()
	mmBuyTicket.BuyTicketMock.callArgs = append(mmBuyTicket.BuyTicketMock.callArgs, &mm_params)
	mmBuyTicket.BuyTicketMock.mutex.Unlock()

	for _, e := range mmBuyTicket.BuyTicketMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmBuyTicket.BuyTicketMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuyTicket.BuyTicketMock.defaultExpectation.Counter, 1)
		mm_want := mmBuyTicket.BuyTicketMock.defaultExpectation.params
		mm_want_ptrs := mmBuyTicket.BuyTicketMock.defaultExpectation.paramPtrs

		mm_got := TicketsServiceMockBuyTicketParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBuyTicket.t.Errorf("TicketsServiceMock.BuyTicket got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyTicket.BuyTicketMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmBuyTicket.t.Errorf("TicketsServiceMock.BuyTicket got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyTicket.BuyTicketMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuyTicket.t.Errorf("TicketsServiceMock.BuyTicket got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmBuyTicket.BuyTicketMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuyTicket.BuyTicketMock.defaultExpectation.results
		if mm_results == nil {
			mmBuyTicket.t.Fatal("No results are set for the TicketsServiceMock.BuyTicket")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmBuyTicket.funcBuyTicket != nil {
		return mmBuyTicket.funcBuyTicket(ctx, req)
	}
	mmBuyTicket.t.Fatalf("Unexpected call to TicketsServiceMock.BuyTicket. %v %v", ctx, req)
	return
}

// BuyTicketAfterCounter returns a count of finished TicketsServiceMock.BuyTicket invocations
func (mmBuyTicket *TicketsServiceMock) BuyTicketAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuyTicket.afterBuyTicketCounter)
}

// BuyTicketBeforeCounter returns a count of TicketsServiceMock.BuyTicket invocations
func (mmBuyTicket *TicketsServiceMock) BuyTicketBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuyTicket.beforeBuyTicketCounter)
}

// Calls returns a list of arguments used in each call to TicketsServiceMock.BuyTicket.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuyTicket *mTicketsServiceMockBuyTicket) Calls() []*TicketsServiceMockBuyTicketParams {
	mmBuyTicket.mutex.RLock()

	argCopy := make([]*TicketsServiceMockBuyTicketParams, len(mmBuyTicket.callArgs))
	copy(argCopy, mmBuyTicket.callArgs)

	mmBuyTicket.mutex.RUnlock()

	return argCopy
}

// MinimockBuyTicketDone returns true if the count of the BuyTicket invocations corresponds
// the number of defined expectations
func (m *TicketsServiceMock) MinimockBuyTicketDone() bool {
	if m.BuyTicketMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BuyTicketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BuyTicketMock.invocationsDone()
}

// MinimockBuyTicketInspect logs each unmet expectation
func (m *TicketsServiceMock) MinimockBuyTicketInspect() {
	for _, e := range m.BuyTicketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TicketsServiceMock.BuyTicket at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterBuyTicketCounter := mm_atomic.LoadUint64(&m.afterBuyTicketCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BuyTicketMock.defaultExpectation != nil && afterBuyTicketCounter < 1 {
		if m.BuyTicketMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TicketsServiceMock.BuyTicket at\n%s", m.BuyTicketMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TicketsServiceMock.BuyTicket at\n%s with params: %#v", m.BuyTicketMock.defaultExpectation.expectationOrigins.origin, *m.BuyTicketMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuyTicket != nil && afterBuyTicketCounter < 1 {
		m.t.Errorf("Expected call to TicketsServiceMock.BuyTicket at\n%s", m.funcBuyTicketOrigin)
	}

	if !m.BuyTicketMock.invocationsDone() && afterBuyTicketCounter > 0 {
		m.t.Errorf("Expected %d calls to TicketsServiceMock.BuyTicket at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BuyTicketMock.expectedInvocations), m.BuyTicketMock.expectedInvocationsOrigin, afterBuyTicketCounter)
	}
}

type mTicketsServiceMockTicket struct {
	optional           bool
	mock               *TicketsServiceMock
	defaultExpectation *TicketsServiceMockTicketExpectation
	expectations       []*TicketsServiceMockTicketExpectation

	callArgs []*TicketsServiceMockTicketParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TicketsServiceMockTicketExpectation specifies expectation struct of the TicketsService.Ticket
type TicketsServiceMockTicketExpectation struct {
	mock               *TicketsServiceMock
	params             *TicketsServiceMockTicketParams
	paramPtrs          *TicketsServiceMockTicketParamPtrs
	expectationOrigins TicketsServiceMockTicketExpectationOrigins
	results            *TicketsServiceMockTicketResults
	returnOrigin       string
	Counter            uint64
}

// TicketsServiceMockTicketParams contains parameters of the TicketsService.Ticket
type TicketsServiceMockTicketParams struct {
	ctx      context.Context
	ticketID string
}

// TicketsServiceMockTicketParamPtrs contains pointers to parameters of the TicketsService.Ticket
type TicketsServiceMockTicketParamPtrs struct {
	ctx      *context.Context
	ticketID *string
}

// TicketsServiceMockTicketResults contains results of the TicketsService.Ticket
type TicketsServiceMockTicketResults struct {
	tp1 *models.Ticket
	err error
}

// TicketsServiceMockTicketOrigins contains origins of expectations of the TicketsService.Ticket
type TicketsServiceMockTicketExpectationOrigins struct {
	origin         string
	originCtx      string
	originTicketID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTicket *mTicketsServiceMockTicket) Optional() *mTicketsServiceMockTicket {
	mmTicket.optional = true
	return mmTicket
}

// Expect sets up expected params for TicketsService.Ticket
func (mmTicket *mTicketsServiceMockTicket) Expect(ctx context.Context, ticketID string) *mTicketsServiceMockTicket {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("TicketsServiceMock.Ticket mock is already set by Set")
	}

	if mmTicket.defaultExpectation == nil {
		mmTicket.defaultExpectation = &TicketsServiceMockTicketExpectation{}
	}

	if mmTicket.defaultExpectation.paramPtrs != nil {
		mmTicket.mock.t.Fatalf("TicketsServiceMock.Ticket mock is already set by ExpectParams functions")
	}

	mmTicket.defaultExpectation.params = &TicketsServiceMockTicketParams{ctx, ticketID}
	mmTicket.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTicket.expectations {
		if minimock.Equal(e.params, mmTicket.defaultExpectation.params) {
			mmTicket.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTicket.defaultExpectation.params)
		}
	}

	return mmTicket
}

// ExpectCtxParam1 sets up expected param ctx for TicketsService.Ticket
func (mmTicket *mTicketsServiceMockTicket) ExpectCtxParam1(ctx context.Context) *mTicketsServiceMockTicket {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("TicketsServiceMock.Ticket mock is already set by Set")
	}

	if mmTicket.defaultExpectation == nil {
		mmTicket.defaultExpectation = &TicketsServiceMockTicketExpectation{}
	}

	if mmTicket.defaultExpectation.params != nil {
		mmTicket.mock.t.Fatalf("TicketsServiceMock.Ticket mock is already set by Expect")
	}

	if mmTicket.defaultExpectation.paramPtrs == nil {
		mmTicket.defaultExpectation.paramPtrs = &TicketsServiceMockTicketParamPtrs{}
	}
	mmTicket.defaultExpectation.paramPtrs.ctx = &ctx
	mmTicket.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTicket
}

// ExpectTicketIDParam2 sets up expected param ticketID for TicketsService.Ticket
func (mmTicket *mTicketsServiceMockTicket) ExpectTicketIDParam2(ticketID string) *mTicketsServiceMockTicket {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("TicketsServiceMock.Ticket mock is already set by Set")
	}

	if mmTicket.defaultExpectation == nil {
		mmTicket.defaultExpectation = &TicketsServiceMockTicketExpectation{}
	}

	if mmTicket.defaultExpectation.params != nil {
		mmTicket.mock.t.Fatalf("TicketsServiceMock.Ticket mock is already set by Expect")
	}

	if mmTicket.defaultExpectation.paramPtrs == nil {
		mmTicket.defaultExpectation.paramPtrs = &TicketsServiceMockTicketParamPtrs{}
	}
	mmTicket.defaultExpectation.paramPtrs.ticketID = &ticketID
	mmTicket.defaultExpectation.expectationOrigins.originTicketID = minimock.CallerInfo(1)

	return mmTicket
}

// Inspect accepts an inspector function that has same arguments as the TicketsService.Ticket
func (mmTicket *mTicketsServiceMockTicket) Inspect(f func(ctx context.Context, ticketID string)) *mTicketsServiceMockTicket {
	if mmTicket.mock.inspectFuncTicket != nil {
		mmTicket.mock.t.Fatalf("Inspect function is already set for TicketsServiceMock.Ticket")
	}

	mmTicket.mock.inspectFuncTicket = f

	return mmTicket
}

// Return sets up results that will be returned by TicketsService.Ticket
func (mmTicket *mTicketsServiceMockTicket) Return(tp1 *models.Ticket, err error) *TicketsServiceMock {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("TicketsServiceMock.Ticket mock is already set by Set")
	}

	if mmTicket.defaultExpectation == nil {
		mmTicket.defaultExpectation = &TicketsServiceMockTicketExpectation{mock: mmTicket.mock}
	}
	mmTicket.defaultExpectation.results = &TicketsServiceMockTicketResults{tp1, err}
	mmTicket.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTicket.mock
}

// Set uses given function f to mock the TicketsService.Ticket method
func (mmTicket *mTicketsServiceMockTicket) Set(f func(ctx context.Context, ticketID string) (tp1 *models.Ticket, err error)) *TicketsServiceMock {
	if mmTicket.defaultExpectation != nil {
		mmTicket.mock.t.Fatalf("Default expectation is already set for the TicketsService.Ticket method")
	}

	if len(mmTicket.expectations) > 0 {
		mmTicket.mock.t.Fatalf("Some expectations are already set for the TicketsService.Ticket method")
	}

	mmTicket.mock.funcTicket = f
	mmTicket.mock.funcTicketOrigin = minimock.CallerInfo(1)
	return mmTicket.mock
}

// When sets expectation for the TicketsService.Ticket which will trigger the result defined by the following
// Then helper
func (mmTicket *mTicketsServiceMockTicket) When(ctx context.Context, ticketID string) *TicketsServiceMockTicketExpectation {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("TicketsServiceMock.Ticket mock is already set by Set")
	}

	expectation := &TicketsServiceMockTicketExpectation{
		mock:               mmTicket.mock,
		params:             &TicketsServiceMockTicketParams{ctx, ticketID},
		expectationOrigins: TicketsServiceMockTicketExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTicket.expectations = append(mmTicket.expectations, expectation)
	return expectation
}

// Then sets up TicketsService.Ticket return parameters for the expectation previously defined by the When method
func (e *TicketsServiceMockTicketExpectation) Then(tp1 *models.Ticket, err error) *TicketsServiceMock {
	e.results = &TicketsServiceMockTicketResults{tp1, err}
	return e.mock
}

// Times sets number of times TicketsService.Ticket should be invoked
func (mmTicket *mTicketsServiceMockTicket) Times(n uint64) *mTicketsServiceMockTicket {
	if n == 0 {
		mmTicket.mock.t.Fatalf("Times of TicketsServiceMock.Ticket mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTicket.expectedInvocations, n)
	mmTicket.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTicket
}

func (mmTicket *mTicketsServiceMockTicket) invocationsDone() bool {
	if len(mmTicket.expectations) == 0 && mmTicket.defaultExpectation == nil && mmTicket.mock.funcTicket == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTicket.mock.afterTicketCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTicket.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Ticket implements mm_service.TicketsService
func (mmTicket *TicketsServiceMock) Ticket(ctx context.Context, ticketID string) (tp1 *models.Ticket, err error) {
	mm_atomic.AddUint64(&mmTicket.beforeTicketCounter, 1)
	defer mm_atomic.AddUint64(&mmTicket.afterTicketCounter, 1)

	mmTicket.t.Helper()

	if mmTicket.inspectFuncTicket != nil {
		mmTicket.inspectFuncTicket(ctx, ticketID)
	}

	mm_params := TicketsServiceMockTicketParams{ctx, ticketID}

	// Record call args
	mmTicket.TicketMock.mutex.Lock()
	mmTicket.TicketMock.callArgs = append(mmTicket.TicketMock.callArgs, &mm_params)
	mmTicket.TicketMock.mutex.Unlock()

	for _, e := range mmTicket.TicketMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmTicket.TicketMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTicket.TicketMock.defaultExpectation.Counter, 1)
		mm_want := mmTicket.TicketMock.defaultExpectation.params
		mm_want_ptrs := mmTicket.TicketMock.defaultExpectation.paramPtrs

		mm_got := TicketsServiceMockTicketParams{ctx, ticketID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTicket.t.Errorf("TicketsServiceMock.Ticket got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTicket.TicketMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ticketID != nil && !minimock.Equal(*mm_want_ptrs.ticketID, mm_got.ticketID) {
				mmTicket.t.Errorf("TicketsServiceMock.Ticket got unexpected parameter ticketID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTicket.TicketMock.defaultExpectation.expectationOrigins.originTicketID, *mm_want_ptrs.ticketID, mm_got.ticketID, minimock.Diff(*mm_want_ptrs.ticketID, mm_got.ticketID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTicket.t.Errorf("TicketsServiceMock.Ticket got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTicket.TicketMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTicket.TicketMock.defaultExpectation.results
		if mm_results == nil {
			mmTicket.t.Fatal("No results are set for the TicketsServiceMock.Ticket")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmTicket.funcTicket != nil {
		return mmTicket.funcTicket(ctx, ticketID)
	}
	mmTicket.t.Fatalf("Unexpected call to TicketsServiceMock.Ticket. %v %v", ctx, ticketID)
	return
}

// TicketAfterCounter returns a count of finished TicketsServiceMock.Ticket invocations
func (mmTicket *TicketsServiceMock) TicketAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTicket.afterTicketCounter)
}

// TicketBeforeCounter returns a count of TicketsServiceMock.Ticket invocations
func (mmTicket *TicketsServiceMock) TicketBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTicket.beforeTicketCounter)
}

// Calls returns a list of arguments used in each call to TicketsServiceMock.Ticket.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTicket *mTicketsServiceMockTicket) Calls() []*TicketsServiceMockTicketParams {
	mmTicket.mutex.RLock()

	argCopy := make([]*TicketsServiceMockTicketParams, len(mmTicket.callArgs))
	copy(argCopy, mmTicket.callArgs)

	mmTicket.mutex.RUnlock()

	return argCopy
}

// MinimockTicketDone returns true if the count of the Ticket invocations corresponds
// the number of defined expectations
func (m *TicketsServiceMock) MinimockTicketDone() bool {
	if m.TicketMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TicketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TicketMock.invocationsDone()
}

// MinimockTicketInspect logs each unmet expectation
func (m *TicketsServiceMock) MinimockTicketInspect() {
	for _, e := range m.TicketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TicketsServiceMock.Ticket at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTicketCounter := mm_atomic.LoadUint64(&m.afterTicketCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TicketMock.defaultExpectation != nil && afterTicketCounter < 1 {
		if m.TicketMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TicketsServiceMock.Ticket at\n%s", m.TicketMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TicketsServiceMock.Ticket at\n%s with params: %#v", m.TicketMock.defaultExpectation.expectationOrigins.origin, *m.TicketMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTicket != nil && afterTicketCounter < 1 {
		m.t.Errorf("Expected call to TicketsServiceMock.Ticket at\n%s", m.funcTicketOrigin)
	}

	if !m.TicketMock.invocationsDone() && afterTicketCounter > 0 {
		m.t.Errorf("Expected %d calls to TicketsServiceMock.Ticket at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TicketMock.expectedInvocations), m.TicketMock.expectedInvocationsOrigin, afterTicketCounter)
	}
}

type mTicketsServiceMockUserTickets struct {
	optional           bool
	mock               *TicketsServiceMock
	defaultExpectation *TicketsServiceMockUserTicketsExpectation
	expectations       []*TicketsServiceMockUserTicketsExpectation

	callArgs []*TicketsServiceMockUserTicketsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TicketsServiceMockUserTicketsExpectation specifies expectation struct of the TicketsService.UserTickets
type TicketsServiceMockUserTicketsExpectation struct {
	mock               *TicketsServiceMock
	params             *TicketsServiceMockUserTicketsParams
	paramPtrs          *TicketsServiceMockUserTicketsParamPtrs
	expectationOrigins TicketsServiceMockUserTicketsExpectationOrigins
	results            *TicketsServiceMockUserTicketsResults
	returnOrigin       string
	Counter            uint64
}

// TicketsServiceMockUserTicketsParams contains parameters of the TicketsService.UserTickets
type TicketsServiceMockUserTicketsParams struct {
	ctx    context.Context
	userID int64
}

// TicketsServiceMockUserTicketsParamPtrs contains pointers to parameters of the TicketsService.UserTickets
type TicketsServiceMockUserTicketsParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// TicketsServiceMockUserTicketsResults contains results of the TicketsService.UserTickets
type TicketsServiceMockUserTicketsResults struct {
	tpa1 []*models.Ticket
	err  error
}

// TicketsServiceMockUserTicketsOrigins contains origins of expectations of the TicketsService.UserTickets
type TicketsServiceMockUserTicketsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserTickets *mTicketsServiceMockUserTickets) Optional() *mTicketsServiceMockUserTickets {
	mmUserTickets.optional = true
	return mmUserTickets
}

// Expect sets up expected params for TicketsService.UserTickets
func (mmUserTickets *mTicketsServiceMockUserTickets) Expect(ctx context.Context, userID int64) *mTicketsServiceMockUserTickets {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("TicketsServiceMock.UserTickets mock is already set by Set")
	}

	if mmUserTickets.defaultExpectation == nil {
		mmUserTickets.defaultExpectation = &TicketsServiceMockUserTicketsExpectation{}
	}

	if mmUserTickets.defaultExpectation.paramPtrs != nil {
		mmUserTickets.mock.t.Fatalf("TicketsServiceMock.UserTickets mock is already set by ExpectParams functions")
	}

	mmUserTickets.defaultExpectation.params = &TicketsServiceMockUserTicketsParams{ctx, userID}
	mmUserTickets.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserTickets.expectations {
		if minimock.Equal(e.params, mmUserTickets.defaultExpectation.params) {
			mmUserTickets.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserTickets.defaultExpectation.params)
		}
	}

	return mmUserTickets
}

// ExpectCtxParam1 sets up expected param ctx for TicketsService.UserTickets
func (mmUserTickets *mTicketsServiceMockUserTickets) ExpectCtxParam1(ctx context.Context) *mTicketsServiceMockUserTickets {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("TicketsServiceMock.UserTickets mock is already set by Set")
	}

	if mmUserTickets.defaultExpectation == nil {
		mmUserTickets.defaultExpectation = &TicketsServiceMockUserTicketsExpectation{}
	}

	if mmUserTickets.defaultExpectation.params != nil {
		mmUserTickets.mock.t.Fatalf("TicketsServiceMock.UserTickets mock is already set by Expect")
	}

	if mmUserTickets.defaultExpectation.paramPtrs == nil {
		mmUserTickets.defaultExpectation.paramPtrs = &TicketsServiceMockUserTicketsParamPtrs{}
	}
	mmUserTickets.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserTickets.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserTickets
}

// ExpectUserIDParam2 sets up expected param userID for TicketsService.UserTickets
func (mmUserTickets *mTicketsServiceMockUserTickets) ExpectUserIDParam2(userID int64) *mTicketsServiceMockUserTickets {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("TicketsServiceMock.UserTickets mock is already set by Set")
	}

	if mmUserTickets.defaultExpectation == nil {
		mmUserTickets.defaultExpectation = &TicketsServiceMockUserTicketsExpectation{}
	}

	if mmUserTickets.defaultExpectation.params != nil {
		mmUserTickets.mock.t.Fatalf("TicketsServiceMock.UserTickets mock is already set by Expect")
	}

	if mmUserTickets.defaultExpectation.paramPtrs == nil {
		mmUserTickets.defaultExpectation.paramPtrs = &TicketsServiceMockUserTicketsParamPtrs{}
	}
	mmUserTickets.defaultExpectation.paramPtrs.userID = &userID
	mmUserTickets.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUserTickets
}

// Inspect accepts an inspector function that has same arguments as the TicketsService.UserTickets
func (mmUserTickets *mTicketsServiceMockUserTickets) Inspect(f func(ctx context.Context, userID int64)) *mTicketsServiceMockUserTickets {
	if mmUserTickets.mock.inspectFuncUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("Inspect function is already set for TicketsServiceMock.UserTickets")
	}

	mmUserTickets.mock.inspectFuncUserTickets = f

	return mmUserTickets
}

// Return sets up results that will be returned by TicketsService.UserTickets
func (mmUserTickets *mTicketsServiceMockUserTickets) Return(tpa1 []*models.Ticket, err error) *TicketsServiceMock {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("TicketsServiceMock.UserTickets mock is already set by Set")
	}

	if mmUserTickets.defaultExpectation == nil {
		mmUserTickets.defaultExpectation = &TicketsServiceMockUserTicketsExpectation{mock: mmUserTickets.mock}
	}
	mmUserTickets.defaultExpectation.results = &TicketsServiceMockUserTicketsResults{tpa1, err}
	mmUserTickets.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserTickets.mock
}

// Set uses given function f to mock the TicketsService.UserTickets method
func (mmUserTickets *mTicketsServiceMockUserTickets) Set(f func(ctx context.Context, userID int64) (tpa1 []*models.Ticket, err error)) *TicketsServiceMock {
	if mmUserTickets.defaultExpectation != nil {
		mmUserTickets.mock.t.Fatalf("Default expectation is already set for the TicketsService.UserTickets method")
	}

	if len(mmUserTickets.expectations) > 0 {
		mmUserTickets.mock.t.Fatalf("Some expectations are already set for the TicketsService.UserTickets method")
	}

	mmUserTickets.mock.funcUserTickets = f
	mmUserTickets.mock.funcUserTicketsOrigin = minimock.CallerInfo(1)
	return mmUserTickets.mock
}

// When sets expectation for the TicketsService.UserTickets which will trigger the result defined by the following
// Then helper
func (mmUserTickets *mTicketsServiceMockUserTickets) When(ctx context.Context, userID int64) *TicketsServiceMockUserTicketsExpectation {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("TicketsServiceMock.UserTickets mock is already set by Set")
	}

	expectation := &TicketsServiceMockUserTicketsExpectation{
		mock:               mmUserTickets.mock,
		params:             &TicketsServiceMockUserTicketsParams{ctx, userID},
		expectationOrigins: TicketsServiceMockUserTicketsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserTickets.expectations = append(mmUserTickets.expectations, expectation)
	return expectation
}

// Then sets up TicketsService.UserTickets return parameters for the expectation previously defined by the When method
func (e *TicketsServiceMockUserTicketsExpectation) Then(tpa1 []*models.Ticket, err error) *TicketsServiceMock {
	e.results = &TicketsServiceMockUserTicketsResults{tpa1, err}
	return e.mock
}

// Times sets number of times TicketsService.UserTickets should be invoked
func (mmUserTickets *mTicketsServiceMockUserTickets) Times(n uint64) *mTicketsServiceMockUserTickets {
	if n == 0 {
		mmUserTickets.mock.t.Fatalf("Times of TicketsServiceMock.UserTickets mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserTickets.expectedInvocations, n)
	mmUserTickets.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserTickets
}

func (mmUserTickets *mTicketsServiceMockUserTickets) invocationsDone() bool {
	if len(mmUserTickets.expectations) == 0 && mmUserTickets.defaultExpectation == nil && mmUserTickets.mock.funcUserTickets == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserTickets.mock.afterUserTicketsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserTickets.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserTickets implements mm_service.TicketsService
func (mmUserTickets *TicketsServiceMock) UserTickets(ctx context.Context, userID int64) (tpa1 []*models.Ticket, err error) {
	mm_atomic.AddUint64(&mmUserTickets.beforeUserTicketsCounter, 1)
	defer mm_atomic.AddUint64(&mmUserTickets.afterUserTicketsCounter, 1)

	mmUserTickets.t.Helper()

	if mmUserTickets.inspectFuncUserTickets != nil {
		mmUserTickets.inspectFuncUserTickets(ctx, userID)
	}

	mm_params := TicketsServiceMockUserTicketsParams{ctx, userID}

	// Record call args
	mmUserTickets.UserTicketsMock.mutex.Lock()
	mmUserTickets.UserTicketsMock.callArgs = append(mmUserTickets.UserTicketsMock.callArgs, &mm_params)
	mmUserTickets.UserTicketsMock.mutex.Unlock()

	for _, e := range mmUserTickets.UserTicketsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmUserTickets.UserTicketsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserTickets.UserTicketsMock.defaultExpectation.Counter, 1)
		mm_want := mmUserTickets.UserTicketsMock.defaultExpectation.params
		mm_want_ptrs := mmUserTickets.UserTicketsMock.defaultExpectation.paramPtrs

		mm_got := TicketsServiceMockUserTicketsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserTickets.t.Errorf("TicketsServiceMock.UserTickets got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserTickets.UserTicketsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUserTickets.t.Errorf("TicketsServiceMock.UserTickets got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserTickets.UserTicketsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserTickets.t.Errorf("TicketsServiceMock.UserTickets got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserTickets.UserTicketsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserTickets.UserTicketsMock.defaultExpectation.results
		if mm_results == nil {
			mmUserTickets.t.Fatal("No results are set for the TicketsServiceMock.UserTickets")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmUserTickets.funcUserTickets != nil {
		return mmUserTickets.funcUserTickets(ctx, userID)
	}
	mmUserTickets.t.Fatalf("Unexpected call to TicketsServiceMock.UserTickets. %v %v", ctx, userID)
	return
}

// UserTicketsAfterCounter returns a count of finished TicketsServiceMock.UserTickets invocations
func (mmUserTickets *TicketsServiceMock) UserTicketsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserTickets.afterUserTicketsCounter)
}

// UserTicketsBeforeCounter returns a count of TicketsServiceMock.UserTickets invocations
func (mmUserTickets *TicketsServiceMock) UserTicketsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserTickets.beforeUserTicketsCounter)
}

// Calls returns a list of arguments used in each call to TicketsServiceMock.UserTickets.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserTickets *mTicketsServiceMockUserTickets) Calls() []*TicketsServiceMockUserTicketsParams {
	mmUserTickets.mutex.RLock()

	argCopy := make([]*TicketsServiceMockUserTicketsParams, len(mmUserTickets.callArgs))
	copy(argCopy, mmUserTickets.callArgs)

	mmUserTickets.mutex.RUnlock()

	return argCopy
}

// MinimockUserTicketsDone returns true if the count of the UserTickets invocations corresponds
// the number of defined expectations
func (m *TicketsServiceMock) MinimockUserTicketsDone() bool {
	if m.UserTicketsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserTicketsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserTicketsMock.invocationsDone()
}

// MinimockUserTicketsInspect logs each unmet expectation
func (m *TicketsServiceMock) MinimockUserTicketsInspect() {
	for _, e := range m.UserTicketsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TicketsServiceMock.UserTickets at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserTicketsCounter := mm_atomic.LoadUint64(&m.afterUserTicketsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserTicketsMock.defaultExpectation != nil && afterUserTicketsCounter < 1 {
		if m.UserTicketsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TicketsServiceMock.UserTickets at\n%s", m.UserTicketsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TicketsServiceMock.UserTickets at\n%s with params: %#v", m.UserTicketsMock.defaultExpectation.expectationOrigins.origin, *m.UserTicketsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserTickets != nil && afterUserTicketsCounter < 1 {
		m.t.Errorf("Expected call to TicketsServiceMock.UserTickets at\n%s", m.funcUserTicketsOrigin)
	}

	if !m.UserTicketsMock.invocationsDone() && afterUserTicketsCounter > 0 {
		m.t.Errorf("Expected %d calls to TicketsServiceMock.UserTickets at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserTicketsMock.expectedInvocations), m.UserTicketsMock.expectedInvocationsOrigin, afterUserTicketsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TicketsServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBuyTicketInspect()

			m.MinimockTicketInspect()

			m.MinimockUserTicketsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TicketsServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TicketsServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBuyTicketDone() &&
		m.MinimockTicketDone() &&
		m.MinimockUserTicketsDone()
}
