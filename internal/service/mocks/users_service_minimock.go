// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/wDRxxx/eventflow-backend/internal/service.UsersService -o users_service_minimock.go -n UsersServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/wDRxxx/eventflow-backend/internal/models"
)

// UsersServiceMock implements mm_service.UsersService
type UsersServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAccessToken          func(ctx context.Context, refreshToken string) (s1 string, err error)
	funcAccessTokenOrigin    string
	inspectFuncAccessToken   func(ctx context.Context, refreshToken string)
	afterAccessTokenCounter  uint64
	beforeAccessTokenCounter uint64
	AccessTokenMock          mUsersServiceMockAccessToken

	funcLogin          func(ctx context.Context, user *models.User) (s1 string, err error)
	funcLoginOrigin    string
	inspectFuncLogin   func(ctx context.Context, user *models.User)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mUsersServiceMockLogin

	funcRegisterUser          func(ctx context.Context, user *models.User) (err error)
	funcRegisterUserOrigin    string
	inspectFuncRegisterUser   func(ctx context.Context, user *models.User)
	afterRegisterUserCounter  uint64
	beforeRegisterUserCounter uint64
	RegisterUserMock          mUsersServiceMockRegisterUser

	funcUpdateUser          func(ctx context.Context, user *models.User) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, user *models.User)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mUsersServiceMockUpdateUser

	funcUser          func(ctx context.Context, userEmail string) (up1 *models.User, err error)
	funcUserOrigin    string
	inspectFuncUser   func(ctx context.Context, userEmail string)
	afterUserCounter  uint64
	beforeUserCounter uint64
	UserMock          mUsersServiceMockUser
}

// NewUsersServiceMock returns a mock for mm_service.UsersService
func NewUsersServiceMock(t minimock.Tester) *UsersServiceMock {
	m := &UsersServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AccessTokenMock = mUsersServiceMockAccessToken{mock: m}
	m.AccessTokenMock.callArgs = []*UsersServiceMockAccessTokenParams{}

	m.LoginMock = mUsersServiceMockLogin{mock: m}
	m.LoginMock.callArgs = []*UsersServiceMockLoginParams{}

	m.RegisterUserMock = mUsersServiceMockRegisterUser{mock: m}
	m.RegisterUserMock.callArgs = []*UsersServiceMockRegisterUserParams{}

	m.UpdateUserMock = mUsersServiceMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*UsersServiceMockUpdateUserParams{}

	m.UserMock = mUsersServiceMockUser{mock: m}
	m.UserMock.callArgs = []*UsersServiceMockUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUsersServiceMockAccessToken struct {
	optional           bool
	mock               *UsersServiceMock
	defaultExpectation *UsersServiceMockAccessTokenExpectation
	expectations       []*UsersServiceMockAccessTokenExpectation

	callArgs []*UsersServiceMockAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersServiceMockAccessTokenExpectation specifies expectation struct of the UsersService.AccessToken
type UsersServiceMockAccessTokenExpectation struct {
	mock               *UsersServiceMock
	params             *UsersServiceMockAccessTokenParams
	paramPtrs          *UsersServiceMockAccessTokenParamPtrs
	expectationOrigins UsersServiceMockAccessTokenExpectationOrigins
	results            *UsersServiceMockAccessTokenResults
	returnOrigin       string
	Counter            uint64
}

// UsersServiceMockAccessTokenParams contains parameters of the UsersService.AccessToken
type UsersServiceMockAccessTokenParams struct {
	ctx          context.Context
	refreshToken string
}

// UsersServiceMockAccessTokenParamPtrs contains pointers to parameters of the UsersService.AccessToken
type UsersServiceMockAccessTokenParamPtrs struct {
	ctx          *context.Context
	refreshToken *string
}

// UsersServiceMockAccessTokenResults contains results of the UsersService.AccessToken
type UsersServiceMockAccessTokenResults struct {
	s1  string
	err error
}

// UsersServiceMockAccessTokenOrigins contains origins of expectations of the UsersService.AccessToken
type UsersServiceMockAccessTokenExpectationOrigins struct {
	origin             string
	originCtx          string
	originRefreshToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAccessToken *mUsersServiceMockAccessToken) Optional() *mUsersServiceMockAccessToken {
	mmAccessToken.optional = true
	return mmAccessToken
}

// Expect sets up expected params for UsersService.AccessToken
func (mmAccessToken *mUsersServiceMockAccessToken) Expect(ctx context.Context, refreshToken string) *mUsersServiceMockAccessToken {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("UsersServiceMock.AccessToken mock is already set by Set")
	}

	if mmAccessToken.defaultExpectation == nil {
		mmAccessToken.defaultExpectation = &UsersServiceMockAccessTokenExpectation{}
	}

	if mmAccessToken.defaultExpectation.paramPtrs != nil {
		mmAccessToken.mock.t.Fatalf("UsersServiceMock.AccessToken mock is already set by ExpectParams functions")
	}

	mmAccessToken.defaultExpectation.params = &UsersServiceMockAccessTokenParams{ctx, refreshToken}
	mmAccessToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAccessToken.expectations {
		if minimock.Equal(e.params, mmAccessToken.defaultExpectation.params) {
			mmAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAccessToken.defaultExpectation.params)
		}
	}

	return mmAccessToken
}

// ExpectCtxParam1 sets up expected param ctx for UsersService.AccessToken
func (mmAccessToken *mUsersServiceMockAccessToken) ExpectCtxParam1(ctx context.Context) *mUsersServiceMockAccessToken {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("UsersServiceMock.AccessToken mock is already set by Set")
	}

	if mmAccessToken.defaultExpectation == nil {
		mmAccessToken.defaultExpectation = &UsersServiceMockAccessTokenExpectation{}
	}

	if mmAccessToken.defaultExpectation.params != nil {
		mmAccessToken.mock.t.Fatalf("UsersServiceMock.AccessToken mock is already set by Expect")
	}

	if mmAccessToken.defaultExpectation.paramPtrs == nil {
		mmAccessToken.defaultExpectation.paramPtrs = &UsersServiceMockAccessTokenParamPtrs{}
	}
	mmAccessToken.defaultExpectation.paramPtrs.ctx = &ctx
	mmAccessToken.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAccessToken
}

// ExpectRefreshTokenParam2 sets up expected param refreshToken for UsersService.AccessToken
func (mmAccessToken *mUsersServiceMockAccessToken) ExpectRefreshTokenParam2(refreshToken string) *mUsersServiceMockAccessToken {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("UsersServiceMock.AccessToken mock is already set by Set")
	}

	if mmAccessToken.defaultExpectation == nil {
		mmAccessToken.defaultExpectation = &UsersServiceMockAccessTokenExpectation{}
	}

	if mmAccessToken.defaultExpectation.params != nil {
		mmAccessToken.mock.t.Fatalf("UsersServiceMock.AccessToken mock is already set by Expect")
	}

	if mmAccessToken.defaultExpectation.paramPtrs == nil {
		mmAccessToken.defaultExpectation.paramPtrs = &UsersServiceMockAccessTokenParamPtrs{}
	}
	mmAccessToken.defaultExpectation.paramPtrs.refreshToken = &refreshToken
	mmAccessToken.defaultExpectation.expectationOrigins.originRefreshToken = minimock.CallerInfo(1)

	return mmAccessToken
}

// Inspect accepts an inspector function that has same arguments as the UsersService.AccessToken
func (mmAccessToken *mUsersServiceMockAccessToken) Inspect(f func(ctx context.Context, refreshToken string)) *mUsersServiceMockAccessToken {
	if mmAccessToken.mock.inspectFuncAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("Inspect function is already set for UsersServiceMock.AccessToken")
	}

	mmAccessToken.mock.inspectFuncAccessToken = f

	return mmAccessToken
}

// Return sets up results that will be returned by UsersService.AccessToken
func (mmAccessToken *mUsersServiceMockAccessToken) Return(s1 string, err error) *UsersServiceMock {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("UsersServiceMock.AccessToken mock is already set by Set")
	}

	if mmAccessToken.defaultExpectation == nil {
		mmAccessToken.defaultExpectation = &UsersServiceMockAccessTokenExpectation{mock: mmAccessToken.mock}
	}
	mmAccessToken.defaultExpectation.results = &UsersServiceMockAccessTokenResults{s1, err}
	mmAccessToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAccessToken.mock
}

// Set uses given function f to mock the UsersService.AccessToken method
func (mmAccessToken *mUsersServiceMockAccessToken) Set(f func(ctx context.Context, refreshToken string) (s1 string, err error)) *UsersServiceMock {
	if mmAccessToken.defaultExpectation != nil {
		mmAccessToken.mock.t.Fatalf("Default expectation is already set for the UsersService.AccessToken method")
	}

	if len(mmAccessToken.expectations) > 0 {
		mmAccessToken.mock.t.Fatalf("Some expectations are already set for the UsersService.AccessToken method")
	}

	mmAccessToken.mock.funcAccessToken = f
	mmAccessToken.mock.funcAccessTokenOrigin = minimock.CallerInfo(1)
	return mmAccessToken.mock
}

// When sets expectation for the UsersService.AccessToken which will trigger the result defined by the following
// Then helper
func (mmAccessToken *mUsersServiceMockAccessToken) When(ctx context.Context, refreshToken string) *UsersServiceMockAccessTokenExpectation {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("UsersServiceMock.AccessToken mock is already set by Set")
	}

	expectation := &UsersServiceMockAccessTokenExpectation{
		mock:               mmAccessToken.mock,
		params:             &UsersServiceMockAccessTokenParams{ctx, refreshToken},
		expectationOrigins: UsersServiceMockAccessTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAccessToken.expectations = append(mmAccessToken.expectations, expectation)
	return expectation
}

// Then sets up UsersService.AccessToken return parameters for the expectation previously defined by the When method
func (e *UsersServiceMockAccessTokenExpectation) Then(s1 string, err error) *UsersServiceMock {
	e.results = &UsersServiceMockAccessTokenResults{s1, err}
	return e.mock
}

// Times sets number of times UsersService.AccessToken should be invoked
func (mmAccessToken *mUsersServiceMockAccessToken) Times(n uint64) *mUsersServiceMockAccessToken {
	if n == 0 {
		mmAccessToken.mock.t.Fatalf("Times of UsersServiceMock.AccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAccessToken.expectedInvocations, n)
	mmAccessToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAccessToken
}

func (mmAccessToken *mUsersServiceMockAccessToken) invocationsDone() bool {
	if len(mmAccessToken.expectations) == 0 && mmAccessToken.defaultExpectation == nil && mmAccessToken.mock.funcAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAccessToken.mock.afterAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AccessToken implements mm_service.UsersService
func (mmAccessToken *UsersServiceMock) AccessToken(ctx context.Context, refreshToken string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmAccessToken.beforeAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmAccessToken.afterAccessTokenCounter, 1)

	mmAccessToken.t.Helper()

	if mmAccessToken.inspectFuncAccessToken != nil {
		mmAccessToken.inspectFuncAccessToken(ctx, refreshToken)
	}

	mm_params := UsersServiceMockAccessTokenParams{ctx, refreshToken}

	// Record call args
	mmAccessToken.AccessTokenMock.mutex.Lock()
	mmAccessToken.AccessTokenMock.callArgs = append(mmAccessToken.AccessTokenMock.callArgs, &mm_params)
	mmAccessToken.AccessTokenMock.mutex.Unlock()

	for _, e := range mmAccessToken.AccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmAccessToken.AccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAccessToken.AccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmAccessToken.AccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmAccessToken.AccessTokenMock.defaultExpectation.paramPtrs

		mm_got := UsersServiceMockAccessTokenParams{ctx, refreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAccessToken.t.Errorf("UsersServiceMock.AccessToken got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAccessToken.AccessTokenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.refreshToken != nil && !minimock.Equal(*mm_want_ptrs.refreshToken, mm_got.refreshToken) {
				mmAccessToken.t.Errorf("UsersServiceMock.AccessToken got unexpected parameter refreshToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAccessToken.AccessTokenMock.defaultExpectation.expectationOrigins.originRefreshToken, *mm_want_ptrs.refreshToken, mm_got.refreshToken, minimock.Diff(*mm_want_ptrs.refreshToken, mm_got.refreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAccessToken.t.Errorf("UsersServiceMock.AccessToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAccessToken.AccessTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAccessToken.AccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmAccessToken.t.Fatal("No results are set for the UsersServiceMock.AccessToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmAccessToken.funcAccessToken != nil {
		return mmAccessToken.funcAccessToken(ctx, refreshToken)
	}
	mmAccessToken.t.Fatalf("Unexpected call to UsersServiceMock.AccessToken. %v %v", ctx, refreshToken)
	return
}

// AccessTokenAfterCounter returns a count of finished UsersServiceMock.AccessToken invocations
func (mmAccessToken *UsersServiceMock) AccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessToken.afterAccessTokenCounter)
}

// AccessTokenBeforeCounter returns a count of UsersServiceMock.AccessToken invocations
func (mmAccessToken *UsersServiceMock) AccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessToken.beforeAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to UsersServiceMock.AccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAccessToken *mUsersServiceMockAccessToken) Calls() []*UsersServiceMockAccessTokenParams {
	mmAccessToken.mutex.RLock()

	argCopy := make([]*UsersServiceMockAccessTokenParams, len(mmAccessToken.callArgs))
	copy(argCopy, mmAccessToken.callArgs)

	mmAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockAccessTokenDone returns true if the count of the AccessToken invocations corresponds
// the number of defined expectations
func (m *UsersServiceMock) MinimockAccessTokenDone() bool {
	if m.AccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AccessTokenMock.invocationsDone()
}

// MinimockAccessTokenInspect logs each unmet expectation
func (m *UsersServiceMock) MinimockAccessTokenInspect() {
	for _, e := range m.AccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersServiceMock.AccessToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAccessTokenCounter := mm_atomic.LoadUint64(&m.afterAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AccessTokenMock.defaultExpectation != nil && afterAccessTokenCounter < 1 {
		if m.AccessTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersServiceMock.AccessToken at\n%s", m.AccessTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersServiceMock.AccessToken at\n%s with params: %#v", m.AccessTokenMock.defaultExpectation.expectationOrigins.origin, *m.AccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccessToken != nil && afterAccessTokenCounter < 1 {
		m.t.Errorf("Expected call to UsersServiceMock.AccessToken at\n%s", m.funcAccessTokenOrigin)
	}

	if !m.AccessTokenMock.invocationsDone() && afterAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersServiceMock.AccessToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AccessTokenMock.expectedInvocations), m.AccessTokenMock.expectedInvocationsOrigin, afterAccessTokenCounter)
	}
}

type mUsersServiceMockLogin struct {
	optional           bool
	mock               *UsersServiceMock
	defaultExpectation *UsersServiceMockLoginExpectation
	expectations       []*UsersServiceMockLoginExpectation

	callArgs []*UsersServiceMockLoginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersServiceMockLoginExpectation specifies expectation struct of the UsersService.Login
type UsersServiceMockLoginExpectation struct {
	mock               *UsersServiceMock
	params             *UsersServiceMockLoginParams
	paramPtrs          *UsersServiceMockLoginParamPtrs
	expectationOrigins UsersServiceMockLoginExpectationOrigins
	results            *UsersServiceMockLoginResults
	returnOrigin       string
	Counter            uint64
}

// UsersServiceMockLoginParams contains parameters of the UsersService.Login
type UsersServiceMockLoginParams struct {
	ctx  context.Context
	user *models.User
}

// UsersServiceMockLoginParamPtrs contains pointers to parameters of the UsersService.Login
type UsersServiceMockLoginParamPtrs struct {
	ctx  *context.Context
	user **models.User
}

// UsersServiceMockLoginResults contains results of the UsersService.Login
type UsersServiceMockLoginResults struct {
	s1  string
	err error
}

// UsersServiceMockLoginOrigins contains origins of expectations of the UsersService.Login
type UsersServiceMockLoginExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mUsersServiceMockLogin) Optional() *mUsersServiceMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for UsersService.Login
func (mmLogin *mUsersServiceMockLogin) Expect(ctx context.Context, user *models.User) *mUsersServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UsersServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UsersServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.paramPtrs != nil {
		mmLogin.mock.t.Fatalf("UsersServiceMock.Login mock is already set by ExpectParams functions")
	}

	mmLogin.defaultExpectation.params = &UsersServiceMockLoginParams{ctx, user}
	mmLogin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// ExpectCtxParam1 sets up expected param ctx for UsersService.Login
func (mmLogin *mUsersServiceMockLogin) ExpectCtxParam1(ctx context.Context) *mUsersServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UsersServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UsersServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("UsersServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &UsersServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.ctx = &ctx
	mmLogin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLogin
}

// ExpectUserParam2 sets up expected param user for UsersService.Login
func (mmLogin *mUsersServiceMockLogin) ExpectUserParam2(user *models.User) *mUsersServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UsersServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UsersServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("UsersServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &UsersServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.user = &user
	mmLogin.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the UsersService.Login
func (mmLogin *mUsersServiceMockLogin) Inspect(f func(ctx context.Context, user *models.User)) *mUsersServiceMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for UsersServiceMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by UsersService.Login
func (mmLogin *mUsersServiceMockLogin) Return(s1 string, err error) *UsersServiceMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UsersServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UsersServiceMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &UsersServiceMockLoginResults{s1, err}
	mmLogin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// Set uses given function f to mock the UsersService.Login method
func (mmLogin *mUsersServiceMockLogin) Set(f func(ctx context.Context, user *models.User) (s1 string, err error)) *UsersServiceMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the UsersService.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the UsersService.Login method")
	}

	mmLogin.mock.funcLogin = f
	mmLogin.mock.funcLoginOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// When sets expectation for the UsersService.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mUsersServiceMockLogin) When(ctx context.Context, user *models.User) *UsersServiceMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UsersServiceMock.Login mock is already set by Set")
	}

	expectation := &UsersServiceMockLoginExpectation{
		mock:               mmLogin.mock,
		params:             &UsersServiceMockLoginParams{ctx, user},
		expectationOrigins: UsersServiceMockLoginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up UsersService.Login return parameters for the expectation previously defined by the When method
func (e *UsersServiceMockLoginExpectation) Then(s1 string, err error) *UsersServiceMock {
	e.results = &UsersServiceMockLoginResults{s1, err}
	return e.mock
}

// Times sets number of times UsersService.Login should be invoked
func (mmLogin *mUsersServiceMockLogin) Times(n uint64) *mUsersServiceMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of UsersServiceMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	mmLogin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogin
}

func (mmLogin *mUsersServiceMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements mm_service.UsersService
func (mmLogin *UsersServiceMock) Login(ctx context.Context, user *models.User) (s1 string, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	mmLogin.t.Helper()

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, user)
	}

	mm_params := UsersServiceMockLoginParams{ctx, user}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_want_ptrs := mmLogin.LoginMock.defaultExpectation.paramPtrs

		mm_got := UsersServiceMockLoginParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogin.t.Errorf("UsersServiceMock.Login got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmLogin.t.Errorf("UsersServiceMock.Login got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("UsersServiceMock.Login got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLogin.LoginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the UsersServiceMock.Login")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, user)
	}
	mmLogin.t.Fatalf("Unexpected call to UsersServiceMock.Login. %v %v", ctx, user)
	return
}

// LoginAfterCounter returns a count of finished UsersServiceMock.Login invocations
func (mmLogin *UsersServiceMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of UsersServiceMock.Login invocations
func (mmLogin *UsersServiceMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to UsersServiceMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mUsersServiceMockLogin) Calls() []*UsersServiceMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*UsersServiceMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *UsersServiceMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *UsersServiceMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersServiceMock.Login at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersServiceMock.Login at\n%s", m.LoginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersServiceMock.Login at\n%s with params: %#v", m.LoginMock.defaultExpectation.expectationOrigins.origin, *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Errorf("Expected call to UsersServiceMock.Login at\n%s", m.funcLoginOrigin)
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersServiceMock.Login at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), m.LoginMock.expectedInvocationsOrigin, afterLoginCounter)
	}
}

type mUsersServiceMockRegisterUser struct {
	optional           bool
	mock               *UsersServiceMock
	defaultExpectation *UsersServiceMockRegisterUserExpectation
	expectations       []*UsersServiceMockRegisterUserExpectation

	callArgs []*UsersServiceMockRegisterUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersServiceMockRegisterUserExpectation specifies expectation struct of the UsersService.RegisterUser
type UsersServiceMockRegisterUserExpectation struct {
	mock               *UsersServiceMock
	params             *UsersServiceMockRegisterUserParams
	paramPtrs          *UsersServiceMockRegisterUserParamPtrs
	expectationOrigins UsersServiceMockRegisterUserExpectationOrigins
	results            *UsersServiceMockRegisterUserResults
	returnOrigin       string
	Counter            uint64
}

// UsersServiceMockRegisterUserParams contains parameters of the UsersService.RegisterUser
type UsersServiceMockRegisterUserParams struct {
	ctx  context.Context
	user *models.User
}

// UsersServiceMockRegisterUserParamPtrs contains pointers to parameters of the UsersService.RegisterUser
type UsersServiceMockRegisterUserParamPtrs struct {
	ctx  *context.Context
	user **models.User
}

// UsersServiceMockRegisterUserResults contains results of the UsersService.RegisterUser
type UsersServiceMockRegisterUserResults struct {
	err error
}

// UsersServiceMockRegisterUserOrigins contains origins of expectations of the UsersService.RegisterUser
type UsersServiceMockRegisterUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterUser *mUsersServiceMockRegisterUser) Optional() *mUsersServiceMockRegisterUser {
	mmRegisterUser.optional = true
	return mmRegisterUser
}

// Expect sets up expected params for UsersService.RegisterUser
func (mmRegisterUser *mUsersServiceMockRegisterUser) Expect(ctx context.Context, user *models.User) *mUsersServiceMockRegisterUser {
	if mmRegisterUser.mock.funcRegisterUser != nil {
		mmRegisterUser.mock.t.Fatalf("UsersServiceMock.RegisterUser mock is already set by Set")
	}

	if mmRegisterUser.defaultExpectation == nil {
		mmRegisterUser.defaultExpectation = &UsersServiceMockRegisterUserExpectation{}
	}

	if mmRegisterUser.defaultExpectation.paramPtrs != nil {
		mmRegisterUser.mock.t.Fatalf("UsersServiceMock.RegisterUser mock is already set by ExpectParams functions")
	}

	mmRegisterUser.defaultExpectation.params = &UsersServiceMockRegisterUserParams{ctx, user}
	mmRegisterUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterUser.expectations {
		if minimock.Equal(e.params, mmRegisterUser.defaultExpectation.params) {
			mmRegisterUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterUser.defaultExpectation.params)
		}
	}

	return mmRegisterUser
}

// ExpectCtxParam1 sets up expected param ctx for UsersService.RegisterUser
func (mmRegisterUser *mUsersServiceMockRegisterUser) ExpectCtxParam1(ctx context.Context) *mUsersServiceMockRegisterUser {
	if mmRegisterUser.mock.funcRegisterUser != nil {
		mmRegisterUser.mock.t.Fatalf("UsersServiceMock.RegisterUser mock is already set by Set")
	}

	if mmRegisterUser.defaultExpectation == nil {
		mmRegisterUser.defaultExpectation = &UsersServiceMockRegisterUserExpectation{}
	}

	if mmRegisterUser.defaultExpectation.params != nil {
		mmRegisterUser.mock.t.Fatalf("UsersServiceMock.RegisterUser mock is already set by Expect")
	}

	if mmRegisterUser.defaultExpectation.paramPtrs == nil {
		mmRegisterUser.defaultExpectation.paramPtrs = &UsersServiceMockRegisterUserParamPtrs{}
	}
	mmRegisterUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmRegisterUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRegisterUser
}

// ExpectUserParam2 sets up expected param user for UsersService.RegisterUser
func (mmRegisterUser *mUsersServiceMockRegisterUser) ExpectUserParam2(user *models.User) *mUsersServiceMockRegisterUser {
	if mmRegisterUser.mock.funcRegisterUser != nil {
		mmRegisterUser.mock.t.Fatalf("UsersServiceMock.RegisterUser mock is already set by Set")
	}

	if mmRegisterUser.defaultExpectation == nil {
		mmRegisterUser.defaultExpectation = &UsersServiceMockRegisterUserExpectation{}
	}

	if mmRegisterUser.defaultExpectation.params != nil {
		mmRegisterUser.mock.t.Fatalf("UsersServiceMock.RegisterUser mock is already set by Expect")
	}

	if mmRegisterUser.defaultExpectation.paramPtrs == nil {
		mmRegisterUser.defaultExpectation.paramPtrs = &UsersServiceMockRegisterUserParamPtrs{}
	}
	mmRegisterUser.defaultExpectation.paramPtrs.user = &user
	mmRegisterUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmRegisterUser
}

// Inspect accepts an inspector function that has same arguments as the UsersService.RegisterUser
func (mmRegisterUser *mUsersServiceMockRegisterUser) Inspect(f func(ctx context.Context, user *models.User)) *mUsersServiceMockRegisterUser {
	if mmRegisterUser.mock.inspectFuncRegisterUser != nil {
		mmRegisterUser.mock.t.Fatalf("Inspect function is already set for UsersServiceMock.RegisterUser")
	}

	mmRegisterUser.mock.inspectFuncRegisterUser = f

	return mmRegisterUser
}

// Return sets up results that will be returned by UsersService.RegisterUser
func (mmRegisterUser *mUsersServiceMockRegisterUser) Return(err error) *UsersServiceMock {
	if mmRegisterUser.mock.funcRegisterUser != nil {
		mmRegisterUser.mock.t.Fatalf("UsersServiceMock.RegisterUser mock is already set by Set")
	}

	if mmRegisterUser.defaultExpectation == nil {
		mmRegisterUser.defaultExpectation = &UsersServiceMockRegisterUserExpectation{mock: mmRegisterUser.mock}
	}
	mmRegisterUser.defaultExpectation.results = &UsersServiceMockRegisterUserResults{err}
	mmRegisterUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterUser.mock
}

// Set uses given function f to mock the UsersService.RegisterUser method
func (mmRegisterUser *mUsersServiceMockRegisterUser) Set(f func(ctx context.Context, user *models.User) (err error)) *UsersServiceMock {
	if mmRegisterUser.defaultExpectation != nil {
		mmRegisterUser.mock.t.Fatalf("Default expectation is already set for the UsersService.RegisterUser method")
	}

	if len(mmRegisterUser.expectations) > 0 {
		mmRegisterUser.mock.t.Fatalf("Some expectations are already set for the UsersService.RegisterUser method")
	}

	mmRegisterUser.mock.funcRegisterUser = f
	mmRegisterUser.mock.funcRegisterUserOrigin = minimock.CallerInfo(1)
	return mmRegisterUser.mock
}

// When sets expectation for the UsersService.RegisterUser which will trigger the result defined by the following
// Then helper
func (mmRegisterUser *mUsersServiceMockRegisterUser) When(ctx context.Context, user *models.User) *UsersServiceMockRegisterUserExpectation {
	if mmRegisterUser.mock.funcRegisterUser != nil {
		mmRegisterUser.mock.t.Fatalf("UsersServiceMock.RegisterUser mock is already set by Set")
	}

	expectation := &UsersServiceMockRegisterUserExpectation{
		mock:               mmRegisterUser.mock,
		params:             &UsersServiceMockRegisterUserParams{ctx, user},
		expectationOrigins: UsersServiceMockRegisterUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterUser.expectations = append(mmRegisterUser.expectations, expectation)
	return expectation
}

// Then sets up UsersService.RegisterUser return parameters for the expectation previously defined by the When method
func (e *UsersServiceMockRegisterUserExpectation) Then(err error) *UsersServiceMock {
	e.results = &UsersServiceMockRegisterUserResults{err}
	return e.mock
}

// Times sets number of times UsersService.RegisterUser should be invoked
func (mmRegisterUser *mUsersServiceMockRegisterUser) Times(n uint64) *mUsersServiceMockRegisterUser {
	if n == 0 {
		mmRegisterUser.mock.t.Fatalf("Times of UsersServiceMock.RegisterUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterUser.expectedInvocations, n)
	mmRegisterUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterUser
}

func (mmRegisterUser *mUsersServiceMockRegisterUser) invocationsDone() bool {
	if len(mmRegisterUser.expectations) == 0 && mmRegisterUser.defaultExpectation == nil && mmRegisterUser.mock.funcRegisterUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterUser.mock.afterRegisterUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterUser implements mm_service.UsersService
func (mmRegisterUser *UsersServiceMock) RegisterUser(ctx context.Context, user *models.User) (err error) {
	mm_atomic.AddUint64(&mmRegisterUser.beforeRegisterUserCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterUser.afterRegisterUserCounter, 1)

	mmRegisterUser.t.Helper()

	if mmRegisterUser.inspectFuncRegisterUser != nil {
		mmRegisterUser.inspectFuncRegisterUser(ctx, user)
	}

	mm_params := UsersServiceMockRegisterUserParams{ctx, user}

	// Record call args
	mmRegisterUser.RegisterUserMock.mutex.Lock()
	mmRegisterUser.RegisterUserMock.callArgs = append(mmRegisterUser.RegisterUserMock.callArgs, &mm_params)
	mmRegisterUser.RegisterUserMock.mutex.Unlock()

	for _, e := range mmRegisterUser.RegisterUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRegisterUser.RegisterUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterUser.RegisterUserMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterUser.RegisterUserMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterUser.RegisterUserMock.defaultExpectation.paramPtrs

		mm_got := UsersServiceMockRegisterUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRegisterUser.t.Errorf("UsersServiceMock.RegisterUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterUser.RegisterUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmRegisterUser.t.Errorf("UsersServiceMock.RegisterUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterUser.RegisterUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterUser.t.Errorf("UsersServiceMock.RegisterUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterUser.RegisterUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterUser.RegisterUserMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterUser.t.Fatal("No results are set for the UsersServiceMock.RegisterUser")
		}
		return (*mm_results).err
	}
	if mmRegisterUser.funcRegisterUser != nil {
		return mmRegisterUser.funcRegisterUser(ctx, user)
	}
	mmRegisterUser.t.Fatalf("Unexpected call to UsersServiceMock.RegisterUser. %v %v", ctx, user)
	return
}

// RegisterUserAfterCounter returns a count of finished UsersServiceMock.RegisterUser invocations
func (mmRegisterUser *UsersServiceMock) RegisterUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterUser.afterRegisterUserCounter)
}

// RegisterUserBeforeCounter returns a count of UsersServiceMock.RegisterUser invocations
func (mmRegisterUser *UsersServiceMock) RegisterUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterUser.beforeRegisterUserCounter)
}

// Calls returns a list of arguments used in each call to UsersServiceMock.RegisterUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterUser *mUsersServiceMockRegisterUser) Calls() []*UsersServiceMockRegisterUserParams {
	mmRegisterUser.mutex.RLock()

	argCopy := make([]*UsersServiceMockRegisterUserParams, len(mmRegisterUser.callArgs))
	copy(argCopy, mmRegisterUser.callArgs)

	mmRegisterUser.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterUserDone returns true if the count of the RegisterUser invocations corresponds
// the number of defined expectations
func (m *UsersServiceMock) MinimockRegisterUserDone() bool {
	if m.RegisterUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterUserMock.invocationsDone()
}

// MinimockRegisterUserInspect logs each unmet expectation
func (m *UsersServiceMock) MinimockRegisterUserInspect() {
	for _, e := range m.RegisterUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersServiceMock.RegisterUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterUserCounter := mm_atomic.LoadUint64(&m.afterRegisterUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterUserMock.defaultExpectation != nil && afterRegisterUserCounter < 1 {
		if m.RegisterUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersServiceMock.RegisterUser at\n%s", m.RegisterUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersServiceMock.RegisterUser at\n%s with params: %#v", m.RegisterUserMock.defaultExpectation.expectationOrigins.origin, *m.RegisterUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterUser != nil && afterRegisterUserCounter < 1 {
		m.t.Errorf("Expected call to UsersServiceMock.RegisterUser at\n%s", m.funcRegisterUserOrigin)
	}

	if !m.RegisterUserMock.invocationsDone() && afterRegisterUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersServiceMock.RegisterUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterUserMock.expectedInvocations), m.RegisterUserMock.expectedInvocationsOrigin, afterRegisterUserCounter)
	}
}

type mUsersServiceMockUpdateUser struct {
	optional           bool
	mock               *UsersServiceMock
	defaultExpectation *UsersServiceMockUpdateUserExpectation
	expectations       []*UsersServiceMockUpdateUserExpectation

	callArgs []*UsersServiceMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersServiceMockUpdateUserExpectation specifies expectation struct of the UsersService.UpdateUser
type UsersServiceMockUpdateUserExpectation struct {
	mock               *UsersServiceMock
	params             *UsersServiceMockUpdateUserParams
	paramPtrs          *UsersServiceMockUpdateUserParamPtrs
	expectationOrigins UsersServiceMockUpdateUserExpectationOrigins
	results            *UsersServiceMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// UsersServiceMockUpdateUserParams contains parameters of the UsersService.UpdateUser
type UsersServiceMockUpdateUserParams struct {
	ctx  context.Context
	user *models.User
}

// UsersServiceMockUpdateUserParamPtrs contains pointers to parameters of the UsersService.UpdateUser
type UsersServiceMockUpdateUserParamPtrs struct {
	ctx  *context.Context
	user **models.User
}

// UsersServiceMockUpdateUserResults contains results of the UsersService.UpdateUser
type UsersServiceMockUpdateUserResults struct {
	err error
}

// UsersServiceMockUpdateUserOrigins contains origins of expectations of the UsersService.UpdateUser
type UsersServiceMockUpdateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mUsersServiceMockUpdateUser) Optional() *mUsersServiceMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for UsersService.UpdateUser
func (mmUpdateUser *mUsersServiceMockUpdateUser) Expect(ctx context.Context, user *models.User) *mUsersServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UsersServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UsersServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("UsersServiceMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &UsersServiceMockUpdateUserParams{ctx, user}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for UsersService.UpdateUser
func (mmUpdateUser *mUsersServiceMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mUsersServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UsersServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UsersServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UsersServiceMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UsersServiceMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectUserParam2 sets up expected param user for UsersService.UpdateUser
func (mmUpdateUser *mUsersServiceMockUpdateUser) ExpectUserParam2(user *models.User) *mUsersServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UsersServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UsersServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UsersServiceMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UsersServiceMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.user = &user
	mmUpdateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the UsersService.UpdateUser
func (mmUpdateUser *mUsersServiceMockUpdateUser) Inspect(f func(ctx context.Context, user *models.User)) *mUsersServiceMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for UsersServiceMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by UsersService.UpdateUser
func (mmUpdateUser *mUsersServiceMockUpdateUser) Return(err error) *UsersServiceMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UsersServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UsersServiceMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &UsersServiceMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the UsersService.UpdateUser method
func (mmUpdateUser *mUsersServiceMockUpdateUser) Set(f func(ctx context.Context, user *models.User) (err error)) *UsersServiceMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the UsersService.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the UsersService.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the UsersService.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mUsersServiceMockUpdateUser) When(ctx context.Context, user *models.User) *UsersServiceMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UsersServiceMock.UpdateUser mock is already set by Set")
	}

	expectation := &UsersServiceMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &UsersServiceMockUpdateUserParams{ctx, user},
		expectationOrigins: UsersServiceMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up UsersService.UpdateUser return parameters for the expectation previously defined by the When method
func (e *UsersServiceMockUpdateUserExpectation) Then(err error) *UsersServiceMock {
	e.results = &UsersServiceMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times UsersService.UpdateUser should be invoked
func (mmUpdateUser *mUsersServiceMockUpdateUser) Times(n uint64) *mUsersServiceMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of UsersServiceMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mUsersServiceMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_service.UsersService
func (mmUpdateUser *UsersServiceMock) UpdateUser(ctx context.Context, user *models.User) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, user)
	}

	mm_params := UsersServiceMockUpdateUserParams{ctx, user}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := UsersServiceMockUpdateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("UsersServiceMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmUpdateUser.t.Errorf("UsersServiceMock.UpdateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("UsersServiceMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the UsersServiceMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, user)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to UsersServiceMock.UpdateUser. %v %v", ctx, user)
	return
}

// UpdateUserAfterCounter returns a count of finished UsersServiceMock.UpdateUser invocations
func (mmUpdateUser *UsersServiceMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of UsersServiceMock.UpdateUser invocations
func (mmUpdateUser *UsersServiceMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to UsersServiceMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mUsersServiceMockUpdateUser) Calls() []*UsersServiceMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*UsersServiceMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *UsersServiceMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *UsersServiceMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersServiceMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersServiceMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersServiceMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to UsersServiceMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersServiceMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

type mUsersServiceMockUser struct {
	optional           bool
	mock               *UsersServiceMock
	defaultExpectation *UsersServiceMockUserExpectation
	expectations       []*UsersServiceMockUserExpectation

	callArgs []*UsersServiceMockUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersServiceMockUserExpectation specifies expectation struct of the UsersService.User
type UsersServiceMockUserExpectation struct {
	mock               *UsersServiceMock
	params             *UsersServiceMockUserParams
	paramPtrs          *UsersServiceMockUserParamPtrs
	expectationOrigins UsersServiceMockUserExpectationOrigins
	results            *UsersServiceMockUserResults
	returnOrigin       string
	Counter            uint64
}

// UsersServiceMockUserParams contains parameters of the UsersService.User
type UsersServiceMockUserParams struct {
	ctx       context.Context
	userEmail string
}

// UsersServiceMockUserParamPtrs contains pointers to parameters of the UsersService.User
type UsersServiceMockUserParamPtrs struct {
	ctx       *context.Context
	userEmail *string
}

// UsersServiceMockUserResults contains results of the UsersService.User
type UsersServiceMockUserResults struct {
	up1 *models.User
	err error
}

// UsersServiceMockUserOrigins contains origins of expectations of the UsersService.User
type UsersServiceMockUserExpectationOrigins struct {
	origin          string
	originCtx       string
	originUserEmail string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUser *mUsersServiceMockUser) Optional() *mUsersServiceMockUser {
	mmUser.optional = true
	return mmUser
}

// Expect sets up expected params for UsersService.User
func (mmUser *mUsersServiceMockUser) Expect(ctx context.Context, userEmail string) *mUsersServiceMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UsersServiceMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &UsersServiceMockUserExpectation{}
	}

	if mmUser.defaultExpectation.paramPtrs != nil {
		mmUser.mock.t.Fatalf("UsersServiceMock.User mock is already set by ExpectParams functions")
	}

	mmUser.defaultExpectation.params = &UsersServiceMockUserParams{ctx, userEmail}
	mmUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUser.expectations {
		if minimock.Equal(e.params, mmUser.defaultExpectation.params) {
			mmUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUser.defaultExpectation.params)
		}
	}

	return mmUser
}

// ExpectCtxParam1 sets up expected param ctx for UsersService.User
func (mmUser *mUsersServiceMockUser) ExpectCtxParam1(ctx context.Context) *mUsersServiceMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UsersServiceMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &UsersServiceMockUserExpectation{}
	}

	if mmUser.defaultExpectation.params != nil {
		mmUser.mock.t.Fatalf("UsersServiceMock.User mock is already set by Expect")
	}

	if mmUser.defaultExpectation.paramPtrs == nil {
		mmUser.defaultExpectation.paramPtrs = &UsersServiceMockUserParamPtrs{}
	}
	mmUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUser
}

// ExpectUserEmailParam2 sets up expected param userEmail for UsersService.User
func (mmUser *mUsersServiceMockUser) ExpectUserEmailParam2(userEmail string) *mUsersServiceMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UsersServiceMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &UsersServiceMockUserExpectation{}
	}

	if mmUser.defaultExpectation.params != nil {
		mmUser.mock.t.Fatalf("UsersServiceMock.User mock is already set by Expect")
	}

	if mmUser.defaultExpectation.paramPtrs == nil {
		mmUser.defaultExpectation.paramPtrs = &UsersServiceMockUserParamPtrs{}
	}
	mmUser.defaultExpectation.paramPtrs.userEmail = &userEmail
	mmUser.defaultExpectation.expectationOrigins.originUserEmail = minimock.CallerInfo(1)

	return mmUser
}

// Inspect accepts an inspector function that has same arguments as the UsersService.User
func (mmUser *mUsersServiceMockUser) Inspect(f func(ctx context.Context, userEmail string)) *mUsersServiceMockUser {
	if mmUser.mock.inspectFuncUser != nil {
		mmUser.mock.t.Fatalf("Inspect function is already set for UsersServiceMock.User")
	}

	mmUser.mock.inspectFuncUser = f

	return mmUser
}

// Return sets up results that will be returned by UsersService.User
func (mmUser *mUsersServiceMockUser) Return(up1 *models.User, err error) *UsersServiceMock {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UsersServiceMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &UsersServiceMockUserExpectation{mock: mmUser.mock}
	}
	mmUser.defaultExpectation.results = &UsersServiceMockUserResults{up1, err}
	mmUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUser.mock
}

// Set uses given function f to mock the UsersService.User method
func (mmUser *mUsersServiceMockUser) Set(f func(ctx context.Context, userEmail string) (up1 *models.User, err error)) *UsersServiceMock {
	if mmUser.defaultExpectation != nil {
		mmUser.mock.t.Fatalf("Default expectation is already set for the UsersService.User method")
	}

	if len(mmUser.expectations) > 0 {
		mmUser.mock.t.Fatalf("Some expectations are already set for the UsersService.User method")
	}

	mmUser.mock.funcUser = f
	mmUser.mock.funcUserOrigin = minimock.CallerInfo(1)
	return mmUser.mock
}

// When sets expectation for the UsersService.User which will trigger the result defined by the following
// Then helper
func (mmUser *mUsersServiceMockUser) When(ctx context.Context, userEmail string) *UsersServiceMockUserExpectation {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UsersServiceMock.User mock is already set by Set")
	}

	expectation := &UsersServiceMockUserExpectation{
		mock:               mmUser.mock,
		params:             &UsersServiceMockUserParams{ctx, userEmail},
		expectationOrigins: UsersServiceMockUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUser.expectations = append(mmUser.expectations, expectation)
	return expectation
}

// Then sets up UsersService.User return parameters for the expectation previously defined by the When method
func (e *UsersServiceMockUserExpectation) Then(up1 *models.User, err error) *UsersServiceMock {
	e.results = &UsersServiceMockUserResults{up1, err}
	return e.mock
}

// Times sets number of times UsersService.User should be invoked
func (mmUser *mUsersServiceMockUser) Times(n uint64) *mUsersServiceMockUser {
	if n == 0 {
		mmUser.mock.t.Fatalf("Times of UsersServiceMock.User mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUser.expectedInvocations, n)
	mmUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUser
}

func (mmUser *mUsersServiceMockUser) invocationsDone() bool {
	if len(mmUser.expectations) == 0 && mmUser.defaultExpectation == nil && mmUser.mock.funcUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUser.mock.afterUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// User implements mm_service.UsersService
func (mmUser *UsersServiceMock) User(ctx context.Context, userEmail string) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmUser.beforeUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUser.afterUserCounter, 1)

	mmUser.t.Helper()

	if mmUser.inspectFuncUser != nil {
		mmUser.inspectFuncUser(ctx, userEmail)
	}

	mm_params := UsersServiceMockUserParams{ctx, userEmail}

	// Record call args
	mmUser.UserMock.mutex.Lock()
	mmUser.UserMock.callArgs = append(mmUser.UserMock.callArgs, &mm_params)
	mmUser.UserMock.mutex.Unlock()

	for _, e := range mmUser.UserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUser.UserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUser.UserMock.defaultExpectation.Counter, 1)
		mm_want := mmUser.UserMock.defaultExpectation.params
		mm_want_ptrs := mmUser.UserMock.defaultExpectation.paramPtrs

		mm_got := UsersServiceMockUserParams{ctx, userEmail}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUser.t.Errorf("UsersServiceMock.User got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUser.UserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userEmail != nil && !minimock.Equal(*mm_want_ptrs.userEmail, mm_got.userEmail) {
				mmUser.t.Errorf("UsersServiceMock.User got unexpected parameter userEmail, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUser.UserMock.defaultExpectation.expectationOrigins.originUserEmail, *mm_want_ptrs.userEmail, mm_got.userEmail, minimock.Diff(*mm_want_ptrs.userEmail, mm_got.userEmail))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUser.t.Errorf("UsersServiceMock.User got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUser.UserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUser.UserMock.defaultExpectation.results
		if mm_results == nil {
			mmUser.t.Fatal("No results are set for the UsersServiceMock.User")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUser.funcUser != nil {
		return mmUser.funcUser(ctx, userEmail)
	}
	mmUser.t.Fatalf("Unexpected call to UsersServiceMock.User. %v %v", ctx, userEmail)
	return
}

// UserAfterCounter returns a count of finished UsersServiceMock.User invocations
func (mmUser *UsersServiceMock) UserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.afterUserCounter)
}

// UserBeforeCounter returns a count of UsersServiceMock.User invocations
func (mmUser *UsersServiceMock) UserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.beforeUserCounter)
}

// Calls returns a list of arguments used in each call to UsersServiceMock.User.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUser *mUsersServiceMockUser) Calls() []*UsersServiceMockUserParams {
	mmUser.mutex.RLock()

	argCopy := make([]*UsersServiceMockUserParams, len(mmUser.callArgs))
	copy(argCopy, mmUser.callArgs)

	mmUser.mutex.RUnlock()

	return argCopy
}

// MinimockUserDone returns true if the count of the User invocations corresponds
// the number of defined expectations
func (m *UsersServiceMock) MinimockUserDone() bool {
	if m.UserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserMock.invocationsDone()
}

// MinimockUserInspect logs each unmet expectation
func (m *UsersServiceMock) MinimockUserInspect() {
	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersServiceMock.User at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserCounter := mm_atomic.LoadUint64(&m.afterUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserMock.defaultExpectation != nil && afterUserCounter < 1 {
		if m.UserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersServiceMock.User at\n%s", m.UserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersServiceMock.User at\n%s with params: %#v", m.UserMock.defaultExpectation.expectationOrigins.origin, *m.UserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUser != nil && afterUserCounter < 1 {
		m.t.Errorf("Expected call to UsersServiceMock.User at\n%s", m.funcUserOrigin)
	}

	if !m.UserMock.invocationsDone() && afterUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersServiceMock.User at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserMock.expectedInvocations), m.UserMock.expectedInvocationsOrigin, afterUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UsersServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAccessTokenInspect()

			m.MinimockLoginInspect()

			m.MinimockRegisterUserInspect()

			m.MinimockUpdateUserInspect()

			m.MinimockUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UsersServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UsersServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAccessTokenDone() &&
		m.MinimockLoginDone() &&
		m.MinimockRegisterUserDone() &&
		m.MinimockUpdateUserDone() &&
		m.MinimockUserDone()
}
