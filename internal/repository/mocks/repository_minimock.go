// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/wDRxxx/eventflow-backend/internal/repository.Repository -o repository_minimock.go -n RepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/wDRxxx/eventflow-backend/internal/models"
)

// RepositoryMock implements mm_repository.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeleteEvent          func(ctx context.Context, urlTitle string) (err error)
	funcDeleteEventOrigin    string
	inspectFuncDeleteEvent   func(ctx context.Context, urlTitle string)
	afterDeleteEventCounter  uint64
	beforeDeleteEventCounter uint64
	DeleteEventMock          mRepositoryMockDeleteEvent

	funcEventByURLTitle          func(ctx context.Context, urlTitle string) (ep1 *models.Event, err error)
	funcEventByURLTitleOrigin    string
	inspectFuncEventByURLTitle   func(ctx context.Context, urlTitle string)
	afterEventByURLTitleCounter  uint64
	beforeEventByURLTitleCounter uint64
	EventByURLTitleMock          mRepositoryMockEventByURLTitle

	funcEvents          func(ctx context.Context, page int) (epa1 []*models.Event, err error)
	funcEventsOrigin    string
	inspectFuncEvents   func(ctx context.Context, page int)
	afterEventsCounter  uint64
	beforeEventsCounter uint64
	EventsMock          mRepositoryMockEvents

	funcInsertEvent          func(ctx context.Context, event *models.Event) (i1 int64, err error)
	funcInsertEventOrigin    string
	inspectFuncInsertEvent   func(ctx context.Context, event *models.Event)
	afterInsertEventCounter  uint64
	beforeInsertEventCounter uint64
	InsertEventMock          mRepositoryMockInsertEvent

	funcInsertTicket          func(ctx context.Context, ticket *models.Ticket) (s1 string, err error)
	funcInsertTicketOrigin    string
	inspectFuncInsertTicket   func(ctx context.Context, ticket *models.Ticket)
	afterInsertTicketCounter  uint64
	beforeInsertTicketCounter uint64
	InsertTicketMock          mRepositoryMockInsertTicket

	funcInsertUser          func(ctx context.Context, user *models.User) (i1 int64, err error)
	funcInsertUserOrigin    string
	inspectFuncInsertUser   func(ctx context.Context, user *models.User)
	afterInsertUserCounter  uint64
	beforeInsertUserCounter uint64
	InsertUserMock          mRepositoryMockInsertUser

	funcTicket          func(ctx context.Context, ticketID string) (tp1 *models.Ticket, err error)
	funcTicketOrigin    string
	inspectFuncTicket   func(ctx context.Context, ticketID string)
	afterTicketCounter  uint64
	beforeTicketCounter uint64
	TicketMock          mRepositoryMockTicket

	funcUpdateEvent          func(ctx context.Context, event *models.Event) (err error)
	funcUpdateEventOrigin    string
	inspectFuncUpdateEvent   func(ctx context.Context, event *models.Event)
	afterUpdateEventCounter  uint64
	beforeUpdateEventCounter uint64
	UpdateEventMock          mRepositoryMockUpdateEvent

	funcUpdateUserTGUsername          func(ctx context.Context, userID int64, username string) (err error)
	funcUpdateUserTGUsernameOrigin    string
	inspectFuncUpdateUserTGUsername   func(ctx context.Context, userID int64, username string)
	afterUpdateUserTGUsernameCounter  uint64
	beforeUpdateUserTGUsernameCounter uint64
	UpdateUserTGUsernameMock          mRepositoryMockUpdateUserTGUsername

	funcUpdateYookassaSettings          func(ctx context.Context, settings *models.YookassaSettings) (err error)
	funcUpdateYookassaSettingsOrigin    string
	inspectFuncUpdateYookassaSettings   func(ctx context.Context, settings *models.YookassaSettings)
	afterUpdateYookassaSettingsCounter  uint64
	beforeUpdateYookassaSettingsCounter uint64
	UpdateYookassaSettingsMock          mRepositoryMockUpdateYookassaSettings

	funcUser          func(ctx context.Context, userEmail string) (up1 *models.User, err error)
	funcUserOrigin    string
	inspectFuncUser   func(ctx context.Context, userEmail string)
	afterUserCounter  uint64
	beforeUserCounter uint64
	UserMock          mRepositoryMockUser

	funcUserEvents          func(ctx context.Context, userID int64) (epa1 []*models.Event, err error)
	funcUserEventsOrigin    string
	inspectFuncUserEvents   func(ctx context.Context, userID int64)
	afterUserEventsCounter  uint64
	beforeUserEventsCounter uint64
	UserEventsMock          mRepositoryMockUserEvents

	funcUserTickets          func(ctx context.Context, userID int64) (tpa1 []*models.Ticket, err error)
	funcUserTicketsOrigin    string
	inspectFuncUserTickets   func(ctx context.Context, userID int64)
	afterUserTicketsCounter  uint64
	beforeUserTicketsCounter uint64
	UserTicketsMock          mRepositoryMockUserTickets
}

// NewRepositoryMock returns a mock for mm_repository.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteEventMock = mRepositoryMockDeleteEvent{mock: m}
	m.DeleteEventMock.callArgs = []*RepositoryMockDeleteEventParams{}

	m.EventByURLTitleMock = mRepositoryMockEventByURLTitle{mock: m}
	m.EventByURLTitleMock.callArgs = []*RepositoryMockEventByURLTitleParams{}

	m.EventsMock = mRepositoryMockEvents{mock: m}
	m.EventsMock.callArgs = []*RepositoryMockEventsParams{}

	m.InsertEventMock = mRepositoryMockInsertEvent{mock: m}
	m.InsertEventMock.callArgs = []*RepositoryMockInsertEventParams{}

	m.InsertTicketMock = mRepositoryMockInsertTicket{mock: m}
	m.InsertTicketMock.callArgs = []*RepositoryMockInsertTicketParams{}

	m.InsertUserMock = mRepositoryMockInsertUser{mock: m}
	m.InsertUserMock.callArgs = []*RepositoryMockInsertUserParams{}

	m.TicketMock = mRepositoryMockTicket{mock: m}
	m.TicketMock.callArgs = []*RepositoryMockTicketParams{}

	m.UpdateEventMock = mRepositoryMockUpdateEvent{mock: m}
	m.UpdateEventMock.callArgs = []*RepositoryMockUpdateEventParams{}

	m.UpdateUserTGUsernameMock = mRepositoryMockUpdateUserTGUsername{mock: m}
	m.UpdateUserTGUsernameMock.callArgs = []*RepositoryMockUpdateUserTGUsernameParams{}

	m.UpdateYookassaSettingsMock = mRepositoryMockUpdateYookassaSettings{mock: m}
	m.UpdateYookassaSettingsMock.callArgs = []*RepositoryMockUpdateYookassaSettingsParams{}

	m.UserMock = mRepositoryMockUser{mock: m}
	m.UserMock.callArgs = []*RepositoryMockUserParams{}

	m.UserEventsMock = mRepositoryMockUserEvents{mock: m}
	m.UserEventsMock.callArgs = []*RepositoryMockUserEventsParams{}

	m.UserTicketsMock = mRepositoryMockUserTickets{mock: m}
	m.UserTicketsMock.callArgs = []*RepositoryMockUserTicketsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockDeleteEvent struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteEventExpectation
	expectations       []*RepositoryMockDeleteEventExpectation

	callArgs []*RepositoryMockDeleteEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteEventExpectation specifies expectation struct of the Repository.DeleteEvent
type RepositoryMockDeleteEventExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteEventParams
	paramPtrs          *RepositoryMockDeleteEventParamPtrs
	expectationOrigins RepositoryMockDeleteEventExpectationOrigins
	results            *RepositoryMockDeleteEventResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteEventParams contains parameters of the Repository.DeleteEvent
type RepositoryMockDeleteEventParams struct {
	ctx      context.Context
	urlTitle string
}

// RepositoryMockDeleteEventParamPtrs contains pointers to parameters of the Repository.DeleteEvent
type RepositoryMockDeleteEventParamPtrs struct {
	ctx      *context.Context
	urlTitle *string
}

// RepositoryMockDeleteEventResults contains results of the Repository.DeleteEvent
type RepositoryMockDeleteEventResults struct {
	err error
}

// RepositoryMockDeleteEventOrigins contains origins of expectations of the Repository.DeleteEvent
type RepositoryMockDeleteEventExpectationOrigins struct {
	origin         string
	originCtx      string
	originUrlTitle string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteEvent *mRepositoryMockDeleteEvent) Optional() *mRepositoryMockDeleteEvent {
	mmDeleteEvent.optional = true
	return mmDeleteEvent
}

// Expect sets up expected params for Repository.DeleteEvent
func (mmDeleteEvent *mRepositoryMockDeleteEvent) Expect(ctx context.Context, urlTitle string) *mRepositoryMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("RepositoryMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &RepositoryMockDeleteEventExpectation{}
	}

	if mmDeleteEvent.defaultExpectation.paramPtrs != nil {
		mmDeleteEvent.mock.t.Fatalf("RepositoryMock.DeleteEvent mock is already set by ExpectParams functions")
	}

	mmDeleteEvent.defaultExpectation.params = &RepositoryMockDeleteEventParams{ctx, urlTitle}
	mmDeleteEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteEvent.expectations {
		if minimock.Equal(e.params, mmDeleteEvent.defaultExpectation.params) {
			mmDeleteEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEvent.defaultExpectation.params)
		}
	}

	return mmDeleteEvent
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteEvent
func (mmDeleteEvent *mRepositoryMockDeleteEvent) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("RepositoryMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &RepositoryMockDeleteEventExpectation{}
	}

	if mmDeleteEvent.defaultExpectation.params != nil {
		mmDeleteEvent.mock.t.Fatalf("RepositoryMock.DeleteEvent mock is already set by Expect")
	}

	if mmDeleteEvent.defaultExpectation.paramPtrs == nil {
		mmDeleteEvent.defaultExpectation.paramPtrs = &RepositoryMockDeleteEventParamPtrs{}
	}
	mmDeleteEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteEvent
}

// ExpectUrlTitleParam2 sets up expected param urlTitle for Repository.DeleteEvent
func (mmDeleteEvent *mRepositoryMockDeleteEvent) ExpectUrlTitleParam2(urlTitle string) *mRepositoryMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("RepositoryMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &RepositoryMockDeleteEventExpectation{}
	}

	if mmDeleteEvent.defaultExpectation.params != nil {
		mmDeleteEvent.mock.t.Fatalf("RepositoryMock.DeleteEvent mock is already set by Expect")
	}

	if mmDeleteEvent.defaultExpectation.paramPtrs == nil {
		mmDeleteEvent.defaultExpectation.paramPtrs = &RepositoryMockDeleteEventParamPtrs{}
	}
	mmDeleteEvent.defaultExpectation.paramPtrs.urlTitle = &urlTitle
	mmDeleteEvent.defaultExpectation.expectationOrigins.originUrlTitle = minimock.CallerInfo(1)

	return mmDeleteEvent
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteEvent
func (mmDeleteEvent *mRepositoryMockDeleteEvent) Inspect(f func(ctx context.Context, urlTitle string)) *mRepositoryMockDeleteEvent {
	if mmDeleteEvent.mock.inspectFuncDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteEvent")
	}

	mmDeleteEvent.mock.inspectFuncDeleteEvent = f

	return mmDeleteEvent
}

// Return sets up results that will be returned by Repository.DeleteEvent
func (mmDeleteEvent *mRepositoryMockDeleteEvent) Return(err error) *RepositoryMock {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("RepositoryMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &RepositoryMockDeleteEventExpectation{mock: mmDeleteEvent.mock}
	}
	mmDeleteEvent.defaultExpectation.results = &RepositoryMockDeleteEventResults{err}
	mmDeleteEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteEvent.mock
}

// Set uses given function f to mock the Repository.DeleteEvent method
func (mmDeleteEvent *mRepositoryMockDeleteEvent) Set(f func(ctx context.Context, urlTitle string) (err error)) *RepositoryMock {
	if mmDeleteEvent.defaultExpectation != nil {
		mmDeleteEvent.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteEvent method")
	}

	if len(mmDeleteEvent.expectations) > 0 {
		mmDeleteEvent.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteEvent method")
	}

	mmDeleteEvent.mock.funcDeleteEvent = f
	mmDeleteEvent.mock.funcDeleteEventOrigin = minimock.CallerInfo(1)
	return mmDeleteEvent.mock
}

// When sets expectation for the Repository.DeleteEvent which will trigger the result defined by the following
// Then helper
func (mmDeleteEvent *mRepositoryMockDeleteEvent) When(ctx context.Context, urlTitle string) *RepositoryMockDeleteEventExpectation {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("RepositoryMock.DeleteEvent mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteEventExpectation{
		mock:               mmDeleteEvent.mock,
		params:             &RepositoryMockDeleteEventParams{ctx, urlTitle},
		expectationOrigins: RepositoryMockDeleteEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteEvent.expectations = append(mmDeleteEvent.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteEvent return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteEventExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteEventResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteEvent should be invoked
func (mmDeleteEvent *mRepositoryMockDeleteEvent) Times(n uint64) *mRepositoryMockDeleteEvent {
	if n == 0 {
		mmDeleteEvent.mock.t.Fatalf("Times of RepositoryMock.DeleteEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEvent.expectedInvocations, n)
	mmDeleteEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteEvent
}

func (mmDeleteEvent *mRepositoryMockDeleteEvent) invocationsDone() bool {
	if len(mmDeleteEvent.expectations) == 0 && mmDeleteEvent.defaultExpectation == nil && mmDeleteEvent.mock.funcDeleteEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEvent.mock.afterDeleteEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEvent implements mm_repository.Repository
func (mmDeleteEvent *RepositoryMock) DeleteEvent(ctx context.Context, urlTitle string) (err error) {
	mm_atomic.AddUint64(&mmDeleteEvent.beforeDeleteEventCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEvent.afterDeleteEventCounter, 1)

	mmDeleteEvent.t.Helper()

	if mmDeleteEvent.inspectFuncDeleteEvent != nil {
		mmDeleteEvent.inspectFuncDeleteEvent(ctx, urlTitle)
	}

	mm_params := RepositoryMockDeleteEventParams{ctx, urlTitle}

	// Record call args
	mmDeleteEvent.DeleteEventMock.mutex.Lock()
	mmDeleteEvent.DeleteEventMock.callArgs = append(mmDeleteEvent.DeleteEventMock.callArgs, &mm_params)
	mmDeleteEvent.DeleteEventMock.mutex.Unlock()

	for _, e := range mmDeleteEvent.DeleteEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEvent.DeleteEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEvent.DeleteEventMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEvent.DeleteEventMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEvent.DeleteEventMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteEventParams{ctx, urlTitle}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEvent.t.Errorf("RepositoryMock.DeleteEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEvent.DeleteEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.urlTitle != nil && !minimock.Equal(*mm_want_ptrs.urlTitle, mm_got.urlTitle) {
				mmDeleteEvent.t.Errorf("RepositoryMock.DeleteEvent got unexpected parameter urlTitle, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEvent.DeleteEventMock.defaultExpectation.expectationOrigins.originUrlTitle, *mm_want_ptrs.urlTitle, mm_got.urlTitle, minimock.Diff(*mm_want_ptrs.urlTitle, mm_got.urlTitle))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEvent.t.Errorf("RepositoryMock.DeleteEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteEvent.DeleteEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEvent.DeleteEventMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEvent.t.Fatal("No results are set for the RepositoryMock.DeleteEvent")
		}
		return (*mm_results).err
	}
	if mmDeleteEvent.funcDeleteEvent != nil {
		return mmDeleteEvent.funcDeleteEvent(ctx, urlTitle)
	}
	mmDeleteEvent.t.Fatalf("Unexpected call to RepositoryMock.DeleteEvent. %v %v", ctx, urlTitle)
	return
}

// DeleteEventAfterCounter returns a count of finished RepositoryMock.DeleteEvent invocations
func (mmDeleteEvent *RepositoryMock) DeleteEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEvent.afterDeleteEventCounter)
}

// DeleteEventBeforeCounter returns a count of RepositoryMock.DeleteEvent invocations
func (mmDeleteEvent *RepositoryMock) DeleteEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEvent.beforeDeleteEventCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEvent *mRepositoryMockDeleteEvent) Calls() []*RepositoryMockDeleteEventParams {
	mmDeleteEvent.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteEventParams, len(mmDeleteEvent.callArgs))
	copy(argCopy, mmDeleteEvent.callArgs)

	mmDeleteEvent.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEventDone returns true if the count of the DeleteEvent invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteEventDone() bool {
	if m.DeleteEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEventMock.invocationsDone()
}

// MinimockDeleteEventInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteEventInspect() {
	for _, e := range m.DeleteEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteEventCounter := mm_atomic.LoadUint64(&m.afterDeleteEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEventMock.defaultExpectation != nil && afterDeleteEventCounter < 1 {
		if m.DeleteEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEvent at\n%s", m.DeleteEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEvent at\n%s with params: %#v", m.DeleteEventMock.defaultExpectation.expectationOrigins.origin, *m.DeleteEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEvent != nil && afterDeleteEventCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteEvent at\n%s", m.funcDeleteEventOrigin)
	}

	if !m.DeleteEventMock.invocationsDone() && afterDeleteEventCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEventMock.expectedInvocations), m.DeleteEventMock.expectedInvocationsOrigin, afterDeleteEventCounter)
	}
}

type mRepositoryMockEventByURLTitle struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockEventByURLTitleExpectation
	expectations       []*RepositoryMockEventByURLTitleExpectation

	callArgs []*RepositoryMockEventByURLTitleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockEventByURLTitleExpectation specifies expectation struct of the Repository.EventByURLTitle
type RepositoryMockEventByURLTitleExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockEventByURLTitleParams
	paramPtrs          *RepositoryMockEventByURLTitleParamPtrs
	expectationOrigins RepositoryMockEventByURLTitleExpectationOrigins
	results            *RepositoryMockEventByURLTitleResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockEventByURLTitleParams contains parameters of the Repository.EventByURLTitle
type RepositoryMockEventByURLTitleParams struct {
	ctx      context.Context
	urlTitle string
}

// RepositoryMockEventByURLTitleParamPtrs contains pointers to parameters of the Repository.EventByURLTitle
type RepositoryMockEventByURLTitleParamPtrs struct {
	ctx      *context.Context
	urlTitle *string
}

// RepositoryMockEventByURLTitleResults contains results of the Repository.EventByURLTitle
type RepositoryMockEventByURLTitleResults struct {
	ep1 *models.Event
	err error
}

// RepositoryMockEventByURLTitleOrigins contains origins of expectations of the Repository.EventByURLTitle
type RepositoryMockEventByURLTitleExpectationOrigins struct {
	origin         string
	originCtx      string
	originUrlTitle string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEventByURLTitle *mRepositoryMockEventByURLTitle) Optional() *mRepositoryMockEventByURLTitle {
	mmEventByURLTitle.optional = true
	return mmEventByURLTitle
}

// Expect sets up expected params for Repository.EventByURLTitle
func (mmEventByURLTitle *mRepositoryMockEventByURLTitle) Expect(ctx context.Context, urlTitle string) *mRepositoryMockEventByURLTitle {
	if mmEventByURLTitle.mock.funcEventByURLTitle != nil {
		mmEventByURLTitle.mock.t.Fatalf("RepositoryMock.EventByURLTitle mock is already set by Set")
	}

	if mmEventByURLTitle.defaultExpectation == nil {
		mmEventByURLTitle.defaultExpectation = &RepositoryMockEventByURLTitleExpectation{}
	}

	if mmEventByURLTitle.defaultExpectation.paramPtrs != nil {
		mmEventByURLTitle.mock.t.Fatalf("RepositoryMock.EventByURLTitle mock is already set by ExpectParams functions")
	}

	mmEventByURLTitle.defaultExpectation.params = &RepositoryMockEventByURLTitleParams{ctx, urlTitle}
	mmEventByURLTitle.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEventByURLTitle.expectations {
		if minimock.Equal(e.params, mmEventByURLTitle.defaultExpectation.params) {
			mmEventByURLTitle.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEventByURLTitle.defaultExpectation.params)
		}
	}

	return mmEventByURLTitle
}

// ExpectCtxParam1 sets up expected param ctx for Repository.EventByURLTitle
func (mmEventByURLTitle *mRepositoryMockEventByURLTitle) ExpectCtxParam1(ctx context.Context) *mRepositoryMockEventByURLTitle {
	if mmEventByURLTitle.mock.funcEventByURLTitle != nil {
		mmEventByURLTitle.mock.t.Fatalf("RepositoryMock.EventByURLTitle mock is already set by Set")
	}

	if mmEventByURLTitle.defaultExpectation == nil {
		mmEventByURLTitle.defaultExpectation = &RepositoryMockEventByURLTitleExpectation{}
	}

	if mmEventByURLTitle.defaultExpectation.params != nil {
		mmEventByURLTitle.mock.t.Fatalf("RepositoryMock.EventByURLTitle mock is already set by Expect")
	}

	if mmEventByURLTitle.defaultExpectation.paramPtrs == nil {
		mmEventByURLTitle.defaultExpectation.paramPtrs = &RepositoryMockEventByURLTitleParamPtrs{}
	}
	mmEventByURLTitle.defaultExpectation.paramPtrs.ctx = &ctx
	mmEventByURLTitle.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEventByURLTitle
}

// ExpectUrlTitleParam2 sets up expected param urlTitle for Repository.EventByURLTitle
func (mmEventByURLTitle *mRepositoryMockEventByURLTitle) ExpectUrlTitleParam2(urlTitle string) *mRepositoryMockEventByURLTitle {
	if mmEventByURLTitle.mock.funcEventByURLTitle != nil {
		mmEventByURLTitle.mock.t.Fatalf("RepositoryMock.EventByURLTitle mock is already set by Set")
	}

	if mmEventByURLTitle.defaultExpectation == nil {
		mmEventByURLTitle.defaultExpectation = &RepositoryMockEventByURLTitleExpectation{}
	}

	if mmEventByURLTitle.defaultExpectation.params != nil {
		mmEventByURLTitle.mock.t.Fatalf("RepositoryMock.EventByURLTitle mock is already set by Expect")
	}

	if mmEventByURLTitle.defaultExpectation.paramPtrs == nil {
		mmEventByURLTitle.defaultExpectation.paramPtrs = &RepositoryMockEventByURLTitleParamPtrs{}
	}
	mmEventByURLTitle.defaultExpectation.paramPtrs.urlTitle = &urlTitle
	mmEventByURLTitle.defaultExpectation.expectationOrigins.originUrlTitle = minimock.CallerInfo(1)

	return mmEventByURLTitle
}

// Inspect accepts an inspector function that has same arguments as the Repository.EventByURLTitle
func (mmEventByURLTitle *mRepositoryMockEventByURLTitle) Inspect(f func(ctx context.Context, urlTitle string)) *mRepositoryMockEventByURLTitle {
	if mmEventByURLTitle.mock.inspectFuncEventByURLTitle != nil {
		mmEventByURLTitle.mock.t.Fatalf("Inspect function is already set for RepositoryMock.EventByURLTitle")
	}

	mmEventByURLTitle.mock.inspectFuncEventByURLTitle = f

	return mmEventByURLTitle
}

// Return sets up results that will be returned by Repository.EventByURLTitle
func (mmEventByURLTitle *mRepositoryMockEventByURLTitle) Return(ep1 *models.Event, err error) *RepositoryMock {
	if mmEventByURLTitle.mock.funcEventByURLTitle != nil {
		mmEventByURLTitle.mock.t.Fatalf("RepositoryMock.EventByURLTitle mock is already set by Set")
	}

	if mmEventByURLTitle.defaultExpectation == nil {
		mmEventByURLTitle.defaultExpectation = &RepositoryMockEventByURLTitleExpectation{mock: mmEventByURLTitle.mock}
	}
	mmEventByURLTitle.defaultExpectation.results = &RepositoryMockEventByURLTitleResults{ep1, err}
	mmEventByURLTitle.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEventByURLTitle.mock
}

// Set uses given function f to mock the Repository.EventByURLTitle method
func (mmEventByURLTitle *mRepositoryMockEventByURLTitle) Set(f func(ctx context.Context, urlTitle string) (ep1 *models.Event, err error)) *RepositoryMock {
	if mmEventByURLTitle.defaultExpectation != nil {
		mmEventByURLTitle.mock.t.Fatalf("Default expectation is already set for the Repository.EventByURLTitle method")
	}

	if len(mmEventByURLTitle.expectations) > 0 {
		mmEventByURLTitle.mock.t.Fatalf("Some expectations are already set for the Repository.EventByURLTitle method")
	}

	mmEventByURLTitle.mock.funcEventByURLTitle = f
	mmEventByURLTitle.mock.funcEventByURLTitleOrigin = minimock.CallerInfo(1)
	return mmEventByURLTitle.mock
}

// When sets expectation for the Repository.EventByURLTitle which will trigger the result defined by the following
// Then helper
func (mmEventByURLTitle *mRepositoryMockEventByURLTitle) When(ctx context.Context, urlTitle string) *RepositoryMockEventByURLTitleExpectation {
	if mmEventByURLTitle.mock.funcEventByURLTitle != nil {
		mmEventByURLTitle.mock.t.Fatalf("RepositoryMock.EventByURLTitle mock is already set by Set")
	}

	expectation := &RepositoryMockEventByURLTitleExpectation{
		mock:               mmEventByURLTitle.mock,
		params:             &RepositoryMockEventByURLTitleParams{ctx, urlTitle},
		expectationOrigins: RepositoryMockEventByURLTitleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEventByURLTitle.expectations = append(mmEventByURLTitle.expectations, expectation)
	return expectation
}

// Then sets up Repository.EventByURLTitle return parameters for the expectation previously defined by the When method
func (e *RepositoryMockEventByURLTitleExpectation) Then(ep1 *models.Event, err error) *RepositoryMock {
	e.results = &RepositoryMockEventByURLTitleResults{ep1, err}
	return e.mock
}

// Times sets number of times Repository.EventByURLTitle should be invoked
func (mmEventByURLTitle *mRepositoryMockEventByURLTitle) Times(n uint64) *mRepositoryMockEventByURLTitle {
	if n == 0 {
		mmEventByURLTitle.mock.t.Fatalf("Times of RepositoryMock.EventByURLTitle mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEventByURLTitle.expectedInvocations, n)
	mmEventByURLTitle.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEventByURLTitle
}

func (mmEventByURLTitle *mRepositoryMockEventByURLTitle) invocationsDone() bool {
	if len(mmEventByURLTitle.expectations) == 0 && mmEventByURLTitle.defaultExpectation == nil && mmEventByURLTitle.mock.funcEventByURLTitle == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEventByURLTitle.mock.afterEventByURLTitleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEventByURLTitle.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EventByURLTitle implements mm_repository.Repository
func (mmEventByURLTitle *RepositoryMock) EventByURLTitle(ctx context.Context, urlTitle string) (ep1 *models.Event, err error) {
	mm_atomic.AddUint64(&mmEventByURLTitle.beforeEventByURLTitleCounter, 1)
	defer mm_atomic.AddUint64(&mmEventByURLTitle.afterEventByURLTitleCounter, 1)

	mmEventByURLTitle.t.Helper()

	if mmEventByURLTitle.inspectFuncEventByURLTitle != nil {
		mmEventByURLTitle.inspectFuncEventByURLTitle(ctx, urlTitle)
	}

	mm_params := RepositoryMockEventByURLTitleParams{ctx, urlTitle}

	// Record call args
	mmEventByURLTitle.EventByURLTitleMock.mutex.Lock()
	mmEventByURLTitle.EventByURLTitleMock.callArgs = append(mmEventByURLTitle.EventByURLTitleMock.callArgs, &mm_params)
	mmEventByURLTitle.EventByURLTitleMock.mutex.Unlock()

	for _, e := range mmEventByURLTitle.EventByURLTitleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmEventByURLTitle.EventByURLTitleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEventByURLTitle.EventByURLTitleMock.defaultExpectation.Counter, 1)
		mm_want := mmEventByURLTitle.EventByURLTitleMock.defaultExpectation.params
		mm_want_ptrs := mmEventByURLTitle.EventByURLTitleMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockEventByURLTitleParams{ctx, urlTitle}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEventByURLTitle.t.Errorf("RepositoryMock.EventByURLTitle got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEventByURLTitle.EventByURLTitleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.urlTitle != nil && !minimock.Equal(*mm_want_ptrs.urlTitle, mm_got.urlTitle) {
				mmEventByURLTitle.t.Errorf("RepositoryMock.EventByURLTitle got unexpected parameter urlTitle, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEventByURLTitle.EventByURLTitleMock.defaultExpectation.expectationOrigins.originUrlTitle, *mm_want_ptrs.urlTitle, mm_got.urlTitle, minimock.Diff(*mm_want_ptrs.urlTitle, mm_got.urlTitle))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEventByURLTitle.t.Errorf("RepositoryMock.EventByURLTitle got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEventByURLTitle.EventByURLTitleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEventByURLTitle.EventByURLTitleMock.defaultExpectation.results
		if mm_results == nil {
			mmEventByURLTitle.t.Fatal("No results are set for the RepositoryMock.EventByURLTitle")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmEventByURLTitle.funcEventByURLTitle != nil {
		return mmEventByURLTitle.funcEventByURLTitle(ctx, urlTitle)
	}
	mmEventByURLTitle.t.Fatalf("Unexpected call to RepositoryMock.EventByURLTitle. %v %v", ctx, urlTitle)
	return
}

// EventByURLTitleAfterCounter returns a count of finished RepositoryMock.EventByURLTitle invocations
func (mmEventByURLTitle *RepositoryMock) EventByURLTitleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEventByURLTitle.afterEventByURLTitleCounter)
}

// EventByURLTitleBeforeCounter returns a count of RepositoryMock.EventByURLTitle invocations
func (mmEventByURLTitle *RepositoryMock) EventByURLTitleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEventByURLTitle.beforeEventByURLTitleCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.EventByURLTitle.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEventByURLTitle *mRepositoryMockEventByURLTitle) Calls() []*RepositoryMockEventByURLTitleParams {
	mmEventByURLTitle.mutex.RLock()

	argCopy := make([]*RepositoryMockEventByURLTitleParams, len(mmEventByURLTitle.callArgs))
	copy(argCopy, mmEventByURLTitle.callArgs)

	mmEventByURLTitle.mutex.RUnlock()

	return argCopy
}

// MinimockEventByURLTitleDone returns true if the count of the EventByURLTitle invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockEventByURLTitleDone() bool {
	if m.EventByURLTitleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EventByURLTitleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EventByURLTitleMock.invocationsDone()
}

// MinimockEventByURLTitleInspect logs each unmet expectation
func (m *RepositoryMock) MinimockEventByURLTitleInspect() {
	for _, e := range m.EventByURLTitleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.EventByURLTitle at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEventByURLTitleCounter := mm_atomic.LoadUint64(&m.afterEventByURLTitleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EventByURLTitleMock.defaultExpectation != nil && afterEventByURLTitleCounter < 1 {
		if m.EventByURLTitleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.EventByURLTitle at\n%s", m.EventByURLTitleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.EventByURLTitle at\n%s with params: %#v", m.EventByURLTitleMock.defaultExpectation.expectationOrigins.origin, *m.EventByURLTitleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEventByURLTitle != nil && afterEventByURLTitleCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.EventByURLTitle at\n%s", m.funcEventByURLTitleOrigin)
	}

	if !m.EventByURLTitleMock.invocationsDone() && afterEventByURLTitleCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.EventByURLTitle at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EventByURLTitleMock.expectedInvocations), m.EventByURLTitleMock.expectedInvocationsOrigin, afterEventByURLTitleCounter)
	}
}

type mRepositoryMockEvents struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockEventsExpectation
	expectations       []*RepositoryMockEventsExpectation

	callArgs []*RepositoryMockEventsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockEventsExpectation specifies expectation struct of the Repository.Events
type RepositoryMockEventsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockEventsParams
	paramPtrs          *RepositoryMockEventsParamPtrs
	expectationOrigins RepositoryMockEventsExpectationOrigins
	results            *RepositoryMockEventsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockEventsParams contains parameters of the Repository.Events
type RepositoryMockEventsParams struct {
	ctx  context.Context
	page int
}

// RepositoryMockEventsParamPtrs contains pointers to parameters of the Repository.Events
type RepositoryMockEventsParamPtrs struct {
	ctx  *context.Context
	page *int
}

// RepositoryMockEventsResults contains results of the Repository.Events
type RepositoryMockEventsResults struct {
	epa1 []*models.Event
	err  error
}

// RepositoryMockEventsOrigins contains origins of expectations of the Repository.Events
type RepositoryMockEventsExpectationOrigins struct {
	origin     string
	originCtx  string
	originPage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEvents *mRepositoryMockEvents) Optional() *mRepositoryMockEvents {
	mmEvents.optional = true
	return mmEvents
}

// Expect sets up expected params for Repository.Events
func (mmEvents *mRepositoryMockEvents) Expect(ctx context.Context, page int) *mRepositoryMockEvents {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("RepositoryMock.Events mock is already set by Set")
	}

	if mmEvents.defaultExpectation == nil {
		mmEvents.defaultExpectation = &RepositoryMockEventsExpectation{}
	}

	if mmEvents.defaultExpectation.paramPtrs != nil {
		mmEvents.mock.t.Fatalf("RepositoryMock.Events mock is already set by ExpectParams functions")
	}

	mmEvents.defaultExpectation.params = &RepositoryMockEventsParams{ctx, page}
	mmEvents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEvents.expectations {
		if minimock.Equal(e.params, mmEvents.defaultExpectation.params) {
			mmEvents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEvents.defaultExpectation.params)
		}
	}

	return mmEvents
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Events
func (mmEvents *mRepositoryMockEvents) ExpectCtxParam1(ctx context.Context) *mRepositoryMockEvents {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("RepositoryMock.Events mock is already set by Set")
	}

	if mmEvents.defaultExpectation == nil {
		mmEvents.defaultExpectation = &RepositoryMockEventsExpectation{}
	}

	if mmEvents.defaultExpectation.params != nil {
		mmEvents.mock.t.Fatalf("RepositoryMock.Events mock is already set by Expect")
	}

	if mmEvents.defaultExpectation.paramPtrs == nil {
		mmEvents.defaultExpectation.paramPtrs = &RepositoryMockEventsParamPtrs{}
	}
	mmEvents.defaultExpectation.paramPtrs.ctx = &ctx
	mmEvents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEvents
}

// ExpectPageParam2 sets up expected param page for Repository.Events
func (mmEvents *mRepositoryMockEvents) ExpectPageParam2(page int) *mRepositoryMockEvents {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("RepositoryMock.Events mock is already set by Set")
	}

	if mmEvents.defaultExpectation == nil {
		mmEvents.defaultExpectation = &RepositoryMockEventsExpectation{}
	}

	if mmEvents.defaultExpectation.params != nil {
		mmEvents.mock.t.Fatalf("RepositoryMock.Events mock is already set by Expect")
	}

	if mmEvents.defaultExpectation.paramPtrs == nil {
		mmEvents.defaultExpectation.paramPtrs = &RepositoryMockEventsParamPtrs{}
	}
	mmEvents.defaultExpectation.paramPtrs.page = &page
	mmEvents.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmEvents
}

// Inspect accepts an inspector function that has same arguments as the Repository.Events
func (mmEvents *mRepositoryMockEvents) Inspect(f func(ctx context.Context, page int)) *mRepositoryMockEvents {
	if mmEvents.mock.inspectFuncEvents != nil {
		mmEvents.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Events")
	}

	mmEvents.mock.inspectFuncEvents = f

	return mmEvents
}

// Return sets up results that will be returned by Repository.Events
func (mmEvents *mRepositoryMockEvents) Return(epa1 []*models.Event, err error) *RepositoryMock {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("RepositoryMock.Events mock is already set by Set")
	}

	if mmEvents.defaultExpectation == nil {
		mmEvents.defaultExpectation = &RepositoryMockEventsExpectation{mock: mmEvents.mock}
	}
	mmEvents.defaultExpectation.results = &RepositoryMockEventsResults{epa1, err}
	mmEvents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEvents.mock
}

// Set uses given function f to mock the Repository.Events method
func (mmEvents *mRepositoryMockEvents) Set(f func(ctx context.Context, page int) (epa1 []*models.Event, err error)) *RepositoryMock {
	if mmEvents.defaultExpectation != nil {
		mmEvents.mock.t.Fatalf("Default expectation is already set for the Repository.Events method")
	}

	if len(mmEvents.expectations) > 0 {
		mmEvents.mock.t.Fatalf("Some expectations are already set for the Repository.Events method")
	}

	mmEvents.mock.funcEvents = f
	mmEvents.mock.funcEventsOrigin = minimock.CallerInfo(1)
	return mmEvents.mock
}

// When sets expectation for the Repository.Events which will trigger the result defined by the following
// Then helper
func (mmEvents *mRepositoryMockEvents) When(ctx context.Context, page int) *RepositoryMockEventsExpectation {
	if mmEvents.mock.funcEvents != nil {
		mmEvents.mock.t.Fatalf("RepositoryMock.Events mock is already set by Set")
	}

	expectation := &RepositoryMockEventsExpectation{
		mock:               mmEvents.mock,
		params:             &RepositoryMockEventsParams{ctx, page},
		expectationOrigins: RepositoryMockEventsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEvents.expectations = append(mmEvents.expectations, expectation)
	return expectation
}

// Then sets up Repository.Events return parameters for the expectation previously defined by the When method
func (e *RepositoryMockEventsExpectation) Then(epa1 []*models.Event, err error) *RepositoryMock {
	e.results = &RepositoryMockEventsResults{epa1, err}
	return e.mock
}

// Times sets number of times Repository.Events should be invoked
func (mmEvents *mRepositoryMockEvents) Times(n uint64) *mRepositoryMockEvents {
	if n == 0 {
		mmEvents.mock.t.Fatalf("Times of RepositoryMock.Events mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEvents.expectedInvocations, n)
	mmEvents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEvents
}

func (mmEvents *mRepositoryMockEvents) invocationsDone() bool {
	if len(mmEvents.expectations) == 0 && mmEvents.defaultExpectation == nil && mmEvents.mock.funcEvents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEvents.mock.afterEventsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEvents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Events implements mm_repository.Repository
func (mmEvents *RepositoryMock) Events(ctx context.Context, page int) (epa1 []*models.Event, err error) {
	mm_atomic.AddUint64(&mmEvents.beforeEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmEvents.afterEventsCounter, 1)

	mmEvents.t.Helper()

	if mmEvents.inspectFuncEvents != nil {
		mmEvents.inspectFuncEvents(ctx, page)
	}

	mm_params := RepositoryMockEventsParams{ctx, page}

	// Record call args
	mmEvents.EventsMock.mutex.Lock()
	mmEvents.EventsMock.callArgs = append(mmEvents.EventsMock.callArgs, &mm_params)
	mmEvents.EventsMock.mutex.Unlock()

	for _, e := range mmEvents.EventsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.epa1, e.results.err
		}
	}

	if mmEvents.EventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEvents.EventsMock.defaultExpectation.Counter, 1)
		mm_want := mmEvents.EventsMock.defaultExpectation.params
		mm_want_ptrs := mmEvents.EventsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockEventsParams{ctx, page}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEvents.t.Errorf("RepositoryMock.Events got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEvents.EventsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmEvents.t.Errorf("RepositoryMock.Events got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEvents.EventsMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEvents.t.Errorf("RepositoryMock.Events got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEvents.EventsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEvents.EventsMock.defaultExpectation.results
		if mm_results == nil {
			mmEvents.t.Fatal("No results are set for the RepositoryMock.Events")
		}
		return (*mm_results).epa1, (*mm_results).err
	}
	if mmEvents.funcEvents != nil {
		return mmEvents.funcEvents(ctx, page)
	}
	mmEvents.t.Fatalf("Unexpected call to RepositoryMock.Events. %v %v", ctx, page)
	return
}

// EventsAfterCounter returns a count of finished RepositoryMock.Events invocations
func (mmEvents *RepositoryMock) EventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEvents.afterEventsCounter)
}

// EventsBeforeCounter returns a count of RepositoryMock.Events invocations
func (mmEvents *RepositoryMock) EventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEvents.beforeEventsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Events.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEvents *mRepositoryMockEvents) Calls() []*RepositoryMockEventsParams {
	mmEvents.mutex.RLock()

	argCopy := make([]*RepositoryMockEventsParams, len(mmEvents.callArgs))
	copy(argCopy, mmEvents.callArgs)

	mmEvents.mutex.RUnlock()

	return argCopy
}

// MinimockEventsDone returns true if the count of the Events invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockEventsDone() bool {
	if m.EventsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EventsMock.invocationsDone()
}

// MinimockEventsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockEventsInspect() {
	for _, e := range m.EventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Events at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEventsCounter := mm_atomic.LoadUint64(&m.afterEventsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EventsMock.defaultExpectation != nil && afterEventsCounter < 1 {
		if m.EventsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Events at\n%s", m.EventsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Events at\n%s with params: %#v", m.EventsMock.defaultExpectation.expectationOrigins.origin, *m.EventsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEvents != nil && afterEventsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Events at\n%s", m.funcEventsOrigin)
	}

	if !m.EventsMock.invocationsDone() && afterEventsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Events at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EventsMock.expectedInvocations), m.EventsMock.expectedInvocationsOrigin, afterEventsCounter)
	}
}

type mRepositoryMockInsertEvent struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockInsertEventExpectation
	expectations       []*RepositoryMockInsertEventExpectation

	callArgs []*RepositoryMockInsertEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockInsertEventExpectation specifies expectation struct of the Repository.InsertEvent
type RepositoryMockInsertEventExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockInsertEventParams
	paramPtrs          *RepositoryMockInsertEventParamPtrs
	expectationOrigins RepositoryMockInsertEventExpectationOrigins
	results            *RepositoryMockInsertEventResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockInsertEventParams contains parameters of the Repository.InsertEvent
type RepositoryMockInsertEventParams struct {
	ctx   context.Context
	event *models.Event
}

// RepositoryMockInsertEventParamPtrs contains pointers to parameters of the Repository.InsertEvent
type RepositoryMockInsertEventParamPtrs struct {
	ctx   *context.Context
	event **models.Event
}

// RepositoryMockInsertEventResults contains results of the Repository.InsertEvent
type RepositoryMockInsertEventResults struct {
	i1  int64
	err error
}

// RepositoryMockInsertEventOrigins contains origins of expectations of the Repository.InsertEvent
type RepositoryMockInsertEventExpectationOrigins struct {
	origin      string
	originCtx   string
	originEvent string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInsertEvent *mRepositoryMockInsertEvent) Optional() *mRepositoryMockInsertEvent {
	mmInsertEvent.optional = true
	return mmInsertEvent
}

// Expect sets up expected params for Repository.InsertEvent
func (mmInsertEvent *mRepositoryMockInsertEvent) Expect(ctx context.Context, event *models.Event) *mRepositoryMockInsertEvent {
	if mmInsertEvent.mock.funcInsertEvent != nil {
		mmInsertEvent.mock.t.Fatalf("RepositoryMock.InsertEvent mock is already set by Set")
	}

	if mmInsertEvent.defaultExpectation == nil {
		mmInsertEvent.defaultExpectation = &RepositoryMockInsertEventExpectation{}
	}

	if mmInsertEvent.defaultExpectation.paramPtrs != nil {
		mmInsertEvent.mock.t.Fatalf("RepositoryMock.InsertEvent mock is already set by ExpectParams functions")
	}

	mmInsertEvent.defaultExpectation.params = &RepositoryMockInsertEventParams{ctx, event}
	mmInsertEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInsertEvent.expectations {
		if minimock.Equal(e.params, mmInsertEvent.defaultExpectation.params) {
			mmInsertEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertEvent.defaultExpectation.params)
		}
	}

	return mmInsertEvent
}

// ExpectCtxParam1 sets up expected param ctx for Repository.InsertEvent
func (mmInsertEvent *mRepositoryMockInsertEvent) ExpectCtxParam1(ctx context.Context) *mRepositoryMockInsertEvent {
	if mmInsertEvent.mock.funcInsertEvent != nil {
		mmInsertEvent.mock.t.Fatalf("RepositoryMock.InsertEvent mock is already set by Set")
	}

	if mmInsertEvent.defaultExpectation == nil {
		mmInsertEvent.defaultExpectation = &RepositoryMockInsertEventExpectation{}
	}

	if mmInsertEvent.defaultExpectation.params != nil {
		mmInsertEvent.mock.t.Fatalf("RepositoryMock.InsertEvent mock is already set by Expect")
	}

	if mmInsertEvent.defaultExpectation.paramPtrs == nil {
		mmInsertEvent.defaultExpectation.paramPtrs = &RepositoryMockInsertEventParamPtrs{}
	}
	mmInsertEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmInsertEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInsertEvent
}

// ExpectEventParam2 sets up expected param event for Repository.InsertEvent
func (mmInsertEvent *mRepositoryMockInsertEvent) ExpectEventParam2(event *models.Event) *mRepositoryMockInsertEvent {
	if mmInsertEvent.mock.funcInsertEvent != nil {
		mmInsertEvent.mock.t.Fatalf("RepositoryMock.InsertEvent mock is already set by Set")
	}

	if mmInsertEvent.defaultExpectation == nil {
		mmInsertEvent.defaultExpectation = &RepositoryMockInsertEventExpectation{}
	}

	if mmInsertEvent.defaultExpectation.params != nil {
		mmInsertEvent.mock.t.Fatalf("RepositoryMock.InsertEvent mock is already set by Expect")
	}

	if mmInsertEvent.defaultExpectation.paramPtrs == nil {
		mmInsertEvent.defaultExpectation.paramPtrs = &RepositoryMockInsertEventParamPtrs{}
	}
	mmInsertEvent.defaultExpectation.paramPtrs.event = &event
	mmInsertEvent.defaultExpectation.expectationOrigins.originEvent = minimock.CallerInfo(1)

	return mmInsertEvent
}

// Inspect accepts an inspector function that has same arguments as the Repository.InsertEvent
func (mmInsertEvent *mRepositoryMockInsertEvent) Inspect(f func(ctx context.Context, event *models.Event)) *mRepositoryMockInsertEvent {
	if mmInsertEvent.mock.inspectFuncInsertEvent != nil {
		mmInsertEvent.mock.t.Fatalf("Inspect function is already set for RepositoryMock.InsertEvent")
	}

	mmInsertEvent.mock.inspectFuncInsertEvent = f

	return mmInsertEvent
}

// Return sets up results that will be returned by Repository.InsertEvent
func (mmInsertEvent *mRepositoryMockInsertEvent) Return(i1 int64, err error) *RepositoryMock {
	if mmInsertEvent.mock.funcInsertEvent != nil {
		mmInsertEvent.mock.t.Fatalf("RepositoryMock.InsertEvent mock is already set by Set")
	}

	if mmInsertEvent.defaultExpectation == nil {
		mmInsertEvent.defaultExpectation = &RepositoryMockInsertEventExpectation{mock: mmInsertEvent.mock}
	}
	mmInsertEvent.defaultExpectation.results = &RepositoryMockInsertEventResults{i1, err}
	mmInsertEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInsertEvent.mock
}

// Set uses given function f to mock the Repository.InsertEvent method
func (mmInsertEvent *mRepositoryMockInsertEvent) Set(f func(ctx context.Context, event *models.Event) (i1 int64, err error)) *RepositoryMock {
	if mmInsertEvent.defaultExpectation != nil {
		mmInsertEvent.mock.t.Fatalf("Default expectation is already set for the Repository.InsertEvent method")
	}

	if len(mmInsertEvent.expectations) > 0 {
		mmInsertEvent.mock.t.Fatalf("Some expectations are already set for the Repository.InsertEvent method")
	}

	mmInsertEvent.mock.funcInsertEvent = f
	mmInsertEvent.mock.funcInsertEventOrigin = minimock.CallerInfo(1)
	return mmInsertEvent.mock
}

// When sets expectation for the Repository.InsertEvent which will trigger the result defined by the following
// Then helper
func (mmInsertEvent *mRepositoryMockInsertEvent) When(ctx context.Context, event *models.Event) *RepositoryMockInsertEventExpectation {
	if mmInsertEvent.mock.funcInsertEvent != nil {
		mmInsertEvent.mock.t.Fatalf("RepositoryMock.InsertEvent mock is already set by Set")
	}

	expectation := &RepositoryMockInsertEventExpectation{
		mock:               mmInsertEvent.mock,
		params:             &RepositoryMockInsertEventParams{ctx, event},
		expectationOrigins: RepositoryMockInsertEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInsertEvent.expectations = append(mmInsertEvent.expectations, expectation)
	return expectation
}

// Then sets up Repository.InsertEvent return parameters for the expectation previously defined by the When method
func (e *RepositoryMockInsertEventExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockInsertEventResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.InsertEvent should be invoked
func (mmInsertEvent *mRepositoryMockInsertEvent) Times(n uint64) *mRepositoryMockInsertEvent {
	if n == 0 {
		mmInsertEvent.mock.t.Fatalf("Times of RepositoryMock.InsertEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInsertEvent.expectedInvocations, n)
	mmInsertEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInsertEvent
}

func (mmInsertEvent *mRepositoryMockInsertEvent) invocationsDone() bool {
	if len(mmInsertEvent.expectations) == 0 && mmInsertEvent.defaultExpectation == nil && mmInsertEvent.mock.funcInsertEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInsertEvent.mock.afterInsertEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInsertEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InsertEvent implements mm_repository.Repository
func (mmInsertEvent *RepositoryMock) InsertEvent(ctx context.Context, event *models.Event) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmInsertEvent.beforeInsertEventCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertEvent.afterInsertEventCounter, 1)

	mmInsertEvent.t.Helper()

	if mmInsertEvent.inspectFuncInsertEvent != nil {
		mmInsertEvent.inspectFuncInsertEvent(ctx, event)
	}

	mm_params := RepositoryMockInsertEventParams{ctx, event}

	// Record call args
	mmInsertEvent.InsertEventMock.mutex.Lock()
	mmInsertEvent.InsertEventMock.callArgs = append(mmInsertEvent.InsertEventMock.callArgs, &mm_params)
	mmInsertEvent.InsertEventMock.mutex.Unlock()

	for _, e := range mmInsertEvent.InsertEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmInsertEvent.InsertEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertEvent.InsertEventMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertEvent.InsertEventMock.defaultExpectation.params
		mm_want_ptrs := mmInsertEvent.InsertEventMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockInsertEventParams{ctx, event}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsertEvent.t.Errorf("RepositoryMock.InsertEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertEvent.InsertEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.event != nil && !minimock.Equal(*mm_want_ptrs.event, mm_got.event) {
				mmInsertEvent.t.Errorf("RepositoryMock.InsertEvent got unexpected parameter event, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertEvent.InsertEventMock.defaultExpectation.expectationOrigins.originEvent, *mm_want_ptrs.event, mm_got.event, minimock.Diff(*mm_want_ptrs.event, mm_got.event))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertEvent.t.Errorf("RepositoryMock.InsertEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInsertEvent.InsertEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertEvent.InsertEventMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertEvent.t.Fatal("No results are set for the RepositoryMock.InsertEvent")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmInsertEvent.funcInsertEvent != nil {
		return mmInsertEvent.funcInsertEvent(ctx, event)
	}
	mmInsertEvent.t.Fatalf("Unexpected call to RepositoryMock.InsertEvent. %v %v", ctx, event)
	return
}

// InsertEventAfterCounter returns a count of finished RepositoryMock.InsertEvent invocations
func (mmInsertEvent *RepositoryMock) InsertEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertEvent.afterInsertEventCounter)
}

// InsertEventBeforeCounter returns a count of RepositoryMock.InsertEvent invocations
func (mmInsertEvent *RepositoryMock) InsertEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertEvent.beforeInsertEventCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.InsertEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertEvent *mRepositoryMockInsertEvent) Calls() []*RepositoryMockInsertEventParams {
	mmInsertEvent.mutex.RLock()

	argCopy := make([]*RepositoryMockInsertEventParams, len(mmInsertEvent.callArgs))
	copy(argCopy, mmInsertEvent.callArgs)

	mmInsertEvent.mutex.RUnlock()

	return argCopy
}

// MinimockInsertEventDone returns true if the count of the InsertEvent invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockInsertEventDone() bool {
	if m.InsertEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InsertEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InsertEventMock.invocationsDone()
}

// MinimockInsertEventInspect logs each unmet expectation
func (m *RepositoryMock) MinimockInsertEventInspect() {
	for _, e := range m.InsertEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.InsertEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInsertEventCounter := mm_atomic.LoadUint64(&m.afterInsertEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InsertEventMock.defaultExpectation != nil && afterInsertEventCounter < 1 {
		if m.InsertEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.InsertEvent at\n%s", m.InsertEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.InsertEvent at\n%s with params: %#v", m.InsertEventMock.defaultExpectation.expectationOrigins.origin, *m.InsertEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertEvent != nil && afterInsertEventCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.InsertEvent at\n%s", m.funcInsertEventOrigin)
	}

	if !m.InsertEventMock.invocationsDone() && afterInsertEventCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.InsertEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InsertEventMock.expectedInvocations), m.InsertEventMock.expectedInvocationsOrigin, afterInsertEventCounter)
	}
}

type mRepositoryMockInsertTicket struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockInsertTicketExpectation
	expectations       []*RepositoryMockInsertTicketExpectation

	callArgs []*RepositoryMockInsertTicketParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockInsertTicketExpectation specifies expectation struct of the Repository.InsertTicket
type RepositoryMockInsertTicketExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockInsertTicketParams
	paramPtrs          *RepositoryMockInsertTicketParamPtrs
	expectationOrigins RepositoryMockInsertTicketExpectationOrigins
	results            *RepositoryMockInsertTicketResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockInsertTicketParams contains parameters of the Repository.InsertTicket
type RepositoryMockInsertTicketParams struct {
	ctx    context.Context
	ticket *models.Ticket
}

// RepositoryMockInsertTicketParamPtrs contains pointers to parameters of the Repository.InsertTicket
type RepositoryMockInsertTicketParamPtrs struct {
	ctx    *context.Context
	ticket **models.Ticket
}

// RepositoryMockInsertTicketResults contains results of the Repository.InsertTicket
type RepositoryMockInsertTicketResults struct {
	s1  string
	err error
}

// RepositoryMockInsertTicketOrigins contains origins of expectations of the Repository.InsertTicket
type RepositoryMockInsertTicketExpectationOrigins struct {
	origin       string
	originCtx    string
	originTicket string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInsertTicket *mRepositoryMockInsertTicket) Optional() *mRepositoryMockInsertTicket {
	mmInsertTicket.optional = true
	return mmInsertTicket
}

// Expect sets up expected params for Repository.InsertTicket
func (mmInsertTicket *mRepositoryMockInsertTicket) Expect(ctx context.Context, ticket *models.Ticket) *mRepositoryMockInsertTicket {
	if mmInsertTicket.mock.funcInsertTicket != nil {
		mmInsertTicket.mock.t.Fatalf("RepositoryMock.InsertTicket mock is already set by Set")
	}

	if mmInsertTicket.defaultExpectation == nil {
		mmInsertTicket.defaultExpectation = &RepositoryMockInsertTicketExpectation{}
	}

	if mmInsertTicket.defaultExpectation.paramPtrs != nil {
		mmInsertTicket.mock.t.Fatalf("RepositoryMock.InsertTicket mock is already set by ExpectParams functions")
	}

	mmInsertTicket.defaultExpectation.params = &RepositoryMockInsertTicketParams{ctx, ticket}
	mmInsertTicket.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInsertTicket.expectations {
		if minimock.Equal(e.params, mmInsertTicket.defaultExpectation.params) {
			mmInsertTicket.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertTicket.defaultExpectation.params)
		}
	}

	return mmInsertTicket
}

// ExpectCtxParam1 sets up expected param ctx for Repository.InsertTicket
func (mmInsertTicket *mRepositoryMockInsertTicket) ExpectCtxParam1(ctx context.Context) *mRepositoryMockInsertTicket {
	if mmInsertTicket.mock.funcInsertTicket != nil {
		mmInsertTicket.mock.t.Fatalf("RepositoryMock.InsertTicket mock is already set by Set")
	}

	if mmInsertTicket.defaultExpectation == nil {
		mmInsertTicket.defaultExpectation = &RepositoryMockInsertTicketExpectation{}
	}

	if mmInsertTicket.defaultExpectation.params != nil {
		mmInsertTicket.mock.t.Fatalf("RepositoryMock.InsertTicket mock is already set by Expect")
	}

	if mmInsertTicket.defaultExpectation.paramPtrs == nil {
		mmInsertTicket.defaultExpectation.paramPtrs = &RepositoryMockInsertTicketParamPtrs{}
	}
	mmInsertTicket.defaultExpectation.paramPtrs.ctx = &ctx
	mmInsertTicket.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInsertTicket
}

// ExpectTicketParam2 sets up expected param ticket for Repository.InsertTicket
func (mmInsertTicket *mRepositoryMockInsertTicket) ExpectTicketParam2(ticket *models.Ticket) *mRepositoryMockInsertTicket {
	if mmInsertTicket.mock.funcInsertTicket != nil {
		mmInsertTicket.mock.t.Fatalf("RepositoryMock.InsertTicket mock is already set by Set")
	}

	if mmInsertTicket.defaultExpectation == nil {
		mmInsertTicket.defaultExpectation = &RepositoryMockInsertTicketExpectation{}
	}

	if mmInsertTicket.defaultExpectation.params != nil {
		mmInsertTicket.mock.t.Fatalf("RepositoryMock.InsertTicket mock is already set by Expect")
	}

	if mmInsertTicket.defaultExpectation.paramPtrs == nil {
		mmInsertTicket.defaultExpectation.paramPtrs = &RepositoryMockInsertTicketParamPtrs{}
	}
	mmInsertTicket.defaultExpectation.paramPtrs.ticket = &ticket
	mmInsertTicket.defaultExpectation.expectationOrigins.originTicket = minimock.CallerInfo(1)

	return mmInsertTicket
}

// Inspect accepts an inspector function that has same arguments as the Repository.InsertTicket
func (mmInsertTicket *mRepositoryMockInsertTicket) Inspect(f func(ctx context.Context, ticket *models.Ticket)) *mRepositoryMockInsertTicket {
	if mmInsertTicket.mock.inspectFuncInsertTicket != nil {
		mmInsertTicket.mock.t.Fatalf("Inspect function is already set for RepositoryMock.InsertTicket")
	}

	mmInsertTicket.mock.inspectFuncInsertTicket = f

	return mmInsertTicket
}

// Return sets up results that will be returned by Repository.InsertTicket
func (mmInsertTicket *mRepositoryMockInsertTicket) Return(s1 string, err error) *RepositoryMock {
	if mmInsertTicket.mock.funcInsertTicket != nil {
		mmInsertTicket.mock.t.Fatalf("RepositoryMock.InsertTicket mock is already set by Set")
	}

	if mmInsertTicket.defaultExpectation == nil {
		mmInsertTicket.defaultExpectation = &RepositoryMockInsertTicketExpectation{mock: mmInsertTicket.mock}
	}
	mmInsertTicket.defaultExpectation.results = &RepositoryMockInsertTicketResults{s1, err}
	mmInsertTicket.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInsertTicket.mock
}

// Set uses given function f to mock the Repository.InsertTicket method
func (mmInsertTicket *mRepositoryMockInsertTicket) Set(f func(ctx context.Context, ticket *models.Ticket) (s1 string, err error)) *RepositoryMock {
	if mmInsertTicket.defaultExpectation != nil {
		mmInsertTicket.mock.t.Fatalf("Default expectation is already set for the Repository.InsertTicket method")
	}

	if len(mmInsertTicket.expectations) > 0 {
		mmInsertTicket.mock.t.Fatalf("Some expectations are already set for the Repository.InsertTicket method")
	}

	mmInsertTicket.mock.funcInsertTicket = f
	mmInsertTicket.mock.funcInsertTicketOrigin = minimock.CallerInfo(1)
	return mmInsertTicket.mock
}

// When sets expectation for the Repository.InsertTicket which will trigger the result defined by the following
// Then helper
func (mmInsertTicket *mRepositoryMockInsertTicket) When(ctx context.Context, ticket *models.Ticket) *RepositoryMockInsertTicketExpectation {
	if mmInsertTicket.mock.funcInsertTicket != nil {
		mmInsertTicket.mock.t.Fatalf("RepositoryMock.InsertTicket mock is already set by Set")
	}

	expectation := &RepositoryMockInsertTicketExpectation{
		mock:               mmInsertTicket.mock,
		params:             &RepositoryMockInsertTicketParams{ctx, ticket},
		expectationOrigins: RepositoryMockInsertTicketExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInsertTicket.expectations = append(mmInsertTicket.expectations, expectation)
	return expectation
}

// Then sets up Repository.InsertTicket return parameters for the expectation previously defined by the When method
func (e *RepositoryMockInsertTicketExpectation) Then(s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockInsertTicketResults{s1, err}
	return e.mock
}

// Times sets number of times Repository.InsertTicket should be invoked
func (mmInsertTicket *mRepositoryMockInsertTicket) Times(n uint64) *mRepositoryMockInsertTicket {
	if n == 0 {
		mmInsertTicket.mock.t.Fatalf("Times of RepositoryMock.InsertTicket mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInsertTicket.expectedInvocations, n)
	mmInsertTicket.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInsertTicket
}

func (mmInsertTicket *mRepositoryMockInsertTicket) invocationsDone() bool {
	if len(mmInsertTicket.expectations) == 0 && mmInsertTicket.defaultExpectation == nil && mmInsertTicket.mock.funcInsertTicket == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInsertTicket.mock.afterInsertTicketCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInsertTicket.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InsertTicket implements mm_repository.Repository
func (mmInsertTicket *RepositoryMock) InsertTicket(ctx context.Context, ticket *models.Ticket) (s1 string, err error) {
	mm_atomic.AddUint64(&mmInsertTicket.beforeInsertTicketCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertTicket.afterInsertTicketCounter, 1)

	mmInsertTicket.t.Helper()

	if mmInsertTicket.inspectFuncInsertTicket != nil {
		mmInsertTicket.inspectFuncInsertTicket(ctx, ticket)
	}

	mm_params := RepositoryMockInsertTicketParams{ctx, ticket}

	// Record call args
	mmInsertTicket.InsertTicketMock.mutex.Lock()
	mmInsertTicket.InsertTicketMock.callArgs = append(mmInsertTicket.InsertTicketMock.callArgs, &mm_params)
	mmInsertTicket.InsertTicketMock.mutex.Unlock()

	for _, e := range mmInsertTicket.InsertTicketMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmInsertTicket.InsertTicketMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertTicket.InsertTicketMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertTicket.InsertTicketMock.defaultExpectation.params
		mm_want_ptrs := mmInsertTicket.InsertTicketMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockInsertTicketParams{ctx, ticket}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsertTicket.t.Errorf("RepositoryMock.InsertTicket got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertTicket.InsertTicketMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ticket != nil && !minimock.Equal(*mm_want_ptrs.ticket, mm_got.ticket) {
				mmInsertTicket.t.Errorf("RepositoryMock.InsertTicket got unexpected parameter ticket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertTicket.InsertTicketMock.defaultExpectation.expectationOrigins.originTicket, *mm_want_ptrs.ticket, mm_got.ticket, minimock.Diff(*mm_want_ptrs.ticket, mm_got.ticket))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertTicket.t.Errorf("RepositoryMock.InsertTicket got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInsertTicket.InsertTicketMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertTicket.InsertTicketMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertTicket.t.Fatal("No results are set for the RepositoryMock.InsertTicket")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmInsertTicket.funcInsertTicket != nil {
		return mmInsertTicket.funcInsertTicket(ctx, ticket)
	}
	mmInsertTicket.t.Fatalf("Unexpected call to RepositoryMock.InsertTicket. %v %v", ctx, ticket)
	return
}

// InsertTicketAfterCounter returns a count of finished RepositoryMock.InsertTicket invocations
func (mmInsertTicket *RepositoryMock) InsertTicketAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertTicket.afterInsertTicketCounter)
}

// InsertTicketBeforeCounter returns a count of RepositoryMock.InsertTicket invocations
func (mmInsertTicket *RepositoryMock) InsertTicketBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertTicket.beforeInsertTicketCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.InsertTicket.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertTicket *mRepositoryMockInsertTicket) Calls() []*RepositoryMockInsertTicketParams {
	mmInsertTicket.mutex.RLock()

	argCopy := make([]*RepositoryMockInsertTicketParams, len(mmInsertTicket.callArgs))
	copy(argCopy, mmInsertTicket.callArgs)

	mmInsertTicket.mutex.RUnlock()

	return argCopy
}

// MinimockInsertTicketDone returns true if the count of the InsertTicket invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockInsertTicketDone() bool {
	if m.InsertTicketMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InsertTicketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InsertTicketMock.invocationsDone()
}

// MinimockInsertTicketInspect logs each unmet expectation
func (m *RepositoryMock) MinimockInsertTicketInspect() {
	for _, e := range m.InsertTicketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.InsertTicket at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInsertTicketCounter := mm_atomic.LoadUint64(&m.afterInsertTicketCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InsertTicketMock.defaultExpectation != nil && afterInsertTicketCounter < 1 {
		if m.InsertTicketMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.InsertTicket at\n%s", m.InsertTicketMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.InsertTicket at\n%s with params: %#v", m.InsertTicketMock.defaultExpectation.expectationOrigins.origin, *m.InsertTicketMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertTicket != nil && afterInsertTicketCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.InsertTicket at\n%s", m.funcInsertTicketOrigin)
	}

	if !m.InsertTicketMock.invocationsDone() && afterInsertTicketCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.InsertTicket at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InsertTicketMock.expectedInvocations), m.InsertTicketMock.expectedInvocationsOrigin, afterInsertTicketCounter)
	}
}

type mRepositoryMockInsertUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockInsertUserExpectation
	expectations       []*RepositoryMockInsertUserExpectation

	callArgs []*RepositoryMockInsertUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockInsertUserExpectation specifies expectation struct of the Repository.InsertUser
type RepositoryMockInsertUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockInsertUserParams
	paramPtrs          *RepositoryMockInsertUserParamPtrs
	expectationOrigins RepositoryMockInsertUserExpectationOrigins
	results            *RepositoryMockInsertUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockInsertUserParams contains parameters of the Repository.InsertUser
type RepositoryMockInsertUserParams struct {
	ctx  context.Context
	user *models.User
}

// RepositoryMockInsertUserParamPtrs contains pointers to parameters of the Repository.InsertUser
type RepositoryMockInsertUserParamPtrs struct {
	ctx  *context.Context
	user **models.User
}

// RepositoryMockInsertUserResults contains results of the Repository.InsertUser
type RepositoryMockInsertUserResults struct {
	i1  int64
	err error
}

// RepositoryMockInsertUserOrigins contains origins of expectations of the Repository.InsertUser
type RepositoryMockInsertUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInsertUser *mRepositoryMockInsertUser) Optional() *mRepositoryMockInsertUser {
	mmInsertUser.optional = true
	return mmInsertUser
}

// Expect sets up expected params for Repository.InsertUser
func (mmInsertUser *mRepositoryMockInsertUser) Expect(ctx context.Context, user *models.User) *mRepositoryMockInsertUser {
	if mmInsertUser.mock.funcInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Set")
	}

	if mmInsertUser.defaultExpectation == nil {
		mmInsertUser.defaultExpectation = &RepositoryMockInsertUserExpectation{}
	}

	if mmInsertUser.defaultExpectation.paramPtrs != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by ExpectParams functions")
	}

	mmInsertUser.defaultExpectation.params = &RepositoryMockInsertUserParams{ctx, user}
	mmInsertUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInsertUser.expectations {
		if minimock.Equal(e.params, mmInsertUser.defaultExpectation.params) {
			mmInsertUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertUser.defaultExpectation.params)
		}
	}

	return mmInsertUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.InsertUser
func (mmInsertUser *mRepositoryMockInsertUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockInsertUser {
	if mmInsertUser.mock.funcInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Set")
	}

	if mmInsertUser.defaultExpectation == nil {
		mmInsertUser.defaultExpectation = &RepositoryMockInsertUserExpectation{}
	}

	if mmInsertUser.defaultExpectation.params != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Expect")
	}

	if mmInsertUser.defaultExpectation.paramPtrs == nil {
		mmInsertUser.defaultExpectation.paramPtrs = &RepositoryMockInsertUserParamPtrs{}
	}
	mmInsertUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmInsertUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInsertUser
}

// ExpectUserParam2 sets up expected param user for Repository.InsertUser
func (mmInsertUser *mRepositoryMockInsertUser) ExpectUserParam2(user *models.User) *mRepositoryMockInsertUser {
	if mmInsertUser.mock.funcInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Set")
	}

	if mmInsertUser.defaultExpectation == nil {
		mmInsertUser.defaultExpectation = &RepositoryMockInsertUserExpectation{}
	}

	if mmInsertUser.defaultExpectation.params != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Expect")
	}

	if mmInsertUser.defaultExpectation.paramPtrs == nil {
		mmInsertUser.defaultExpectation.paramPtrs = &RepositoryMockInsertUserParamPtrs{}
	}
	mmInsertUser.defaultExpectation.paramPtrs.user = &user
	mmInsertUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmInsertUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.InsertUser
func (mmInsertUser *mRepositoryMockInsertUser) Inspect(f func(ctx context.Context, user *models.User)) *mRepositoryMockInsertUser {
	if mmInsertUser.mock.inspectFuncInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.InsertUser")
	}

	mmInsertUser.mock.inspectFuncInsertUser = f

	return mmInsertUser
}

// Return sets up results that will be returned by Repository.InsertUser
func (mmInsertUser *mRepositoryMockInsertUser) Return(i1 int64, err error) *RepositoryMock {
	if mmInsertUser.mock.funcInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Set")
	}

	if mmInsertUser.defaultExpectation == nil {
		mmInsertUser.defaultExpectation = &RepositoryMockInsertUserExpectation{mock: mmInsertUser.mock}
	}
	mmInsertUser.defaultExpectation.results = &RepositoryMockInsertUserResults{i1, err}
	mmInsertUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInsertUser.mock
}

// Set uses given function f to mock the Repository.InsertUser method
func (mmInsertUser *mRepositoryMockInsertUser) Set(f func(ctx context.Context, user *models.User) (i1 int64, err error)) *RepositoryMock {
	if mmInsertUser.defaultExpectation != nil {
		mmInsertUser.mock.t.Fatalf("Default expectation is already set for the Repository.InsertUser method")
	}

	if len(mmInsertUser.expectations) > 0 {
		mmInsertUser.mock.t.Fatalf("Some expectations are already set for the Repository.InsertUser method")
	}

	mmInsertUser.mock.funcInsertUser = f
	mmInsertUser.mock.funcInsertUserOrigin = minimock.CallerInfo(1)
	return mmInsertUser.mock
}

// When sets expectation for the Repository.InsertUser which will trigger the result defined by the following
// Then helper
func (mmInsertUser *mRepositoryMockInsertUser) When(ctx context.Context, user *models.User) *RepositoryMockInsertUserExpectation {
	if mmInsertUser.mock.funcInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Set")
	}

	expectation := &RepositoryMockInsertUserExpectation{
		mock:               mmInsertUser.mock,
		params:             &RepositoryMockInsertUserParams{ctx, user},
		expectationOrigins: RepositoryMockInsertUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInsertUser.expectations = append(mmInsertUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.InsertUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockInsertUserExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockInsertUserResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.InsertUser should be invoked
func (mmInsertUser *mRepositoryMockInsertUser) Times(n uint64) *mRepositoryMockInsertUser {
	if n == 0 {
		mmInsertUser.mock.t.Fatalf("Times of RepositoryMock.InsertUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInsertUser.expectedInvocations, n)
	mmInsertUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInsertUser
}

func (mmInsertUser *mRepositoryMockInsertUser) invocationsDone() bool {
	if len(mmInsertUser.expectations) == 0 && mmInsertUser.defaultExpectation == nil && mmInsertUser.mock.funcInsertUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInsertUser.mock.afterInsertUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInsertUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InsertUser implements mm_repository.Repository
func (mmInsertUser *RepositoryMock) InsertUser(ctx context.Context, user *models.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmInsertUser.beforeInsertUserCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertUser.afterInsertUserCounter, 1)

	mmInsertUser.t.Helper()

	if mmInsertUser.inspectFuncInsertUser != nil {
		mmInsertUser.inspectFuncInsertUser(ctx, user)
	}

	mm_params := RepositoryMockInsertUserParams{ctx, user}

	// Record call args
	mmInsertUser.InsertUserMock.mutex.Lock()
	mmInsertUser.InsertUserMock.callArgs = append(mmInsertUser.InsertUserMock.callArgs, &mm_params)
	mmInsertUser.InsertUserMock.mutex.Unlock()

	for _, e := range mmInsertUser.InsertUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmInsertUser.InsertUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertUser.InsertUserMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertUser.InsertUserMock.defaultExpectation.params
		mm_want_ptrs := mmInsertUser.InsertUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockInsertUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsertUser.t.Errorf("RepositoryMock.InsertUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertUser.InsertUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmInsertUser.t.Errorf("RepositoryMock.InsertUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertUser.InsertUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertUser.t.Errorf("RepositoryMock.InsertUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInsertUser.InsertUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertUser.InsertUserMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertUser.t.Fatal("No results are set for the RepositoryMock.InsertUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmInsertUser.funcInsertUser != nil {
		return mmInsertUser.funcInsertUser(ctx, user)
	}
	mmInsertUser.t.Fatalf("Unexpected call to RepositoryMock.InsertUser. %v %v", ctx, user)
	return
}

// InsertUserAfterCounter returns a count of finished RepositoryMock.InsertUser invocations
func (mmInsertUser *RepositoryMock) InsertUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertUser.afterInsertUserCounter)
}

// InsertUserBeforeCounter returns a count of RepositoryMock.InsertUser invocations
func (mmInsertUser *RepositoryMock) InsertUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertUser.beforeInsertUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.InsertUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertUser *mRepositoryMockInsertUser) Calls() []*RepositoryMockInsertUserParams {
	mmInsertUser.mutex.RLock()

	argCopy := make([]*RepositoryMockInsertUserParams, len(mmInsertUser.callArgs))
	copy(argCopy, mmInsertUser.callArgs)

	mmInsertUser.mutex.RUnlock()

	return argCopy
}

// MinimockInsertUserDone returns true if the count of the InsertUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockInsertUserDone() bool {
	if m.InsertUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InsertUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InsertUserMock.invocationsDone()
}

// MinimockInsertUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockInsertUserInspect() {
	for _, e := range m.InsertUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.InsertUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInsertUserCounter := mm_atomic.LoadUint64(&m.afterInsertUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InsertUserMock.defaultExpectation != nil && afterInsertUserCounter < 1 {
		if m.InsertUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.InsertUser at\n%s", m.InsertUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.InsertUser at\n%s with params: %#v", m.InsertUserMock.defaultExpectation.expectationOrigins.origin, *m.InsertUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertUser != nil && afterInsertUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.InsertUser at\n%s", m.funcInsertUserOrigin)
	}

	if !m.InsertUserMock.invocationsDone() && afterInsertUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.InsertUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InsertUserMock.expectedInvocations), m.InsertUserMock.expectedInvocationsOrigin, afterInsertUserCounter)
	}
}

type mRepositoryMockTicket struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockTicketExpectation
	expectations       []*RepositoryMockTicketExpectation

	callArgs []*RepositoryMockTicketParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockTicketExpectation specifies expectation struct of the Repository.Ticket
type RepositoryMockTicketExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockTicketParams
	paramPtrs          *RepositoryMockTicketParamPtrs
	expectationOrigins RepositoryMockTicketExpectationOrigins
	results            *RepositoryMockTicketResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockTicketParams contains parameters of the Repository.Ticket
type RepositoryMockTicketParams struct {
	ctx      context.Context
	ticketID string
}

// RepositoryMockTicketParamPtrs contains pointers to parameters of the Repository.Ticket
type RepositoryMockTicketParamPtrs struct {
	ctx      *context.Context
	ticketID *string
}

// RepositoryMockTicketResults contains results of the Repository.Ticket
type RepositoryMockTicketResults struct {
	tp1 *models.Ticket
	err error
}

// RepositoryMockTicketOrigins contains origins of expectations of the Repository.Ticket
type RepositoryMockTicketExpectationOrigins struct {
	origin         string
	originCtx      string
	originTicketID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTicket *mRepositoryMockTicket) Optional() *mRepositoryMockTicket {
	mmTicket.optional = true
	return mmTicket
}

// Expect sets up expected params for Repository.Ticket
func (mmTicket *mRepositoryMockTicket) Expect(ctx context.Context, ticketID string) *mRepositoryMockTicket {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("RepositoryMock.Ticket mock is already set by Set")
	}

	if mmTicket.defaultExpectation == nil {
		mmTicket.defaultExpectation = &RepositoryMockTicketExpectation{}
	}

	if mmTicket.defaultExpectation.paramPtrs != nil {
		mmTicket.mock.t.Fatalf("RepositoryMock.Ticket mock is already set by ExpectParams functions")
	}

	mmTicket.defaultExpectation.params = &RepositoryMockTicketParams{ctx, ticketID}
	mmTicket.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTicket.expectations {
		if minimock.Equal(e.params, mmTicket.defaultExpectation.params) {
			mmTicket.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTicket.defaultExpectation.params)
		}
	}

	return mmTicket
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Ticket
func (mmTicket *mRepositoryMockTicket) ExpectCtxParam1(ctx context.Context) *mRepositoryMockTicket {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("RepositoryMock.Ticket mock is already set by Set")
	}

	if mmTicket.defaultExpectation == nil {
		mmTicket.defaultExpectation = &RepositoryMockTicketExpectation{}
	}

	if mmTicket.defaultExpectation.params != nil {
		mmTicket.mock.t.Fatalf("RepositoryMock.Ticket mock is already set by Expect")
	}

	if mmTicket.defaultExpectation.paramPtrs == nil {
		mmTicket.defaultExpectation.paramPtrs = &RepositoryMockTicketParamPtrs{}
	}
	mmTicket.defaultExpectation.paramPtrs.ctx = &ctx
	mmTicket.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTicket
}

// ExpectTicketIDParam2 sets up expected param ticketID for Repository.Ticket
func (mmTicket *mRepositoryMockTicket) ExpectTicketIDParam2(ticketID string) *mRepositoryMockTicket {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("RepositoryMock.Ticket mock is already set by Set")
	}

	if mmTicket.defaultExpectation == nil {
		mmTicket.defaultExpectation = &RepositoryMockTicketExpectation{}
	}

	if mmTicket.defaultExpectation.params != nil {
		mmTicket.mock.t.Fatalf("RepositoryMock.Ticket mock is already set by Expect")
	}

	if mmTicket.defaultExpectation.paramPtrs == nil {
		mmTicket.defaultExpectation.paramPtrs = &RepositoryMockTicketParamPtrs{}
	}
	mmTicket.defaultExpectation.paramPtrs.ticketID = &ticketID
	mmTicket.defaultExpectation.expectationOrigins.originTicketID = minimock.CallerInfo(1)

	return mmTicket
}

// Inspect accepts an inspector function that has same arguments as the Repository.Ticket
func (mmTicket *mRepositoryMockTicket) Inspect(f func(ctx context.Context, ticketID string)) *mRepositoryMockTicket {
	if mmTicket.mock.inspectFuncTicket != nil {
		mmTicket.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Ticket")
	}

	mmTicket.mock.inspectFuncTicket = f

	return mmTicket
}

// Return sets up results that will be returned by Repository.Ticket
func (mmTicket *mRepositoryMockTicket) Return(tp1 *models.Ticket, err error) *RepositoryMock {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("RepositoryMock.Ticket mock is already set by Set")
	}

	if mmTicket.defaultExpectation == nil {
		mmTicket.defaultExpectation = &RepositoryMockTicketExpectation{mock: mmTicket.mock}
	}
	mmTicket.defaultExpectation.results = &RepositoryMockTicketResults{tp1, err}
	mmTicket.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTicket.mock
}

// Set uses given function f to mock the Repository.Ticket method
func (mmTicket *mRepositoryMockTicket) Set(f func(ctx context.Context, ticketID string) (tp1 *models.Ticket, err error)) *RepositoryMock {
	if mmTicket.defaultExpectation != nil {
		mmTicket.mock.t.Fatalf("Default expectation is already set for the Repository.Ticket method")
	}

	if len(mmTicket.expectations) > 0 {
		mmTicket.mock.t.Fatalf("Some expectations are already set for the Repository.Ticket method")
	}

	mmTicket.mock.funcTicket = f
	mmTicket.mock.funcTicketOrigin = minimock.CallerInfo(1)
	return mmTicket.mock
}

// When sets expectation for the Repository.Ticket which will trigger the result defined by the following
// Then helper
func (mmTicket *mRepositoryMockTicket) When(ctx context.Context, ticketID string) *RepositoryMockTicketExpectation {
	if mmTicket.mock.funcTicket != nil {
		mmTicket.mock.t.Fatalf("RepositoryMock.Ticket mock is already set by Set")
	}

	expectation := &RepositoryMockTicketExpectation{
		mock:               mmTicket.mock,
		params:             &RepositoryMockTicketParams{ctx, ticketID},
		expectationOrigins: RepositoryMockTicketExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTicket.expectations = append(mmTicket.expectations, expectation)
	return expectation
}

// Then sets up Repository.Ticket return parameters for the expectation previously defined by the When method
func (e *RepositoryMockTicketExpectation) Then(tp1 *models.Ticket, err error) *RepositoryMock {
	e.results = &RepositoryMockTicketResults{tp1, err}
	return e.mock
}

// Times sets number of times Repository.Ticket should be invoked
func (mmTicket *mRepositoryMockTicket) Times(n uint64) *mRepositoryMockTicket {
	if n == 0 {
		mmTicket.mock.t.Fatalf("Times of RepositoryMock.Ticket mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTicket.expectedInvocations, n)
	mmTicket.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTicket
}

func (mmTicket *mRepositoryMockTicket) invocationsDone() bool {
	if len(mmTicket.expectations) == 0 && mmTicket.defaultExpectation == nil && mmTicket.mock.funcTicket == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTicket.mock.afterTicketCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTicket.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Ticket implements mm_repository.Repository
func (mmTicket *RepositoryMock) Ticket(ctx context.Context, ticketID string) (tp1 *models.Ticket, err error) {
	mm_atomic.AddUint64(&mmTicket.beforeTicketCounter, 1)
	defer mm_atomic.AddUint64(&mmTicket.afterTicketCounter, 1)

	mmTicket.t.Helper()

	if mmTicket.inspectFuncTicket != nil {
		mmTicket.inspectFuncTicket(ctx, ticketID)
	}

	mm_params := RepositoryMockTicketParams{ctx, ticketID}

	// Record call args
	mmTicket.TicketMock.mutex.Lock()
	mmTicket.TicketMock.callArgs = append(mmTicket.TicketMock.callArgs, &mm_params)
	mmTicket.TicketMock.mutex.Unlock()

	for _, e := range mmTicket.TicketMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmTicket.TicketMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTicket.TicketMock.defaultExpectation.Counter, 1)
		mm_want := mmTicket.TicketMock.defaultExpectation.params
		mm_want_ptrs := mmTicket.TicketMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockTicketParams{ctx, ticketID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTicket.t.Errorf("RepositoryMock.Ticket got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTicket.TicketMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ticketID != nil && !minimock.Equal(*mm_want_ptrs.ticketID, mm_got.ticketID) {
				mmTicket.t.Errorf("RepositoryMock.Ticket got unexpected parameter ticketID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTicket.TicketMock.defaultExpectation.expectationOrigins.originTicketID, *mm_want_ptrs.ticketID, mm_got.ticketID, minimock.Diff(*mm_want_ptrs.ticketID, mm_got.ticketID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTicket.t.Errorf("RepositoryMock.Ticket got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTicket.TicketMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTicket.TicketMock.defaultExpectation.results
		if mm_results == nil {
			mmTicket.t.Fatal("No results are set for the RepositoryMock.Ticket")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmTicket.funcTicket != nil {
		return mmTicket.funcTicket(ctx, ticketID)
	}
	mmTicket.t.Fatalf("Unexpected call to RepositoryMock.Ticket. %v %v", ctx, ticketID)
	return
}

// TicketAfterCounter returns a count of finished RepositoryMock.Ticket invocations
func (mmTicket *RepositoryMock) TicketAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTicket.afterTicketCounter)
}

// TicketBeforeCounter returns a count of RepositoryMock.Ticket invocations
func (mmTicket *RepositoryMock) TicketBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTicket.beforeTicketCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Ticket.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTicket *mRepositoryMockTicket) Calls() []*RepositoryMockTicketParams {
	mmTicket.mutex.RLock()

	argCopy := make([]*RepositoryMockTicketParams, len(mmTicket.callArgs))
	copy(argCopy, mmTicket.callArgs)

	mmTicket.mutex.RUnlock()

	return argCopy
}

// MinimockTicketDone returns true if the count of the Ticket invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockTicketDone() bool {
	if m.TicketMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TicketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TicketMock.invocationsDone()
}

// MinimockTicketInspect logs each unmet expectation
func (m *RepositoryMock) MinimockTicketInspect() {
	for _, e := range m.TicketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Ticket at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTicketCounter := mm_atomic.LoadUint64(&m.afterTicketCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TicketMock.defaultExpectation != nil && afterTicketCounter < 1 {
		if m.TicketMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Ticket at\n%s", m.TicketMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Ticket at\n%s with params: %#v", m.TicketMock.defaultExpectation.expectationOrigins.origin, *m.TicketMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTicket != nil && afterTicketCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Ticket at\n%s", m.funcTicketOrigin)
	}

	if !m.TicketMock.invocationsDone() && afterTicketCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Ticket at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TicketMock.expectedInvocations), m.TicketMock.expectedInvocationsOrigin, afterTicketCounter)
	}
}

type mRepositoryMockUpdateEvent struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateEventExpectation
	expectations       []*RepositoryMockUpdateEventExpectation

	callArgs []*RepositoryMockUpdateEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateEventExpectation specifies expectation struct of the Repository.UpdateEvent
type RepositoryMockUpdateEventExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateEventParams
	paramPtrs          *RepositoryMockUpdateEventParamPtrs
	expectationOrigins RepositoryMockUpdateEventExpectationOrigins
	results            *RepositoryMockUpdateEventResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateEventParams contains parameters of the Repository.UpdateEvent
type RepositoryMockUpdateEventParams struct {
	ctx   context.Context
	event *models.Event
}

// RepositoryMockUpdateEventParamPtrs contains pointers to parameters of the Repository.UpdateEvent
type RepositoryMockUpdateEventParamPtrs struct {
	ctx   *context.Context
	event **models.Event
}

// RepositoryMockUpdateEventResults contains results of the Repository.UpdateEvent
type RepositoryMockUpdateEventResults struct {
	err error
}

// RepositoryMockUpdateEventOrigins contains origins of expectations of the Repository.UpdateEvent
type RepositoryMockUpdateEventExpectationOrigins struct {
	origin      string
	originCtx   string
	originEvent string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateEvent *mRepositoryMockUpdateEvent) Optional() *mRepositoryMockUpdateEvent {
	mmUpdateEvent.optional = true
	return mmUpdateEvent
}

// Expect sets up expected params for Repository.UpdateEvent
func (mmUpdateEvent *mRepositoryMockUpdateEvent) Expect(ctx context.Context, event *models.Event) *mRepositoryMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("RepositoryMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &RepositoryMockUpdateEventExpectation{}
	}

	if mmUpdateEvent.defaultExpectation.paramPtrs != nil {
		mmUpdateEvent.mock.t.Fatalf("RepositoryMock.UpdateEvent mock is already set by ExpectParams functions")
	}

	mmUpdateEvent.defaultExpectation.params = &RepositoryMockUpdateEventParams{ctx, event}
	mmUpdateEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateEvent.expectations {
		if minimock.Equal(e.params, mmUpdateEvent.defaultExpectation.params) {
			mmUpdateEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateEvent.defaultExpectation.params)
		}
	}

	return mmUpdateEvent
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateEvent
func (mmUpdateEvent *mRepositoryMockUpdateEvent) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("RepositoryMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &RepositoryMockUpdateEventExpectation{}
	}

	if mmUpdateEvent.defaultExpectation.params != nil {
		mmUpdateEvent.mock.t.Fatalf("RepositoryMock.UpdateEvent mock is already set by Expect")
	}

	if mmUpdateEvent.defaultExpectation.paramPtrs == nil {
		mmUpdateEvent.defaultExpectation.paramPtrs = &RepositoryMockUpdateEventParamPtrs{}
	}
	mmUpdateEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateEvent
}

// ExpectEventParam2 sets up expected param event for Repository.UpdateEvent
func (mmUpdateEvent *mRepositoryMockUpdateEvent) ExpectEventParam2(event *models.Event) *mRepositoryMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("RepositoryMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &RepositoryMockUpdateEventExpectation{}
	}

	if mmUpdateEvent.defaultExpectation.params != nil {
		mmUpdateEvent.mock.t.Fatalf("RepositoryMock.UpdateEvent mock is already set by Expect")
	}

	if mmUpdateEvent.defaultExpectation.paramPtrs == nil {
		mmUpdateEvent.defaultExpectation.paramPtrs = &RepositoryMockUpdateEventParamPtrs{}
	}
	mmUpdateEvent.defaultExpectation.paramPtrs.event = &event
	mmUpdateEvent.defaultExpectation.expectationOrigins.originEvent = minimock.CallerInfo(1)

	return mmUpdateEvent
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateEvent
func (mmUpdateEvent *mRepositoryMockUpdateEvent) Inspect(f func(ctx context.Context, event *models.Event)) *mRepositoryMockUpdateEvent {
	if mmUpdateEvent.mock.inspectFuncUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateEvent")
	}

	mmUpdateEvent.mock.inspectFuncUpdateEvent = f

	return mmUpdateEvent
}

// Return sets up results that will be returned by Repository.UpdateEvent
func (mmUpdateEvent *mRepositoryMockUpdateEvent) Return(err error) *RepositoryMock {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("RepositoryMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &RepositoryMockUpdateEventExpectation{mock: mmUpdateEvent.mock}
	}
	mmUpdateEvent.defaultExpectation.results = &RepositoryMockUpdateEventResults{err}
	mmUpdateEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateEvent.mock
}

// Set uses given function f to mock the Repository.UpdateEvent method
func (mmUpdateEvent *mRepositoryMockUpdateEvent) Set(f func(ctx context.Context, event *models.Event) (err error)) *RepositoryMock {
	if mmUpdateEvent.defaultExpectation != nil {
		mmUpdateEvent.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateEvent method")
	}

	if len(mmUpdateEvent.expectations) > 0 {
		mmUpdateEvent.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateEvent method")
	}

	mmUpdateEvent.mock.funcUpdateEvent = f
	mmUpdateEvent.mock.funcUpdateEventOrigin = minimock.CallerInfo(1)
	return mmUpdateEvent.mock
}

// When sets expectation for the Repository.UpdateEvent which will trigger the result defined by the following
// Then helper
func (mmUpdateEvent *mRepositoryMockUpdateEvent) When(ctx context.Context, event *models.Event) *RepositoryMockUpdateEventExpectation {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("RepositoryMock.UpdateEvent mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateEventExpectation{
		mock:               mmUpdateEvent.mock,
		params:             &RepositoryMockUpdateEventParams{ctx, event},
		expectationOrigins: RepositoryMockUpdateEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateEvent.expectations = append(mmUpdateEvent.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateEvent return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateEventExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateEventResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateEvent should be invoked
func (mmUpdateEvent *mRepositoryMockUpdateEvent) Times(n uint64) *mRepositoryMockUpdateEvent {
	if n == 0 {
		mmUpdateEvent.mock.t.Fatalf("Times of RepositoryMock.UpdateEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateEvent.expectedInvocations, n)
	mmUpdateEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateEvent
}

func (mmUpdateEvent *mRepositoryMockUpdateEvent) invocationsDone() bool {
	if len(mmUpdateEvent.expectations) == 0 && mmUpdateEvent.defaultExpectation == nil && mmUpdateEvent.mock.funcUpdateEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateEvent.mock.afterUpdateEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateEvent implements mm_repository.Repository
func (mmUpdateEvent *RepositoryMock) UpdateEvent(ctx context.Context, event *models.Event) (err error) {
	mm_atomic.AddUint64(&mmUpdateEvent.beforeUpdateEventCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateEvent.afterUpdateEventCounter, 1)

	mmUpdateEvent.t.Helper()

	if mmUpdateEvent.inspectFuncUpdateEvent != nil {
		mmUpdateEvent.inspectFuncUpdateEvent(ctx, event)
	}

	mm_params := RepositoryMockUpdateEventParams{ctx, event}

	// Record call args
	mmUpdateEvent.UpdateEventMock.mutex.Lock()
	mmUpdateEvent.UpdateEventMock.callArgs = append(mmUpdateEvent.UpdateEventMock.callArgs, &mm_params)
	mmUpdateEvent.UpdateEventMock.mutex.Unlock()

	for _, e := range mmUpdateEvent.UpdateEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateEvent.UpdateEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateEvent.UpdateEventMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateEvent.UpdateEventMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateEvent.UpdateEventMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateEventParams{ctx, event}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateEvent.t.Errorf("RepositoryMock.UpdateEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEvent.UpdateEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.event != nil && !minimock.Equal(*mm_want_ptrs.event, mm_got.event) {
				mmUpdateEvent.t.Errorf("RepositoryMock.UpdateEvent got unexpected parameter event, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEvent.UpdateEventMock.defaultExpectation.expectationOrigins.originEvent, *mm_want_ptrs.event, mm_got.event, minimock.Diff(*mm_want_ptrs.event, mm_got.event))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateEvent.t.Errorf("RepositoryMock.UpdateEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateEvent.UpdateEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateEvent.UpdateEventMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateEvent.t.Fatal("No results are set for the RepositoryMock.UpdateEvent")
		}
		return (*mm_results).err
	}
	if mmUpdateEvent.funcUpdateEvent != nil {
		return mmUpdateEvent.funcUpdateEvent(ctx, event)
	}
	mmUpdateEvent.t.Fatalf("Unexpected call to RepositoryMock.UpdateEvent. %v %v", ctx, event)
	return
}

// UpdateEventAfterCounter returns a count of finished RepositoryMock.UpdateEvent invocations
func (mmUpdateEvent *RepositoryMock) UpdateEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEvent.afterUpdateEventCounter)
}

// UpdateEventBeforeCounter returns a count of RepositoryMock.UpdateEvent invocations
func (mmUpdateEvent *RepositoryMock) UpdateEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEvent.beforeUpdateEventCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateEvent *mRepositoryMockUpdateEvent) Calls() []*RepositoryMockUpdateEventParams {
	mmUpdateEvent.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateEventParams, len(mmUpdateEvent.callArgs))
	copy(argCopy, mmUpdateEvent.callArgs)

	mmUpdateEvent.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateEventDone returns true if the count of the UpdateEvent invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateEventDone() bool {
	if m.UpdateEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateEventMock.invocationsDone()
}

// MinimockUpdateEventInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateEventInspect() {
	for _, e := range m.UpdateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateEventCounter := mm_atomic.LoadUint64(&m.afterUpdateEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateEventMock.defaultExpectation != nil && afterUpdateEventCounter < 1 {
		if m.UpdateEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateEvent at\n%s", m.UpdateEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateEvent at\n%s with params: %#v", m.UpdateEventMock.defaultExpectation.expectationOrigins.origin, *m.UpdateEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateEvent != nil && afterUpdateEventCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateEvent at\n%s", m.funcUpdateEventOrigin)
	}

	if !m.UpdateEventMock.invocationsDone() && afterUpdateEventCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateEventMock.expectedInvocations), m.UpdateEventMock.expectedInvocationsOrigin, afterUpdateEventCounter)
	}
}

type mRepositoryMockUpdateUserTGUsername struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateUserTGUsernameExpectation
	expectations       []*RepositoryMockUpdateUserTGUsernameExpectation

	callArgs []*RepositoryMockUpdateUserTGUsernameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateUserTGUsernameExpectation specifies expectation struct of the Repository.UpdateUserTGUsername
type RepositoryMockUpdateUserTGUsernameExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateUserTGUsernameParams
	paramPtrs          *RepositoryMockUpdateUserTGUsernameParamPtrs
	expectationOrigins RepositoryMockUpdateUserTGUsernameExpectationOrigins
	results            *RepositoryMockUpdateUserTGUsernameResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateUserTGUsernameParams contains parameters of the Repository.UpdateUserTGUsername
type RepositoryMockUpdateUserTGUsernameParams struct {
	ctx      context.Context
	userID   int64
	username string
}

// RepositoryMockUpdateUserTGUsernameParamPtrs contains pointers to parameters of the Repository.UpdateUserTGUsername
type RepositoryMockUpdateUserTGUsernameParamPtrs struct {
	ctx      *context.Context
	userID   *int64
	username *string
}

// RepositoryMockUpdateUserTGUsernameResults contains results of the Repository.UpdateUserTGUsername
type RepositoryMockUpdateUserTGUsernameResults struct {
	err error
}

// RepositoryMockUpdateUserTGUsernameOrigins contains origins of expectations of the Repository.UpdateUserTGUsername
type RepositoryMockUpdateUserTGUsernameExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserID   string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUserTGUsername *mRepositoryMockUpdateUserTGUsername) Optional() *mRepositoryMockUpdateUserTGUsername {
	mmUpdateUserTGUsername.optional = true
	return mmUpdateUserTGUsername
}

// Expect sets up expected params for Repository.UpdateUserTGUsername
func (mmUpdateUserTGUsername *mRepositoryMockUpdateUserTGUsername) Expect(ctx context.Context, userID int64, username string) *mRepositoryMockUpdateUserTGUsername {
	if mmUpdateUserTGUsername.mock.funcUpdateUserTGUsername != nil {
		mmUpdateUserTGUsername.mock.t.Fatalf("RepositoryMock.UpdateUserTGUsername mock is already set by Set")
	}

	if mmUpdateUserTGUsername.defaultExpectation == nil {
		mmUpdateUserTGUsername.defaultExpectation = &RepositoryMockUpdateUserTGUsernameExpectation{}
	}

	if mmUpdateUserTGUsername.defaultExpectation.paramPtrs != nil {
		mmUpdateUserTGUsername.mock.t.Fatalf("RepositoryMock.UpdateUserTGUsername mock is already set by ExpectParams functions")
	}

	mmUpdateUserTGUsername.defaultExpectation.params = &RepositoryMockUpdateUserTGUsernameParams{ctx, userID, username}
	mmUpdateUserTGUsername.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUserTGUsername.expectations {
		if minimock.Equal(e.params, mmUpdateUserTGUsername.defaultExpectation.params) {
			mmUpdateUserTGUsername.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUserTGUsername.defaultExpectation.params)
		}
	}

	return mmUpdateUserTGUsername
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateUserTGUsername
func (mmUpdateUserTGUsername *mRepositoryMockUpdateUserTGUsername) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateUserTGUsername {
	if mmUpdateUserTGUsername.mock.funcUpdateUserTGUsername != nil {
		mmUpdateUserTGUsername.mock.t.Fatalf("RepositoryMock.UpdateUserTGUsername mock is already set by Set")
	}

	if mmUpdateUserTGUsername.defaultExpectation == nil {
		mmUpdateUserTGUsername.defaultExpectation = &RepositoryMockUpdateUserTGUsernameExpectation{}
	}

	if mmUpdateUserTGUsername.defaultExpectation.params != nil {
		mmUpdateUserTGUsername.mock.t.Fatalf("RepositoryMock.UpdateUserTGUsername mock is already set by Expect")
	}

	if mmUpdateUserTGUsername.defaultExpectation.paramPtrs == nil {
		mmUpdateUserTGUsername.defaultExpectation.paramPtrs = &RepositoryMockUpdateUserTGUsernameParamPtrs{}
	}
	mmUpdateUserTGUsername.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUserTGUsername.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUserTGUsername
}

// ExpectUserIDParam2 sets up expected param userID for Repository.UpdateUserTGUsername
func (mmUpdateUserTGUsername *mRepositoryMockUpdateUserTGUsername) ExpectUserIDParam2(userID int64) *mRepositoryMockUpdateUserTGUsername {
	if mmUpdateUserTGUsername.mock.funcUpdateUserTGUsername != nil {
		mmUpdateUserTGUsername.mock.t.Fatalf("RepositoryMock.UpdateUserTGUsername mock is already set by Set")
	}

	if mmUpdateUserTGUsername.defaultExpectation == nil {
		mmUpdateUserTGUsername.defaultExpectation = &RepositoryMockUpdateUserTGUsernameExpectation{}
	}

	if mmUpdateUserTGUsername.defaultExpectation.params != nil {
		mmUpdateUserTGUsername.mock.t.Fatalf("RepositoryMock.UpdateUserTGUsername mock is already set by Expect")
	}

	if mmUpdateUserTGUsername.defaultExpectation.paramPtrs == nil {
		mmUpdateUserTGUsername.defaultExpectation.paramPtrs = &RepositoryMockUpdateUserTGUsernameParamPtrs{}
	}
	mmUpdateUserTGUsername.defaultExpectation.paramPtrs.userID = &userID
	mmUpdateUserTGUsername.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUpdateUserTGUsername
}

// ExpectUsernameParam3 sets up expected param username for Repository.UpdateUserTGUsername
func (mmUpdateUserTGUsername *mRepositoryMockUpdateUserTGUsername) ExpectUsernameParam3(username string) *mRepositoryMockUpdateUserTGUsername {
	if mmUpdateUserTGUsername.mock.funcUpdateUserTGUsername != nil {
		mmUpdateUserTGUsername.mock.t.Fatalf("RepositoryMock.UpdateUserTGUsername mock is already set by Set")
	}

	if mmUpdateUserTGUsername.defaultExpectation == nil {
		mmUpdateUserTGUsername.defaultExpectation = &RepositoryMockUpdateUserTGUsernameExpectation{}
	}

	if mmUpdateUserTGUsername.defaultExpectation.params != nil {
		mmUpdateUserTGUsername.mock.t.Fatalf("RepositoryMock.UpdateUserTGUsername mock is already set by Expect")
	}

	if mmUpdateUserTGUsername.defaultExpectation.paramPtrs == nil {
		mmUpdateUserTGUsername.defaultExpectation.paramPtrs = &RepositoryMockUpdateUserTGUsernameParamPtrs{}
	}
	mmUpdateUserTGUsername.defaultExpectation.paramPtrs.username = &username
	mmUpdateUserTGUsername.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmUpdateUserTGUsername
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateUserTGUsername
func (mmUpdateUserTGUsername *mRepositoryMockUpdateUserTGUsername) Inspect(f func(ctx context.Context, userID int64, username string)) *mRepositoryMockUpdateUserTGUsername {
	if mmUpdateUserTGUsername.mock.inspectFuncUpdateUserTGUsername != nil {
		mmUpdateUserTGUsername.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateUserTGUsername")
	}

	mmUpdateUserTGUsername.mock.inspectFuncUpdateUserTGUsername = f

	return mmUpdateUserTGUsername
}

// Return sets up results that will be returned by Repository.UpdateUserTGUsername
func (mmUpdateUserTGUsername *mRepositoryMockUpdateUserTGUsername) Return(err error) *RepositoryMock {
	if mmUpdateUserTGUsername.mock.funcUpdateUserTGUsername != nil {
		mmUpdateUserTGUsername.mock.t.Fatalf("RepositoryMock.UpdateUserTGUsername mock is already set by Set")
	}

	if mmUpdateUserTGUsername.defaultExpectation == nil {
		mmUpdateUserTGUsername.defaultExpectation = &RepositoryMockUpdateUserTGUsernameExpectation{mock: mmUpdateUserTGUsername.mock}
	}
	mmUpdateUserTGUsername.defaultExpectation.results = &RepositoryMockUpdateUserTGUsernameResults{err}
	mmUpdateUserTGUsername.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUserTGUsername.mock
}

// Set uses given function f to mock the Repository.UpdateUserTGUsername method
func (mmUpdateUserTGUsername *mRepositoryMockUpdateUserTGUsername) Set(f func(ctx context.Context, userID int64, username string) (err error)) *RepositoryMock {
	if mmUpdateUserTGUsername.defaultExpectation != nil {
		mmUpdateUserTGUsername.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateUserTGUsername method")
	}

	if len(mmUpdateUserTGUsername.expectations) > 0 {
		mmUpdateUserTGUsername.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateUserTGUsername method")
	}

	mmUpdateUserTGUsername.mock.funcUpdateUserTGUsername = f
	mmUpdateUserTGUsername.mock.funcUpdateUserTGUsernameOrigin = minimock.CallerInfo(1)
	return mmUpdateUserTGUsername.mock
}

// When sets expectation for the Repository.UpdateUserTGUsername which will trigger the result defined by the following
// Then helper
func (mmUpdateUserTGUsername *mRepositoryMockUpdateUserTGUsername) When(ctx context.Context, userID int64, username string) *RepositoryMockUpdateUserTGUsernameExpectation {
	if mmUpdateUserTGUsername.mock.funcUpdateUserTGUsername != nil {
		mmUpdateUserTGUsername.mock.t.Fatalf("RepositoryMock.UpdateUserTGUsername mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateUserTGUsernameExpectation{
		mock:               mmUpdateUserTGUsername.mock,
		params:             &RepositoryMockUpdateUserTGUsernameParams{ctx, userID, username},
		expectationOrigins: RepositoryMockUpdateUserTGUsernameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUserTGUsername.expectations = append(mmUpdateUserTGUsername.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateUserTGUsername return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateUserTGUsernameExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateUserTGUsernameResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateUserTGUsername should be invoked
func (mmUpdateUserTGUsername *mRepositoryMockUpdateUserTGUsername) Times(n uint64) *mRepositoryMockUpdateUserTGUsername {
	if n == 0 {
		mmUpdateUserTGUsername.mock.t.Fatalf("Times of RepositoryMock.UpdateUserTGUsername mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUserTGUsername.expectedInvocations, n)
	mmUpdateUserTGUsername.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUserTGUsername
}

func (mmUpdateUserTGUsername *mRepositoryMockUpdateUserTGUsername) invocationsDone() bool {
	if len(mmUpdateUserTGUsername.expectations) == 0 && mmUpdateUserTGUsername.defaultExpectation == nil && mmUpdateUserTGUsername.mock.funcUpdateUserTGUsername == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUserTGUsername.mock.afterUpdateUserTGUsernameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUserTGUsername.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUserTGUsername implements mm_repository.Repository
func (mmUpdateUserTGUsername *RepositoryMock) UpdateUserTGUsername(ctx context.Context, userID int64, username string) (err error) {
	mm_atomic.AddUint64(&mmUpdateUserTGUsername.beforeUpdateUserTGUsernameCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUserTGUsername.afterUpdateUserTGUsernameCounter, 1)

	mmUpdateUserTGUsername.t.Helper()

	if mmUpdateUserTGUsername.inspectFuncUpdateUserTGUsername != nil {
		mmUpdateUserTGUsername.inspectFuncUpdateUserTGUsername(ctx, userID, username)
	}

	mm_params := RepositoryMockUpdateUserTGUsernameParams{ctx, userID, username}

	// Record call args
	mmUpdateUserTGUsername.UpdateUserTGUsernameMock.mutex.Lock()
	mmUpdateUserTGUsername.UpdateUserTGUsernameMock.callArgs = append(mmUpdateUserTGUsername.UpdateUserTGUsernameMock.callArgs, &mm_params)
	mmUpdateUserTGUsername.UpdateUserTGUsernameMock.mutex.Unlock()

	for _, e := range mmUpdateUserTGUsername.UpdateUserTGUsernameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUserTGUsername.UpdateUserTGUsernameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUserTGUsername.UpdateUserTGUsernameMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUserTGUsername.UpdateUserTGUsernameMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUserTGUsername.UpdateUserTGUsernameMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateUserTGUsernameParams{ctx, userID, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUserTGUsername.t.Errorf("RepositoryMock.UpdateUserTGUsername got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserTGUsername.UpdateUserTGUsernameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUpdateUserTGUsername.t.Errorf("RepositoryMock.UpdateUserTGUsername got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserTGUsername.UpdateUserTGUsernameMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmUpdateUserTGUsername.t.Errorf("RepositoryMock.UpdateUserTGUsername got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserTGUsername.UpdateUserTGUsernameMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUserTGUsername.t.Errorf("RepositoryMock.UpdateUserTGUsername got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUserTGUsername.UpdateUserTGUsernameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUserTGUsername.UpdateUserTGUsernameMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUserTGUsername.t.Fatal("No results are set for the RepositoryMock.UpdateUserTGUsername")
		}
		return (*mm_results).err
	}
	if mmUpdateUserTGUsername.funcUpdateUserTGUsername != nil {
		return mmUpdateUserTGUsername.funcUpdateUserTGUsername(ctx, userID, username)
	}
	mmUpdateUserTGUsername.t.Fatalf("Unexpected call to RepositoryMock.UpdateUserTGUsername. %v %v %v", ctx, userID, username)
	return
}

// UpdateUserTGUsernameAfterCounter returns a count of finished RepositoryMock.UpdateUserTGUsername invocations
func (mmUpdateUserTGUsername *RepositoryMock) UpdateUserTGUsernameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserTGUsername.afterUpdateUserTGUsernameCounter)
}

// UpdateUserTGUsernameBeforeCounter returns a count of RepositoryMock.UpdateUserTGUsername invocations
func (mmUpdateUserTGUsername *RepositoryMock) UpdateUserTGUsernameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserTGUsername.beforeUpdateUserTGUsernameCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateUserTGUsername.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUserTGUsername *mRepositoryMockUpdateUserTGUsername) Calls() []*RepositoryMockUpdateUserTGUsernameParams {
	mmUpdateUserTGUsername.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateUserTGUsernameParams, len(mmUpdateUserTGUsername.callArgs))
	copy(argCopy, mmUpdateUserTGUsername.callArgs)

	mmUpdateUserTGUsername.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserTGUsernameDone returns true if the count of the UpdateUserTGUsername invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateUserTGUsernameDone() bool {
	if m.UpdateUserTGUsernameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserTGUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserTGUsernameMock.invocationsDone()
}

// MinimockUpdateUserTGUsernameInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateUserTGUsernameInspect() {
	for _, e := range m.UpdateUserTGUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUserTGUsername at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserTGUsernameCounter := mm_atomic.LoadUint64(&m.afterUpdateUserTGUsernameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserTGUsernameMock.defaultExpectation != nil && afterUpdateUserTGUsernameCounter < 1 {
		if m.UpdateUserTGUsernameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUserTGUsername at\n%s", m.UpdateUserTGUsernameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUserTGUsername at\n%s with params: %#v", m.UpdateUserTGUsernameMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserTGUsernameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUserTGUsername != nil && afterUpdateUserTGUsernameCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateUserTGUsername at\n%s", m.funcUpdateUserTGUsernameOrigin)
	}

	if !m.UpdateUserTGUsernameMock.invocationsDone() && afterUpdateUserTGUsernameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateUserTGUsername at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserTGUsernameMock.expectedInvocations), m.UpdateUserTGUsernameMock.expectedInvocationsOrigin, afterUpdateUserTGUsernameCounter)
	}
}

type mRepositoryMockUpdateYookassaSettings struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateYookassaSettingsExpectation
	expectations       []*RepositoryMockUpdateYookassaSettingsExpectation

	callArgs []*RepositoryMockUpdateYookassaSettingsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateYookassaSettingsExpectation specifies expectation struct of the Repository.UpdateYookassaSettings
type RepositoryMockUpdateYookassaSettingsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateYookassaSettingsParams
	paramPtrs          *RepositoryMockUpdateYookassaSettingsParamPtrs
	expectationOrigins RepositoryMockUpdateYookassaSettingsExpectationOrigins
	results            *RepositoryMockUpdateYookassaSettingsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateYookassaSettingsParams contains parameters of the Repository.UpdateYookassaSettings
type RepositoryMockUpdateYookassaSettingsParams struct {
	ctx      context.Context
	settings *models.YookassaSettings
}

// RepositoryMockUpdateYookassaSettingsParamPtrs contains pointers to parameters of the Repository.UpdateYookassaSettings
type RepositoryMockUpdateYookassaSettingsParamPtrs struct {
	ctx      *context.Context
	settings **models.YookassaSettings
}

// RepositoryMockUpdateYookassaSettingsResults contains results of the Repository.UpdateYookassaSettings
type RepositoryMockUpdateYookassaSettingsResults struct {
	err error
}

// RepositoryMockUpdateYookassaSettingsOrigins contains origins of expectations of the Repository.UpdateYookassaSettings
type RepositoryMockUpdateYookassaSettingsExpectationOrigins struct {
	origin         string
	originCtx      string
	originSettings string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateYookassaSettings *mRepositoryMockUpdateYookassaSettings) Optional() *mRepositoryMockUpdateYookassaSettings {
	mmUpdateYookassaSettings.optional = true
	return mmUpdateYookassaSettings
}

// Expect sets up expected params for Repository.UpdateYookassaSettings
func (mmUpdateYookassaSettings *mRepositoryMockUpdateYookassaSettings) Expect(ctx context.Context, settings *models.YookassaSettings) *mRepositoryMockUpdateYookassaSettings {
	if mmUpdateYookassaSettings.mock.funcUpdateYookassaSettings != nil {
		mmUpdateYookassaSettings.mock.t.Fatalf("RepositoryMock.UpdateYookassaSettings mock is already set by Set")
	}

	if mmUpdateYookassaSettings.defaultExpectation == nil {
		mmUpdateYookassaSettings.defaultExpectation = &RepositoryMockUpdateYookassaSettingsExpectation{}
	}

	if mmUpdateYookassaSettings.defaultExpectation.paramPtrs != nil {
		mmUpdateYookassaSettings.mock.t.Fatalf("RepositoryMock.UpdateYookassaSettings mock is already set by ExpectParams functions")
	}

	mmUpdateYookassaSettings.defaultExpectation.params = &RepositoryMockUpdateYookassaSettingsParams{ctx, settings}
	mmUpdateYookassaSettings.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateYookassaSettings.expectations {
		if minimock.Equal(e.params, mmUpdateYookassaSettings.defaultExpectation.params) {
			mmUpdateYookassaSettings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateYookassaSettings.defaultExpectation.params)
		}
	}

	return mmUpdateYookassaSettings
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateYookassaSettings
func (mmUpdateYookassaSettings *mRepositoryMockUpdateYookassaSettings) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateYookassaSettings {
	if mmUpdateYookassaSettings.mock.funcUpdateYookassaSettings != nil {
		mmUpdateYookassaSettings.mock.t.Fatalf("RepositoryMock.UpdateYookassaSettings mock is already set by Set")
	}

	if mmUpdateYookassaSettings.defaultExpectation == nil {
		mmUpdateYookassaSettings.defaultExpectation = &RepositoryMockUpdateYookassaSettingsExpectation{}
	}

	if mmUpdateYookassaSettings.defaultExpectation.params != nil {
		mmUpdateYookassaSettings.mock.t.Fatalf("RepositoryMock.UpdateYookassaSettings mock is already set by Expect")
	}

	if mmUpdateYookassaSettings.defaultExpectation.paramPtrs == nil {
		mmUpdateYookassaSettings.defaultExpectation.paramPtrs = &RepositoryMockUpdateYookassaSettingsParamPtrs{}
	}
	mmUpdateYookassaSettings.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateYookassaSettings.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateYookassaSettings
}

// ExpectSettingsParam2 sets up expected param settings for Repository.UpdateYookassaSettings
func (mmUpdateYookassaSettings *mRepositoryMockUpdateYookassaSettings) ExpectSettingsParam2(settings *models.YookassaSettings) *mRepositoryMockUpdateYookassaSettings {
	if mmUpdateYookassaSettings.mock.funcUpdateYookassaSettings != nil {
		mmUpdateYookassaSettings.mock.t.Fatalf("RepositoryMock.UpdateYookassaSettings mock is already set by Set")
	}

	if mmUpdateYookassaSettings.defaultExpectation == nil {
		mmUpdateYookassaSettings.defaultExpectation = &RepositoryMockUpdateYookassaSettingsExpectation{}
	}

	if mmUpdateYookassaSettings.defaultExpectation.params != nil {
		mmUpdateYookassaSettings.mock.t.Fatalf("RepositoryMock.UpdateYookassaSettings mock is already set by Expect")
	}

	if mmUpdateYookassaSettings.defaultExpectation.paramPtrs == nil {
		mmUpdateYookassaSettings.defaultExpectation.paramPtrs = &RepositoryMockUpdateYookassaSettingsParamPtrs{}
	}
	mmUpdateYookassaSettings.defaultExpectation.paramPtrs.settings = &settings
	mmUpdateYookassaSettings.defaultExpectation.expectationOrigins.originSettings = minimock.CallerInfo(1)

	return mmUpdateYookassaSettings
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateYookassaSettings
func (mmUpdateYookassaSettings *mRepositoryMockUpdateYookassaSettings) Inspect(f func(ctx context.Context, settings *models.YookassaSettings)) *mRepositoryMockUpdateYookassaSettings {
	if mmUpdateYookassaSettings.mock.inspectFuncUpdateYookassaSettings != nil {
		mmUpdateYookassaSettings.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateYookassaSettings")
	}

	mmUpdateYookassaSettings.mock.inspectFuncUpdateYookassaSettings = f

	return mmUpdateYookassaSettings
}

// Return sets up results that will be returned by Repository.UpdateYookassaSettings
func (mmUpdateYookassaSettings *mRepositoryMockUpdateYookassaSettings) Return(err error) *RepositoryMock {
	if mmUpdateYookassaSettings.mock.funcUpdateYookassaSettings != nil {
		mmUpdateYookassaSettings.mock.t.Fatalf("RepositoryMock.UpdateYookassaSettings mock is already set by Set")
	}

	if mmUpdateYookassaSettings.defaultExpectation == nil {
		mmUpdateYookassaSettings.defaultExpectation = &RepositoryMockUpdateYookassaSettingsExpectation{mock: mmUpdateYookassaSettings.mock}
	}
	mmUpdateYookassaSettings.defaultExpectation.results = &RepositoryMockUpdateYookassaSettingsResults{err}
	mmUpdateYookassaSettings.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateYookassaSettings.mock
}

// Set uses given function f to mock the Repository.UpdateYookassaSettings method
func (mmUpdateYookassaSettings *mRepositoryMockUpdateYookassaSettings) Set(f func(ctx context.Context, settings *models.YookassaSettings) (err error)) *RepositoryMock {
	if mmUpdateYookassaSettings.defaultExpectation != nil {
		mmUpdateYookassaSettings.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateYookassaSettings method")
	}

	if len(mmUpdateYookassaSettings.expectations) > 0 {
		mmUpdateYookassaSettings.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateYookassaSettings method")
	}

	mmUpdateYookassaSettings.mock.funcUpdateYookassaSettings = f
	mmUpdateYookassaSettings.mock.funcUpdateYookassaSettingsOrigin = minimock.CallerInfo(1)
	return mmUpdateYookassaSettings.mock
}

// When sets expectation for the Repository.UpdateYookassaSettings which will trigger the result defined by the following
// Then helper
func (mmUpdateYookassaSettings *mRepositoryMockUpdateYookassaSettings) When(ctx context.Context, settings *models.YookassaSettings) *RepositoryMockUpdateYookassaSettingsExpectation {
	if mmUpdateYookassaSettings.mock.funcUpdateYookassaSettings != nil {
		mmUpdateYookassaSettings.mock.t.Fatalf("RepositoryMock.UpdateYookassaSettings mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateYookassaSettingsExpectation{
		mock:               mmUpdateYookassaSettings.mock,
		params:             &RepositoryMockUpdateYookassaSettingsParams{ctx, settings},
		expectationOrigins: RepositoryMockUpdateYookassaSettingsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateYookassaSettings.expectations = append(mmUpdateYookassaSettings.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateYookassaSettings return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateYookassaSettingsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateYookassaSettingsResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateYookassaSettings should be invoked
func (mmUpdateYookassaSettings *mRepositoryMockUpdateYookassaSettings) Times(n uint64) *mRepositoryMockUpdateYookassaSettings {
	if n == 0 {
		mmUpdateYookassaSettings.mock.t.Fatalf("Times of RepositoryMock.UpdateYookassaSettings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateYookassaSettings.expectedInvocations, n)
	mmUpdateYookassaSettings.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateYookassaSettings
}

func (mmUpdateYookassaSettings *mRepositoryMockUpdateYookassaSettings) invocationsDone() bool {
	if len(mmUpdateYookassaSettings.expectations) == 0 && mmUpdateYookassaSettings.defaultExpectation == nil && mmUpdateYookassaSettings.mock.funcUpdateYookassaSettings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateYookassaSettings.mock.afterUpdateYookassaSettingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateYookassaSettings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateYookassaSettings implements mm_repository.Repository
func (mmUpdateYookassaSettings *RepositoryMock) UpdateYookassaSettings(ctx context.Context, settings *models.YookassaSettings) (err error) {
	mm_atomic.AddUint64(&mmUpdateYookassaSettings.beforeUpdateYookassaSettingsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateYookassaSettings.afterUpdateYookassaSettingsCounter, 1)

	mmUpdateYookassaSettings.t.Helper()

	if mmUpdateYookassaSettings.inspectFuncUpdateYookassaSettings != nil {
		mmUpdateYookassaSettings.inspectFuncUpdateYookassaSettings(ctx, settings)
	}

	mm_params := RepositoryMockUpdateYookassaSettingsParams{ctx, settings}

	// Record call args
	mmUpdateYookassaSettings.UpdateYookassaSettingsMock.mutex.Lock()
	mmUpdateYookassaSettings.UpdateYookassaSettingsMock.callArgs = append(mmUpdateYookassaSettings.UpdateYookassaSettingsMock.callArgs, &mm_params)
	mmUpdateYookassaSettings.UpdateYookassaSettingsMock.mutex.Unlock()

	for _, e := range mmUpdateYookassaSettings.UpdateYookassaSettingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateYookassaSettings.UpdateYookassaSettingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateYookassaSettings.UpdateYookassaSettingsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateYookassaSettings.UpdateYookassaSettingsMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateYookassaSettings.UpdateYookassaSettingsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateYookassaSettingsParams{ctx, settings}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateYookassaSettings.t.Errorf("RepositoryMock.UpdateYookassaSettings got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateYookassaSettings.UpdateYookassaSettingsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.settings != nil && !minimock.Equal(*mm_want_ptrs.settings, mm_got.settings) {
				mmUpdateYookassaSettings.t.Errorf("RepositoryMock.UpdateYookassaSettings got unexpected parameter settings, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateYookassaSettings.UpdateYookassaSettingsMock.defaultExpectation.expectationOrigins.originSettings, *mm_want_ptrs.settings, mm_got.settings, minimock.Diff(*mm_want_ptrs.settings, mm_got.settings))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateYookassaSettings.t.Errorf("RepositoryMock.UpdateYookassaSettings got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateYookassaSettings.UpdateYookassaSettingsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateYookassaSettings.UpdateYookassaSettingsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateYookassaSettings.t.Fatal("No results are set for the RepositoryMock.UpdateYookassaSettings")
		}
		return (*mm_results).err
	}
	if mmUpdateYookassaSettings.funcUpdateYookassaSettings != nil {
		return mmUpdateYookassaSettings.funcUpdateYookassaSettings(ctx, settings)
	}
	mmUpdateYookassaSettings.t.Fatalf("Unexpected call to RepositoryMock.UpdateYookassaSettings. %v %v", ctx, settings)
	return
}

// UpdateYookassaSettingsAfterCounter returns a count of finished RepositoryMock.UpdateYookassaSettings invocations
func (mmUpdateYookassaSettings *RepositoryMock) UpdateYookassaSettingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateYookassaSettings.afterUpdateYookassaSettingsCounter)
}

// UpdateYookassaSettingsBeforeCounter returns a count of RepositoryMock.UpdateYookassaSettings invocations
func (mmUpdateYookassaSettings *RepositoryMock) UpdateYookassaSettingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateYookassaSettings.beforeUpdateYookassaSettingsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateYookassaSettings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateYookassaSettings *mRepositoryMockUpdateYookassaSettings) Calls() []*RepositoryMockUpdateYookassaSettingsParams {
	mmUpdateYookassaSettings.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateYookassaSettingsParams, len(mmUpdateYookassaSettings.callArgs))
	copy(argCopy, mmUpdateYookassaSettings.callArgs)

	mmUpdateYookassaSettings.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateYookassaSettingsDone returns true if the count of the UpdateYookassaSettings invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateYookassaSettingsDone() bool {
	if m.UpdateYookassaSettingsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateYookassaSettingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateYookassaSettingsMock.invocationsDone()
}

// MinimockUpdateYookassaSettingsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateYookassaSettingsInspect() {
	for _, e := range m.UpdateYookassaSettingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateYookassaSettings at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateYookassaSettingsCounter := mm_atomic.LoadUint64(&m.afterUpdateYookassaSettingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateYookassaSettingsMock.defaultExpectation != nil && afterUpdateYookassaSettingsCounter < 1 {
		if m.UpdateYookassaSettingsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateYookassaSettings at\n%s", m.UpdateYookassaSettingsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateYookassaSettings at\n%s with params: %#v", m.UpdateYookassaSettingsMock.defaultExpectation.expectationOrigins.origin, *m.UpdateYookassaSettingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateYookassaSettings != nil && afterUpdateYookassaSettingsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateYookassaSettings at\n%s", m.funcUpdateYookassaSettingsOrigin)
	}

	if !m.UpdateYookassaSettingsMock.invocationsDone() && afterUpdateYookassaSettingsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateYookassaSettings at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateYookassaSettingsMock.expectedInvocations), m.UpdateYookassaSettingsMock.expectedInvocationsOrigin, afterUpdateYookassaSettingsCounter)
	}
}

type mRepositoryMockUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUserExpectation
	expectations       []*RepositoryMockUserExpectation

	callArgs []*RepositoryMockUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUserExpectation specifies expectation struct of the Repository.User
type RepositoryMockUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUserParams
	paramPtrs          *RepositoryMockUserParamPtrs
	expectationOrigins RepositoryMockUserExpectationOrigins
	results            *RepositoryMockUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUserParams contains parameters of the Repository.User
type RepositoryMockUserParams struct {
	ctx       context.Context
	userEmail string
}

// RepositoryMockUserParamPtrs contains pointers to parameters of the Repository.User
type RepositoryMockUserParamPtrs struct {
	ctx       *context.Context
	userEmail *string
}

// RepositoryMockUserResults contains results of the Repository.User
type RepositoryMockUserResults struct {
	up1 *models.User
	err error
}

// RepositoryMockUserOrigins contains origins of expectations of the Repository.User
type RepositoryMockUserExpectationOrigins struct {
	origin          string
	originCtx       string
	originUserEmail string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUser *mRepositoryMockUser) Optional() *mRepositoryMockUser {
	mmUser.optional = true
	return mmUser
}

// Expect sets up expected params for Repository.User
func (mmUser *mRepositoryMockUser) Expect(ctx context.Context, userEmail string) *mRepositoryMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &RepositoryMockUserExpectation{}
	}

	if mmUser.defaultExpectation.paramPtrs != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by ExpectParams functions")
	}

	mmUser.defaultExpectation.params = &RepositoryMockUserParams{ctx, userEmail}
	mmUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUser.expectations {
		if minimock.Equal(e.params, mmUser.defaultExpectation.params) {
			mmUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUser.defaultExpectation.params)
		}
	}

	return mmUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.User
func (mmUser *mRepositoryMockUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &RepositoryMockUserExpectation{}
	}

	if mmUser.defaultExpectation.params != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Expect")
	}

	if mmUser.defaultExpectation.paramPtrs == nil {
		mmUser.defaultExpectation.paramPtrs = &RepositoryMockUserParamPtrs{}
	}
	mmUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUser
}

// ExpectUserEmailParam2 sets up expected param userEmail for Repository.User
func (mmUser *mRepositoryMockUser) ExpectUserEmailParam2(userEmail string) *mRepositoryMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &RepositoryMockUserExpectation{}
	}

	if mmUser.defaultExpectation.params != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Expect")
	}

	if mmUser.defaultExpectation.paramPtrs == nil {
		mmUser.defaultExpectation.paramPtrs = &RepositoryMockUserParamPtrs{}
	}
	mmUser.defaultExpectation.paramPtrs.userEmail = &userEmail
	mmUser.defaultExpectation.expectationOrigins.originUserEmail = minimock.CallerInfo(1)

	return mmUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.User
func (mmUser *mRepositoryMockUser) Inspect(f func(ctx context.Context, userEmail string)) *mRepositoryMockUser {
	if mmUser.mock.inspectFuncUser != nil {
		mmUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.User")
	}

	mmUser.mock.inspectFuncUser = f

	return mmUser
}

// Return sets up results that will be returned by Repository.User
func (mmUser *mRepositoryMockUser) Return(up1 *models.User, err error) *RepositoryMock {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &RepositoryMockUserExpectation{mock: mmUser.mock}
	}
	mmUser.defaultExpectation.results = &RepositoryMockUserResults{up1, err}
	mmUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUser.mock
}

// Set uses given function f to mock the Repository.User method
func (mmUser *mRepositoryMockUser) Set(f func(ctx context.Context, userEmail string) (up1 *models.User, err error)) *RepositoryMock {
	if mmUser.defaultExpectation != nil {
		mmUser.mock.t.Fatalf("Default expectation is already set for the Repository.User method")
	}

	if len(mmUser.expectations) > 0 {
		mmUser.mock.t.Fatalf("Some expectations are already set for the Repository.User method")
	}

	mmUser.mock.funcUser = f
	mmUser.mock.funcUserOrigin = minimock.CallerInfo(1)
	return mmUser.mock
}

// When sets expectation for the Repository.User which will trigger the result defined by the following
// Then helper
func (mmUser *mRepositoryMockUser) When(ctx context.Context, userEmail string) *RepositoryMockUserExpectation {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Set")
	}

	expectation := &RepositoryMockUserExpectation{
		mock:               mmUser.mock,
		params:             &RepositoryMockUserParams{ctx, userEmail},
		expectationOrigins: RepositoryMockUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUser.expectations = append(mmUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.User return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUserExpectation) Then(up1 *models.User, err error) *RepositoryMock {
	e.results = &RepositoryMockUserResults{up1, err}
	return e.mock
}

// Times sets number of times Repository.User should be invoked
func (mmUser *mRepositoryMockUser) Times(n uint64) *mRepositoryMockUser {
	if n == 0 {
		mmUser.mock.t.Fatalf("Times of RepositoryMock.User mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUser.expectedInvocations, n)
	mmUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUser
}

func (mmUser *mRepositoryMockUser) invocationsDone() bool {
	if len(mmUser.expectations) == 0 && mmUser.defaultExpectation == nil && mmUser.mock.funcUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUser.mock.afterUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// User implements mm_repository.Repository
func (mmUser *RepositoryMock) User(ctx context.Context, userEmail string) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmUser.beforeUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUser.afterUserCounter, 1)

	mmUser.t.Helper()

	if mmUser.inspectFuncUser != nil {
		mmUser.inspectFuncUser(ctx, userEmail)
	}

	mm_params := RepositoryMockUserParams{ctx, userEmail}

	// Record call args
	mmUser.UserMock.mutex.Lock()
	mmUser.UserMock.callArgs = append(mmUser.UserMock.callArgs, &mm_params)
	mmUser.UserMock.mutex.Unlock()

	for _, e := range mmUser.UserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUser.UserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUser.UserMock.defaultExpectation.Counter, 1)
		mm_want := mmUser.UserMock.defaultExpectation.params
		mm_want_ptrs := mmUser.UserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUserParams{ctx, userEmail}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUser.t.Errorf("RepositoryMock.User got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUser.UserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userEmail != nil && !minimock.Equal(*mm_want_ptrs.userEmail, mm_got.userEmail) {
				mmUser.t.Errorf("RepositoryMock.User got unexpected parameter userEmail, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUser.UserMock.defaultExpectation.expectationOrigins.originUserEmail, *mm_want_ptrs.userEmail, mm_got.userEmail, minimock.Diff(*mm_want_ptrs.userEmail, mm_got.userEmail))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUser.t.Errorf("RepositoryMock.User got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUser.UserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUser.UserMock.defaultExpectation.results
		if mm_results == nil {
			mmUser.t.Fatal("No results are set for the RepositoryMock.User")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUser.funcUser != nil {
		return mmUser.funcUser(ctx, userEmail)
	}
	mmUser.t.Fatalf("Unexpected call to RepositoryMock.User. %v %v", ctx, userEmail)
	return
}

// UserAfterCounter returns a count of finished RepositoryMock.User invocations
func (mmUser *RepositoryMock) UserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.afterUserCounter)
}

// UserBeforeCounter returns a count of RepositoryMock.User invocations
func (mmUser *RepositoryMock) UserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.beforeUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.User.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUser *mRepositoryMockUser) Calls() []*RepositoryMockUserParams {
	mmUser.mutex.RLock()

	argCopy := make([]*RepositoryMockUserParams, len(mmUser.callArgs))
	copy(argCopy, mmUser.callArgs)

	mmUser.mutex.RUnlock()

	return argCopy
}

// MinimockUserDone returns true if the count of the User invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUserDone() bool {
	if m.UserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserMock.invocationsDone()
}

// MinimockUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUserInspect() {
	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.User at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserCounter := mm_atomic.LoadUint64(&m.afterUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserMock.defaultExpectation != nil && afterUserCounter < 1 {
		if m.UserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.User at\n%s", m.UserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.User at\n%s with params: %#v", m.UserMock.defaultExpectation.expectationOrigins.origin, *m.UserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUser != nil && afterUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.User at\n%s", m.funcUserOrigin)
	}

	if !m.UserMock.invocationsDone() && afterUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.User at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserMock.expectedInvocations), m.UserMock.expectedInvocationsOrigin, afterUserCounter)
	}
}

type mRepositoryMockUserEvents struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUserEventsExpectation
	expectations       []*RepositoryMockUserEventsExpectation

	callArgs []*RepositoryMockUserEventsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUserEventsExpectation specifies expectation struct of the Repository.UserEvents
type RepositoryMockUserEventsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUserEventsParams
	paramPtrs          *RepositoryMockUserEventsParamPtrs
	expectationOrigins RepositoryMockUserEventsExpectationOrigins
	results            *RepositoryMockUserEventsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUserEventsParams contains parameters of the Repository.UserEvents
type RepositoryMockUserEventsParams struct {
	ctx    context.Context
	userID int64
}

// RepositoryMockUserEventsParamPtrs contains pointers to parameters of the Repository.UserEvents
type RepositoryMockUserEventsParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// RepositoryMockUserEventsResults contains results of the Repository.UserEvents
type RepositoryMockUserEventsResults struct {
	epa1 []*models.Event
	err  error
}

// RepositoryMockUserEventsOrigins contains origins of expectations of the Repository.UserEvents
type RepositoryMockUserEventsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserEvents *mRepositoryMockUserEvents) Optional() *mRepositoryMockUserEvents {
	mmUserEvents.optional = true
	return mmUserEvents
}

// Expect sets up expected params for Repository.UserEvents
func (mmUserEvents *mRepositoryMockUserEvents) Expect(ctx context.Context, userID int64) *mRepositoryMockUserEvents {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("RepositoryMock.UserEvents mock is already set by Set")
	}

	if mmUserEvents.defaultExpectation == nil {
		mmUserEvents.defaultExpectation = &RepositoryMockUserEventsExpectation{}
	}

	if mmUserEvents.defaultExpectation.paramPtrs != nil {
		mmUserEvents.mock.t.Fatalf("RepositoryMock.UserEvents mock is already set by ExpectParams functions")
	}

	mmUserEvents.defaultExpectation.params = &RepositoryMockUserEventsParams{ctx, userID}
	mmUserEvents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserEvents.expectations {
		if minimock.Equal(e.params, mmUserEvents.defaultExpectation.params) {
			mmUserEvents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserEvents.defaultExpectation.params)
		}
	}

	return mmUserEvents
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UserEvents
func (mmUserEvents *mRepositoryMockUserEvents) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUserEvents {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("RepositoryMock.UserEvents mock is already set by Set")
	}

	if mmUserEvents.defaultExpectation == nil {
		mmUserEvents.defaultExpectation = &RepositoryMockUserEventsExpectation{}
	}

	if mmUserEvents.defaultExpectation.params != nil {
		mmUserEvents.mock.t.Fatalf("RepositoryMock.UserEvents mock is already set by Expect")
	}

	if mmUserEvents.defaultExpectation.paramPtrs == nil {
		mmUserEvents.defaultExpectation.paramPtrs = &RepositoryMockUserEventsParamPtrs{}
	}
	mmUserEvents.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserEvents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserEvents
}

// ExpectUserIDParam2 sets up expected param userID for Repository.UserEvents
func (mmUserEvents *mRepositoryMockUserEvents) ExpectUserIDParam2(userID int64) *mRepositoryMockUserEvents {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("RepositoryMock.UserEvents mock is already set by Set")
	}

	if mmUserEvents.defaultExpectation == nil {
		mmUserEvents.defaultExpectation = &RepositoryMockUserEventsExpectation{}
	}

	if mmUserEvents.defaultExpectation.params != nil {
		mmUserEvents.mock.t.Fatalf("RepositoryMock.UserEvents mock is already set by Expect")
	}

	if mmUserEvents.defaultExpectation.paramPtrs == nil {
		mmUserEvents.defaultExpectation.paramPtrs = &RepositoryMockUserEventsParamPtrs{}
	}
	mmUserEvents.defaultExpectation.paramPtrs.userID = &userID
	mmUserEvents.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUserEvents
}

// Inspect accepts an inspector function that has same arguments as the Repository.UserEvents
func (mmUserEvents *mRepositoryMockUserEvents) Inspect(f func(ctx context.Context, userID int64)) *mRepositoryMockUserEvents {
	if mmUserEvents.mock.inspectFuncUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UserEvents")
	}

	mmUserEvents.mock.inspectFuncUserEvents = f

	return mmUserEvents
}

// Return sets up results that will be returned by Repository.UserEvents
func (mmUserEvents *mRepositoryMockUserEvents) Return(epa1 []*models.Event, err error) *RepositoryMock {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("RepositoryMock.UserEvents mock is already set by Set")
	}

	if mmUserEvents.defaultExpectation == nil {
		mmUserEvents.defaultExpectation = &RepositoryMockUserEventsExpectation{mock: mmUserEvents.mock}
	}
	mmUserEvents.defaultExpectation.results = &RepositoryMockUserEventsResults{epa1, err}
	mmUserEvents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserEvents.mock
}

// Set uses given function f to mock the Repository.UserEvents method
func (mmUserEvents *mRepositoryMockUserEvents) Set(f func(ctx context.Context, userID int64) (epa1 []*models.Event, err error)) *RepositoryMock {
	if mmUserEvents.defaultExpectation != nil {
		mmUserEvents.mock.t.Fatalf("Default expectation is already set for the Repository.UserEvents method")
	}

	if len(mmUserEvents.expectations) > 0 {
		mmUserEvents.mock.t.Fatalf("Some expectations are already set for the Repository.UserEvents method")
	}

	mmUserEvents.mock.funcUserEvents = f
	mmUserEvents.mock.funcUserEventsOrigin = minimock.CallerInfo(1)
	return mmUserEvents.mock
}

// When sets expectation for the Repository.UserEvents which will trigger the result defined by the following
// Then helper
func (mmUserEvents *mRepositoryMockUserEvents) When(ctx context.Context, userID int64) *RepositoryMockUserEventsExpectation {
	if mmUserEvents.mock.funcUserEvents != nil {
		mmUserEvents.mock.t.Fatalf("RepositoryMock.UserEvents mock is already set by Set")
	}

	expectation := &RepositoryMockUserEventsExpectation{
		mock:               mmUserEvents.mock,
		params:             &RepositoryMockUserEventsParams{ctx, userID},
		expectationOrigins: RepositoryMockUserEventsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserEvents.expectations = append(mmUserEvents.expectations, expectation)
	return expectation
}

// Then sets up Repository.UserEvents return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUserEventsExpectation) Then(epa1 []*models.Event, err error) *RepositoryMock {
	e.results = &RepositoryMockUserEventsResults{epa1, err}
	return e.mock
}

// Times sets number of times Repository.UserEvents should be invoked
func (mmUserEvents *mRepositoryMockUserEvents) Times(n uint64) *mRepositoryMockUserEvents {
	if n == 0 {
		mmUserEvents.mock.t.Fatalf("Times of RepositoryMock.UserEvents mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserEvents.expectedInvocations, n)
	mmUserEvents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserEvents
}

func (mmUserEvents *mRepositoryMockUserEvents) invocationsDone() bool {
	if len(mmUserEvents.expectations) == 0 && mmUserEvents.defaultExpectation == nil && mmUserEvents.mock.funcUserEvents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserEvents.mock.afterUserEventsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserEvents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserEvents implements mm_repository.Repository
func (mmUserEvents *RepositoryMock) UserEvents(ctx context.Context, userID int64) (epa1 []*models.Event, err error) {
	mm_atomic.AddUint64(&mmUserEvents.beforeUserEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmUserEvents.afterUserEventsCounter, 1)

	mmUserEvents.t.Helper()

	if mmUserEvents.inspectFuncUserEvents != nil {
		mmUserEvents.inspectFuncUserEvents(ctx, userID)
	}

	mm_params := RepositoryMockUserEventsParams{ctx, userID}

	// Record call args
	mmUserEvents.UserEventsMock.mutex.Lock()
	mmUserEvents.UserEventsMock.callArgs = append(mmUserEvents.UserEventsMock.callArgs, &mm_params)
	mmUserEvents.UserEventsMock.mutex.Unlock()

	for _, e := range mmUserEvents.UserEventsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.epa1, e.results.err
		}
	}

	if mmUserEvents.UserEventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserEvents.UserEventsMock.defaultExpectation.Counter, 1)
		mm_want := mmUserEvents.UserEventsMock.defaultExpectation.params
		mm_want_ptrs := mmUserEvents.UserEventsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUserEventsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserEvents.t.Errorf("RepositoryMock.UserEvents got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserEvents.UserEventsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUserEvents.t.Errorf("RepositoryMock.UserEvents got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserEvents.UserEventsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserEvents.t.Errorf("RepositoryMock.UserEvents got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserEvents.UserEventsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserEvents.UserEventsMock.defaultExpectation.results
		if mm_results == nil {
			mmUserEvents.t.Fatal("No results are set for the RepositoryMock.UserEvents")
		}
		return (*mm_results).epa1, (*mm_results).err
	}
	if mmUserEvents.funcUserEvents != nil {
		return mmUserEvents.funcUserEvents(ctx, userID)
	}
	mmUserEvents.t.Fatalf("Unexpected call to RepositoryMock.UserEvents. %v %v", ctx, userID)
	return
}

// UserEventsAfterCounter returns a count of finished RepositoryMock.UserEvents invocations
func (mmUserEvents *RepositoryMock) UserEventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserEvents.afterUserEventsCounter)
}

// UserEventsBeforeCounter returns a count of RepositoryMock.UserEvents invocations
func (mmUserEvents *RepositoryMock) UserEventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserEvents.beforeUserEventsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UserEvents.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserEvents *mRepositoryMockUserEvents) Calls() []*RepositoryMockUserEventsParams {
	mmUserEvents.mutex.RLock()

	argCopy := make([]*RepositoryMockUserEventsParams, len(mmUserEvents.callArgs))
	copy(argCopy, mmUserEvents.callArgs)

	mmUserEvents.mutex.RUnlock()

	return argCopy
}

// MinimockUserEventsDone returns true if the count of the UserEvents invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUserEventsDone() bool {
	if m.UserEventsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserEventsMock.invocationsDone()
}

// MinimockUserEventsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUserEventsInspect() {
	for _, e := range m.UserEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UserEvents at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserEventsCounter := mm_atomic.LoadUint64(&m.afterUserEventsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserEventsMock.defaultExpectation != nil && afterUserEventsCounter < 1 {
		if m.UserEventsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UserEvents at\n%s", m.UserEventsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UserEvents at\n%s with params: %#v", m.UserEventsMock.defaultExpectation.expectationOrigins.origin, *m.UserEventsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserEvents != nil && afterUserEventsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UserEvents at\n%s", m.funcUserEventsOrigin)
	}

	if !m.UserEventsMock.invocationsDone() && afterUserEventsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UserEvents at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserEventsMock.expectedInvocations), m.UserEventsMock.expectedInvocationsOrigin, afterUserEventsCounter)
	}
}

type mRepositoryMockUserTickets struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUserTicketsExpectation
	expectations       []*RepositoryMockUserTicketsExpectation

	callArgs []*RepositoryMockUserTicketsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUserTicketsExpectation specifies expectation struct of the Repository.UserTickets
type RepositoryMockUserTicketsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUserTicketsParams
	paramPtrs          *RepositoryMockUserTicketsParamPtrs
	expectationOrigins RepositoryMockUserTicketsExpectationOrigins
	results            *RepositoryMockUserTicketsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUserTicketsParams contains parameters of the Repository.UserTickets
type RepositoryMockUserTicketsParams struct {
	ctx    context.Context
	userID int64
}

// RepositoryMockUserTicketsParamPtrs contains pointers to parameters of the Repository.UserTickets
type RepositoryMockUserTicketsParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// RepositoryMockUserTicketsResults contains results of the Repository.UserTickets
type RepositoryMockUserTicketsResults struct {
	tpa1 []*models.Ticket
	err  error
}

// RepositoryMockUserTicketsOrigins contains origins of expectations of the Repository.UserTickets
type RepositoryMockUserTicketsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserTickets *mRepositoryMockUserTickets) Optional() *mRepositoryMockUserTickets {
	mmUserTickets.optional = true
	return mmUserTickets
}

// Expect sets up expected params for Repository.UserTickets
func (mmUserTickets *mRepositoryMockUserTickets) Expect(ctx context.Context, userID int64) *mRepositoryMockUserTickets {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("RepositoryMock.UserTickets mock is already set by Set")
	}

	if mmUserTickets.defaultExpectation == nil {
		mmUserTickets.defaultExpectation = &RepositoryMockUserTicketsExpectation{}
	}

	if mmUserTickets.defaultExpectation.paramPtrs != nil {
		mmUserTickets.mock.t.Fatalf("RepositoryMock.UserTickets mock is already set by ExpectParams functions")
	}

	mmUserTickets.defaultExpectation.params = &RepositoryMockUserTicketsParams{ctx, userID}
	mmUserTickets.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserTickets.expectations {
		if minimock.Equal(e.params, mmUserTickets.defaultExpectation.params) {
			mmUserTickets.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserTickets.defaultExpectation.params)
		}
	}

	return mmUserTickets
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UserTickets
func (mmUserTickets *mRepositoryMockUserTickets) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUserTickets {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("RepositoryMock.UserTickets mock is already set by Set")
	}

	if mmUserTickets.defaultExpectation == nil {
		mmUserTickets.defaultExpectation = &RepositoryMockUserTicketsExpectation{}
	}

	if mmUserTickets.defaultExpectation.params != nil {
		mmUserTickets.mock.t.Fatalf("RepositoryMock.UserTickets mock is already set by Expect")
	}

	if mmUserTickets.defaultExpectation.paramPtrs == nil {
		mmUserTickets.defaultExpectation.paramPtrs = &RepositoryMockUserTicketsParamPtrs{}
	}
	mmUserTickets.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserTickets.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserTickets
}

// ExpectUserIDParam2 sets up expected param userID for Repository.UserTickets
func (mmUserTickets *mRepositoryMockUserTickets) ExpectUserIDParam2(userID int64) *mRepositoryMockUserTickets {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("RepositoryMock.UserTickets mock is already set by Set")
	}

	if mmUserTickets.defaultExpectation == nil {
		mmUserTickets.defaultExpectation = &RepositoryMockUserTicketsExpectation{}
	}

	if mmUserTickets.defaultExpectation.params != nil {
		mmUserTickets.mock.t.Fatalf("RepositoryMock.UserTickets mock is already set by Expect")
	}

	if mmUserTickets.defaultExpectation.paramPtrs == nil {
		mmUserTickets.defaultExpectation.paramPtrs = &RepositoryMockUserTicketsParamPtrs{}
	}
	mmUserTickets.defaultExpectation.paramPtrs.userID = &userID
	mmUserTickets.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUserTickets
}

// Inspect accepts an inspector function that has same arguments as the Repository.UserTickets
func (mmUserTickets *mRepositoryMockUserTickets) Inspect(f func(ctx context.Context, userID int64)) *mRepositoryMockUserTickets {
	if mmUserTickets.mock.inspectFuncUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UserTickets")
	}

	mmUserTickets.mock.inspectFuncUserTickets = f

	return mmUserTickets
}

// Return sets up results that will be returned by Repository.UserTickets
func (mmUserTickets *mRepositoryMockUserTickets) Return(tpa1 []*models.Ticket, err error) *RepositoryMock {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("RepositoryMock.UserTickets mock is already set by Set")
	}

	if mmUserTickets.defaultExpectation == nil {
		mmUserTickets.defaultExpectation = &RepositoryMockUserTicketsExpectation{mock: mmUserTickets.mock}
	}
	mmUserTickets.defaultExpectation.results = &RepositoryMockUserTicketsResults{tpa1, err}
	mmUserTickets.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserTickets.mock
}

// Set uses given function f to mock the Repository.UserTickets method
func (mmUserTickets *mRepositoryMockUserTickets) Set(f func(ctx context.Context, userID int64) (tpa1 []*models.Ticket, err error)) *RepositoryMock {
	if mmUserTickets.defaultExpectation != nil {
		mmUserTickets.mock.t.Fatalf("Default expectation is already set for the Repository.UserTickets method")
	}

	if len(mmUserTickets.expectations) > 0 {
		mmUserTickets.mock.t.Fatalf("Some expectations are already set for the Repository.UserTickets method")
	}

	mmUserTickets.mock.funcUserTickets = f
	mmUserTickets.mock.funcUserTicketsOrigin = minimock.CallerInfo(1)
	return mmUserTickets.mock
}

// When sets expectation for the Repository.UserTickets which will trigger the result defined by the following
// Then helper
func (mmUserTickets *mRepositoryMockUserTickets) When(ctx context.Context, userID int64) *RepositoryMockUserTicketsExpectation {
	if mmUserTickets.mock.funcUserTickets != nil {
		mmUserTickets.mock.t.Fatalf("RepositoryMock.UserTickets mock is already set by Set")
	}

	expectation := &RepositoryMockUserTicketsExpectation{
		mock:               mmUserTickets.mock,
		params:             &RepositoryMockUserTicketsParams{ctx, userID},
		expectationOrigins: RepositoryMockUserTicketsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserTickets.expectations = append(mmUserTickets.expectations, expectation)
	return expectation
}

// Then sets up Repository.UserTickets return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUserTicketsExpectation) Then(tpa1 []*models.Ticket, err error) *RepositoryMock {
	e.results = &RepositoryMockUserTicketsResults{tpa1, err}
	return e.mock
}

// Times sets number of times Repository.UserTickets should be invoked
func (mmUserTickets *mRepositoryMockUserTickets) Times(n uint64) *mRepositoryMockUserTickets {
	if n == 0 {
		mmUserTickets.mock.t.Fatalf("Times of RepositoryMock.UserTickets mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserTickets.expectedInvocations, n)
	mmUserTickets.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserTickets
}

func (mmUserTickets *mRepositoryMockUserTickets) invocationsDone() bool {
	if len(mmUserTickets.expectations) == 0 && mmUserTickets.defaultExpectation == nil && mmUserTickets.mock.funcUserTickets == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserTickets.mock.afterUserTicketsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserTickets.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserTickets implements mm_repository.Repository
func (mmUserTickets *RepositoryMock) UserTickets(ctx context.Context, userID int64) (tpa1 []*models.Ticket, err error) {
	mm_atomic.AddUint64(&mmUserTickets.beforeUserTicketsCounter, 1)
	defer mm_atomic.AddUint64(&mmUserTickets.afterUserTicketsCounter, 1)

	mmUserTickets.t.Helper()

	if mmUserTickets.inspectFuncUserTickets != nil {
		mmUserTickets.inspectFuncUserTickets(ctx, userID)
	}

	mm_params := RepositoryMockUserTicketsParams{ctx, userID}

	// Record call args
	mmUserTickets.UserTicketsMock.mutex.Lock()
	mmUserTickets.UserTicketsMock.callArgs = append(mmUserTickets.UserTicketsMock.callArgs, &mm_params)
	mmUserTickets.UserTicketsMock.mutex.Unlock()

	for _, e := range mmUserTickets.UserTicketsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmUserTickets.UserTicketsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserTickets.UserTicketsMock.defaultExpectation.Counter, 1)
		mm_want := mmUserTickets.UserTicketsMock.defaultExpectation.params
		mm_want_ptrs := mmUserTickets.UserTicketsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUserTicketsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserTickets.t.Errorf("RepositoryMock.UserTickets got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserTickets.UserTicketsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUserTickets.t.Errorf("RepositoryMock.UserTickets got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserTickets.UserTicketsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserTickets.t.Errorf("RepositoryMock.UserTickets got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserTickets.UserTicketsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserTickets.UserTicketsMock.defaultExpectation.results
		if mm_results == nil {
			mmUserTickets.t.Fatal("No results are set for the RepositoryMock.UserTickets")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmUserTickets.funcUserTickets != nil {
		return mmUserTickets.funcUserTickets(ctx, userID)
	}
	mmUserTickets.t.Fatalf("Unexpected call to RepositoryMock.UserTickets. %v %v", ctx, userID)
	return
}

// UserTicketsAfterCounter returns a count of finished RepositoryMock.UserTickets invocations
func (mmUserTickets *RepositoryMock) UserTicketsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserTickets.afterUserTicketsCounter)
}

// UserTicketsBeforeCounter returns a count of RepositoryMock.UserTickets invocations
func (mmUserTickets *RepositoryMock) UserTicketsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserTickets.beforeUserTicketsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UserTickets.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserTickets *mRepositoryMockUserTickets) Calls() []*RepositoryMockUserTicketsParams {
	mmUserTickets.mutex.RLock()

	argCopy := make([]*RepositoryMockUserTicketsParams, len(mmUserTickets.callArgs))
	copy(argCopy, mmUserTickets.callArgs)

	mmUserTickets.mutex.RUnlock()

	return argCopy
}

// MinimockUserTicketsDone returns true if the count of the UserTickets invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUserTicketsDone() bool {
	if m.UserTicketsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserTicketsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserTicketsMock.invocationsDone()
}

// MinimockUserTicketsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUserTicketsInspect() {
	for _, e := range m.UserTicketsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UserTickets at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserTicketsCounter := mm_atomic.LoadUint64(&m.afterUserTicketsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserTicketsMock.defaultExpectation != nil && afterUserTicketsCounter < 1 {
		if m.UserTicketsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UserTickets at\n%s", m.UserTicketsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UserTickets at\n%s with params: %#v", m.UserTicketsMock.defaultExpectation.expectationOrigins.origin, *m.UserTicketsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserTickets != nil && afterUserTicketsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UserTickets at\n%s", m.funcUserTicketsOrigin)
	}

	if !m.UserTicketsMock.invocationsDone() && afterUserTicketsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UserTickets at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserTicketsMock.expectedInvocations), m.UserTicketsMock.expectedInvocationsOrigin, afterUserTicketsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteEventInspect()

			m.MinimockEventByURLTitleInspect()

			m.MinimockEventsInspect()

			m.MinimockInsertEventInspect()

			m.MinimockInsertTicketInspect()

			m.MinimockInsertUserInspect()

			m.MinimockTicketInspect()

			m.MinimockUpdateEventInspect()

			m.MinimockUpdateUserTGUsernameInspect()

			m.MinimockUpdateYookassaSettingsInspect()

			m.MinimockUserInspect()

			m.MinimockUserEventsInspect()

			m.MinimockUserTicketsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteEventDone() &&
		m.MinimockEventByURLTitleDone() &&
		m.MinimockEventsDone() &&
		m.MinimockInsertEventDone() &&
		m.MinimockInsertTicketDone() &&
		m.MinimockInsertUserDone() &&
		m.MinimockTicketDone() &&
		m.MinimockUpdateEventDone() &&
		m.MinimockUpdateUserTGUsernameDone() &&
		m.MinimockUpdateYookassaSettingsDone() &&
		m.MinimockUserDone() &&
		m.MinimockUserEventsDone() &&
		m.MinimockUserTicketsDone()
}
